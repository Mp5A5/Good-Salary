<center>设计模式</center>
=
### 介绍
1. 定义
 * 某类特定问题的代码设计解决方案
 * 是一套代码设计的经验总结
 
  > 设计模式，其实只是前人针对某类问题的代码设计经验而已

2. 作用
 * 提高代码复用性，降低开发成本和周期
 * 提高代码可维护性、可拓展性
 * 使书写的代码更加优雅
 * 是代码更加容易让人理解
 
## 设计模式的设计原则
![avatar](pic/p87.png)

* 单一职责原则

  * 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责
  * 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障
  * 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险
  * 遵循单一职责原的优点有
     * 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多
     * 提高类的可读性，提高系统的可维护性
     * 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响
  
* 里式替换原则
  * 定义1：在软件开发过程中，子类替换父类后，程序的行为是一样的
  * 定义2：只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为
  * 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障
  * 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法【由时候我们可以采用final的手段强制来遵循】
  * 包含含义
     * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
     * 子类中可以增加自己特有的方法
     * 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。【注意区分重载和重写】
     * 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格
 
* 依赖倒置原则
  * 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。通俗的说，即要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合
  * 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险
  * 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率
  * 基于事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
  * 遵循原则
     * 低层模块尽量都要有抽象类或接口，或者两者都有。【可能会被人用到的】
     * 变量的声明类型尽量是抽象类或接口
     * 使用继承时遵循里氏替换原则
  * 核心
     * 就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置

* 接口隔离原则
  * 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上
  * 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法
  * 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
  * 遵循原则
     * 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
     * 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系
     * 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则
  * 和单一职责的区别
     * 单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离
     * 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节;而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建
* 迪米特法则（最小知道原则）
  * 定义：一个对象应该对其他对象保持最少的了解
  * 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大
  * 解决方案：尽量降低类与类之间的耦合
  * 通俗含义：通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部
  
* 开放封闭原则

 * 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。通俗的说，即为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要面向接口编程
  * 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试
  * 解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
  * 表达意思
     * 用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行
     * 回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭
     
### 设计模式分类
![avatar](pic/p88.png)

#### 单例模式

###### 实现方式

1 .实例引入  
背景：小成有一个塑料生产厂，但里面只有一个仓库。  
目的：想用代码来实现仓库的管理  
现有做法： 建立仓库类和工人类  
其中，仓库类里的quantity=商品数量；工人类里有搬运方法MoveIn(int i)和MoveOut(int i)。  
出现的问题：通过测试发现，每次工人搬运操作都会新建一个仓库，就是货物都不是放在同一仓库，这是怎么回事呢？  

``` java
//仓库类
class StoreHouse {
    private int quantity = 100;

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public int getQuantity() {
        return quantity;
    }
}

//搬货工人类
class Carrier{
    public StoreHouse mStoreHouse;
    public Carrier(StoreHouse storeHouse){
        mStoreHouse = storeHouse;
    }
    //搬货进仓库
    public void MoveIn(int i){
        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);
    }
    //搬货出仓库
    public void MoveOut(int i){
        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);
    }
}

//工人搬运测试
public class SinglePattern {
    public static void main(String[] args){
        StoreHouse mStoreHouse1 = new StoreHouse();
        StoreHouse mStoreHouse2 = new StoreHouse();
        Carrier Carrier1 = new Carrier(mStoreHouse1);
        Carrier Carrier2 = new Carrier(mStoreHouse2);

        System.out.println("两个是不是同一个？");

        if(mStoreHouse1.equals(mStoreHouse2)){//这里用equals而不是用 == 符号，因为 == 符号只是比较两个对象的地址
            System.out.println("是同一个");
        }else {
            System.out.println("不是同一个");
        }
        //搬运工搬完货物之后出来汇报仓库商品数量
        Carrier1.MoveIn(30);
        System.out.println("仓库商品余量："+Carrier1.mStoreHouse.getQuantity());
        Carrier2.MoveOut(50);
        System.out.println("仓库商品余量："+Carrier2.mStoreHouse.getQuantity());
    }
}
```
结果：

``` java
两个是不是同一个？
不是同一个
仓库商品余量：130
仓库商品余量：50
```
2 .模式介绍  
2.1 模式说明：实现1个类只有1个实例化对象 & 提供一个全局访问点  
2.2 作用：保证1个类只有1个对象，降低对象之间的耦合度  
2.3 工作原理：  

``` java
public class Singleton {
//1. 创建私有变量 ourInstance（用以记录 Singleton 的唯一实例）
//2. 内部进行实例化
    private static Singleton ourInstance  = new  Singleton();

//3. 把类的构造方法私有化，不让外部调用构造方法实例化
    private Singleton() {
    }
//4. 定义公有方法提供该类的全局唯一访问点
//5. 外部通过调用getInstance()方法来返回唯一的实例
    public static  Singleton newInstance() {
        return ourInstance;
    }
}
```
3 特点：  
3.1 优点：  

* 提供了对唯一实例的受控访问
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能
* 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式

3.2 缺点：  

* 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”
* 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失

4 实现方式  
![avatar](pic/p89.png)

4.1 初始化单例类时 即创建单例  
4.1.1 饿汉式  

* 依赖 JVM类加载机制，保证单例只会被创建1次，即线程安全

> JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化  
> 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化

* 具体实现

``` java
class Singleton {

    // 1. 加载该类时，单例就会自动被创建
    private static  Singleton ourInstance  = new  Singleton();
    
    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
    // 3. 通过调用静态方法获得创建的单例
    public static  Singleton newInstance() {
        return ourInstance;
    }
}
```

* 应用场景
初始化速度快

4.1.2 枚举类型  

* 原理：根据枚举类型的下述特点，满足单例模式所需 创建单例、线程安全、实现简洁的需求

![avatar](pic/p90.png)

* 具体实现

``` java 
public enum SingletonEnum {
  // 定义1个枚举的元素，即为单例类的1个实例
  INSTANCE;

  public void getName() {
    System.out.println("Name");
  }
}
```
注：这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象

4.2 按需、延迟创建单例  
4.2.1 懒汉式  

* 与 饿汉式 最大的区别是：单例创建的时机

> 饿汉式：单例创建时机不可控，即类加载时自动创建单例  
> 懒汉式：单例创建时机可控，即有需要时，才手动创建单例   

* 具体实现

``` java
lass Singleton {
    // 1. 类加载时，先不自动创建单例
   //  即，将单例的引用先赋值为 Null
    private static  Singleton ourInstance  = null；

    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
    // 3. 需要时才手动调用 newInstance（） 创建 单例   
    public static  Singleton newInstance() {
    // 先判断单例是否为空，以避免重复创建
    if( ourInstance == null){
        ourInstance = new Singleton();
        }
        return ourInstance;
    }
}
```

* 缺点  
基础实现的懒汉式是线程不安全的，具体原因如下

![avatar](pic/p91.png)

4.2.2 同步锁  

* 原理：使用同步锁 synchronized锁住 创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建

> 即，getInstance（）方法块只能运行在1个线程中  
> 若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待  
> 而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下 单例对象的唯一性  

* 具体实现

``` java
// 写法1
class Singleton {
    // 1. 类加载时，先不自动创建单例
    //  即，将单例的引用先赋值为 Null
    private static  Singleton ourInstance  = null；
    
    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
// 3. 加入同步锁
public static synchronized Singleton getInstance(){
        // 先判断单例是否为空，以避免重复创建
        if ( ourInstance == null )
            ourInstance = new Singleton();
        return ourInstance;
    }
}


// 写法2
// 该写法的作用与上述写法作用相同，只是写法有所区别
class Singleton{ 

    private static Singleton instance = null;

    private Singleton(){
}

    public static Singleton getInstance(){
        // 加入同步锁
        synchronized(Singleton.class) {
            if (instance == null)
                instance = new Singleton();
        }
        return instance;
    }
}
```

* 缺点：每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能）

> 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步

4.2.3 DCL双重检索(懒汉式的改进)    

* 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能
* 具体实现

``` java
class Singleton {
    private static  volatile  Singleton ourInstance  = null；

    private Singleton() {
    }
    
    public static  Singleton newInstance() {
     // 加入双重校验锁
    // 校验锁1：第1个if
    if( ourInstance == null){  // ①
     synchronized (Singleton.class){ // ②
      // 校验锁2：第2个 if
      if( ourInstance == null){
          ourInstance = new Singleton();
          }
      }
  }
        return ourInstance;
   }
}

// 说明
// 校验锁1：第1个if
// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作
// 即直接跳到执行 return ourInstance

// 校验锁2：第2个 if 
// 作用：防止多次创建单例问题
// 原理
  // 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance()
  // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕
  // 3. 当线程A释放同步锁时，单例已创建，即instance已非空
  // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例
```

* 缺点：实现复杂 = 多种判断，易出错
* volatile作用：以下会涉及到Java内存模型的知识
  * 禁止指令重排序。我们知道new Singleton()是一个非原子操作，编译器可能会重排序【构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成】。而线程B在线程A赋值完时判断instance就不为null了，此时B拿到的将是一个没有初始化完成的半成品。
  * 保证可见性。线程A在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程B在主存中判断instance还是null，那么线程B又将在自己的工作线程中创建一个实例，这样就创建了多个实例。
  * volatile禁止指令重排序只能保证volatile修饰的代码之后的代码不会在它之前执行。

4.2.3 静态内部类

* 根据 静态内部类的特性，同时解决了按需加载、线程安全的问题，同时实现简洁  

> 在静态内部类里创建单例，在装载该内部类时才会去创建单例
> 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例

* 具体实现

``` Java
public class Singleton_InnerClass {

  // 创建静态内部类
  private static class SingleHolder {
    // 在静态内部类里面创建单例
    private static final Singleton_InnerClass INSTANCE = new Singleton_InnerClass();
  }

  private Singleton_InnerClass() {}

  // 延迟加载、按需创建
  public static Singleton_InnerClass newInstance() {
    return SingleHolder.INSTANCE;
  }
}

// 调用过程说明：
      // 1. 外部调用类的newInstance() 
      // 2. 自动调用SingleHolder.INSTANCE
       // 2.1 此时单例类SingleHolder得到初始化
       // 2.2 而该类在装载 & 被初始化时，会初始化它的静态域，从而创建单例；
       // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性
     // 3. 最终只创建1个单例
``` 

5 不使用synchronized和lock，实现一个线程安全的单例 
5.1 实现方式：CAS(Compare And Swap)  
5.2 原理：CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
5.3 具体实现  

```java 
public class Singleton_CAS {

  private static final AtomicReference<Singleton_CAS> INSTANCE = new AtomicReference<>();

  private Singleton_CAS() {}

  public static Singleton_CAS getInstance() {
    for (; ; ) {
      Singleton_CAS singleton = INSTANCE.get();
      if (singleton != null) {
        return singleton;
      }

      singleton = new Singleton_CAS();
      if (INSTANCE.compareAndSet(null, singleton)) {
        return singleton;
      }
    }
  }
}
```

5.4 优缺点  

* 用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度
* CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销
* 另外，如果N个线程同时执行到singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出

6 总结  

![avatar](pic/p92.png)

#### 工厂模式
1. 引言
1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。  
2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。  
3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。  
4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。  
   最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.  
这就是工厂模式。  

2. 分类
工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。   
工厂模式可以分为三类：   
1）简单工厂模式（Simple Factory）   
2）工厂方法模式（Factory Method）   
3）抽象工厂模式（Abstract Factory）   
这三种模式从上到下逐步抽象，并且更具一般性。   
GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。  
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。  

3. 区别
工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
两者皆可。 

##### 简单工厂

1. 含义  
简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）  
现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。  
2. 解决的问题  
将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。
即使用者可直接消费产品而不需要知道其生产的细节
3. 模式原理  

3.1 模式组成  

| 组成（角色） | 关系 | 作用 |
| ------ | ------ | ------ |
| 抽象产品（Product） | 具体产品的父类 | 描述产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品 |
| 工厂（Creator） | 被外界调用 | 根据传入不同参数从而创建不同具体产品类的实例 |

3.2 UML类图

![avatar](pic/p93.png)

3.3 使用步骤
创建抽象产品类 & 定义具体产品的公共接口；
创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例
4. 实例
接下来我用一个实例来对简单工厂模式进行更深一步的介绍。
4.1 实例概况
背景：小成有一个塑料生产厂，用来做塑料加工生意
目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产
4.2 使用步骤
实现代码如下：
步骤1. 创建抽象产品类，定义具体产品的公共接口

``` java
abstract class Product{
    public abstract void Show();
}
```

步骤2. 创建具体产品类（继承抽象产品类），定义生产的具体产品

//具体产品类A

``` java
class  ProductA extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
```

//具体产品类B

``` java
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}
```

//具体产品类C

``` java
class  ProductC extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}
```

步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例

``` java
class  Factory {
    public static Product Manufacture(String ProductName){
//工厂类里用switch语句控制生产哪种商品；
//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。
        switch (ProductName){
            case "A":
                return new ProductA();

            case "B":
                return new ProductB();

            case "C":
                return new ProductC();

            default:
                return null;

        }
    }
}
```

步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例

``` java
//工厂产品生产流程
public class SimpleFactoryPattern {
    public static void main(String[] args){
        Factory mFactory = new Factory();

        //客户要产品A
        try {
//调用工厂类的静态方法 & 传入不同参数从而创建产品实例
            mFactory.Manufacture("A").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品B
        try {
            mFactory.Manufacture("B").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品C
        try {
            mFactory.Manufacture("C").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品D
        try {
            mFactory.Manufacture("D").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
    }
}
```

``` java
结果输出：
生产出了产品A
生产出了产品B
生产出了产品C
没有这一类产品
```

5.优点
将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
6. 缺点
工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。
7. 应用场景
客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
当工厂类负责创建的对象（具体产品）比较少时。

##### 工厂方法模式

1.介绍
1.1 定义  
工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。
1.2 主要作用
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。
1.3 解决的问题
简单工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则
> 即简单工厂模式的缺点  
> 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点

2.模式原理
2.1 UML类图

![avatar](pic/p94.png)

2.2 模式组成

| 组成（角色） | 关系 | 作用  |
| :------| :------ | :------ |
| 抽象产品（Product） | 具体产品的父类 | 描述具体产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品 |
| 抽象工厂（Creator） | 具体工厂的父类 | 描述具体工厂的公共接口 |
| 具体工厂（Concrete Creator） | 抽象工厂的子类；被外界调用 | 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 |

2.3 使用步骤
步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
步骤2： 创建抽象产品类 ，定义具体产品的公共接口；
步骤3： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

3.实例讲解
3.1 实例概况
背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；
冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；
解决方案：小成决定置办塑料分厂B来生产B类产品；
>即工厂方法模式

3.2 使用步骤
步骤1： 创建抽象工厂类，定义具体工厂的公共接口

``` java
abstract class Factory{
    public abstract Product Manufacture();
}
```

步骤2： 创建抽象产品类 ，定义具体产品的公共接口；

``` java
abstract class Product{
    public abstract void Show();
}
```

步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；

``` java
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
```

//具体产品B类

``` java
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```


步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；

//工厂A类 - 生产A类产品

``` java
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}
```

//工厂B类 - 生产B类产品

``` java
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```

步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

``` java
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();

        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```
结果：

``` java
生产出了产品A
生产出了产品C
```

4.优点

* 更符合开-闭原则
新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可

> 简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品

>简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。

> 简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

5.缺点
添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
一个具体工厂只能创建一种具体产品

6.应用场景

* 当一个类不知道它所需要的对象的类时
* 在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
* 当一个类希望通过其子类来指定创建对象时
* 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
* 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

