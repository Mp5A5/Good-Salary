### 介绍
1. 定义
 * 某类特定问题的代码设计解决方案
 * 是一套代码设计的经验总结
 
  > 设计模式，其实只是前人针对某类问题的代码设计经验而已

2. 作用
 * 提高代码复用性，降低开发成本和周期
 * 提高代码可维护性、可拓展性
 * 使书写的代码更加优雅
 * 是代码更加容易让人理解
 
## 设计模式的设计原则
![avatar](pic/p87.png)

* 单一职责原则

  * 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责
  * 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障
  * 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险
  * 遵循单一职责原的优点有
     * 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多
     * 提高类的可读性，提高系统的可维护性
     * 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响
  
* 里式替换原则
  * 定义1：在软件开发过程中，子类替换父类后，程序的行为是一样的
  * 定义2：只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为
  * 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障
  * 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法【由时候我们可以采用final的手段强制来遵循】
  * 包含含义
     * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
     * 子类中可以增加自己特有的方法
     * 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。【注意区分重载和重写】
     * 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格
 
* 依赖倒置原则
  * 定义：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
  * 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险
  * 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率
  * 基于事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
  * 遵循原则
     * 低层模块尽量都要有抽象类或接口，或者两者都有。【可能会被人用到的】
     * 变量的声明类型尽量是抽象类或接口
     * 使用继承时遵循里氏替换原则
  * 核心
     * 就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置

* 接口隔离原则
  * 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上
  * 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法
  * 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
  * 遵循原则
     * 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
     * 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系
     * 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则
  * 和单一职责的区别
     * 单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离
     * 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节;而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建
     
* 迪米特法则（最小知道原则）

  * 定义：一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中
  * 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大
  * 解决方案：尽量降低类与类之间的耦合
  * 通俗含义：通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部
  
* 开放封闭原则

 * 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。通俗的说，即为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要面向接口编程
  * 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试
  * 解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
  * 表达意思
     * 用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行
     * 回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭
  
* 合成复用原则（Composite Reuse Principle）
尽量首先使用合成/聚合的方式，而不是使用继承。 
     
### 设计模式分类
![avatar](pic/p88.png)

#### 单例模式

###### 实现方式

1 .实例引入  
背景：小成有一个塑料生产厂，但里面只有一个仓库。  
目的：想用代码来实现仓库的管理  
现有做法： 建立仓库类和工人类  
其中，仓库类里的quantity=商品数量；工人类里有搬运方法MoveIn(int i)和MoveOut(int i)。  
出现的问题：通过测试发现，每次工人搬运操作都会新建一个仓库，就是货物都不是放在同一仓库，这是怎么回事呢？  

``` java
//仓库类
class StoreHouse {
    private int quantity = 100;

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public int getQuantity() {
        return quantity;
    }
}

//搬货工人类
class Carrier{
    public StoreHouse mStoreHouse;
    public Carrier(StoreHouse storeHouse){
        mStoreHouse = storeHouse;
    }
    //搬货进仓库
    public void MoveIn(int i){
        mStoreHouse.setQuantity(mStoreHouse.getQuantity()+i);
    }
    //搬货出仓库
    public void MoveOut(int i){
        mStoreHouse.setQuantity(mStoreHouse.getQuantity()-i);
    }
}

//工人搬运测试
public class SinglePattern {
    public static void main(String[] args){
        StoreHouse mStoreHouse1 = new StoreHouse();
        StoreHouse mStoreHouse2 = new StoreHouse();
        Carrier Carrier1 = new Carrier(mStoreHouse1);
        Carrier Carrier2 = new Carrier(mStoreHouse2);

        System.out.println("两个是不是同一个？");

        if(mStoreHouse1.equals(mStoreHouse2)){//这里用equals而不是用 == 符号，因为 == 符号只是比较两个对象的地址
            System.out.println("是同一个");
        }else {
            System.out.println("不是同一个");
        }
        //搬运工搬完货物之后出来汇报仓库商品数量
        Carrier1.MoveIn(30);
        System.out.println("仓库商品余量："+Carrier1.mStoreHouse.getQuantity());
        Carrier2.MoveOut(50);
        System.out.println("仓库商品余量："+Carrier2.mStoreHouse.getQuantity());
    }
}
```
结果：

``` java
两个是不是同一个？
不是同一个
仓库商品余量：130
仓库商品余量：50
```
2 .模式介绍  
2.1 模式说明：实现1个类只有1个实例化对象 & 提供一个全局访问点  
2.2 作用：保证1个类只有1个对象，降低对象之间的耦合度  
2.3 工作原理：  

``` java
public class Singleton {
//1. 创建私有变量 ourInstance（用以记录 Singleton 的唯一实例）
//2. 内部进行实例化
    private static Singleton ourInstance  = new  Singleton();

//3. 把类的构造方法私有化，不让外部调用构造方法实例化
    private Singleton() {
    }
//4. 定义公有方法提供该类的全局唯一访问点
//5. 外部通过调用getInstance()方法来返回唯一的实例
    public static  Singleton newInstance() {
        return ourInstance;
    }
}
```
3 特点：  
3.1 优点：  

* 提供了对唯一实例的受控访问
* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能
* 可以根据实际情况需要，在单例模式的基础上扩展做出双例模式，多例模式

3.2 缺点：  

* 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了“单一职责原则”
* 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失

4 实现方式  
![avatar](pic/p89.png)

4.1 初始化单例类时 即创建单例  
4.1.1 饿汉式  

* 依赖 JVM类加载机制，保证单例只会被创建1次，即线程安全

> JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化  
> 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化

* 具体实现

``` java
class Singleton {

    // 1. 加载该类时，单例就会自动被创建
    private static  Singleton ourInstance  = new  Singleton();
    
    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
    // 3. 通过调用静态方法获得创建的单例
    public static  Singleton newInstance() {
        return ourInstance;
    }
}
```

* 应用场景
初始化速度快

4.1.2 枚举类型  

* 原理：根据枚举类型的下述特点，满足单例模式所需 创建单例、线程安全、实现简洁的需求

![avatar](pic/p90.png)

* 具体实现

``` java 
public enum SingletonEnum {
  // 定义1个枚举的元素，即为单例类的1个实例
  INSTANCE;

  public void getName() {
    System.out.println("Name");
  }
}
```
注：这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象

4.2 按需、延迟创建单例  
4.2.1 懒汉式  

* 与 饿汉式 最大的区别是：单例创建的时机

> 饿汉式：单例创建时机不可控，即类加载时自动创建单例  
> 懒汉式：单例创建时机可控，即有需要时，才手动创建单例   

* 具体实现

``` java
lass Singleton {
    // 1. 类加载时，先不自动创建单例
   //  即，将单例的引用先赋值为 Null
    private static  Singleton ourInstance  = null；

    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
    // 3. 需要时才手动调用 newInstance（） 创建 单例   
    public static  Singleton newInstance() {
    // 先判断单例是否为空，以避免重复创建
    if( ourInstance == null){
        ourInstance = new Singleton();
        }
        return ourInstance;
    }
}
```

* 缺点  
基础实现的懒汉式是线程不安全的，具体原因如下

![avatar](pic/p91.png)

4.2.2 同步锁  

* 原理：使用同步锁 synchronized锁住 创建单例的方法 ，防止多个线程同时调用，从而避免造成单例被多次创建

> 即，getInstance（）方法块只能运行在1个线程中  
> 若该段代码已在1个线程中运行，另外1个线程试图运行该块代码，则 会被阻塞而一直等待  
> 而在这个线程安全的方法里我们实现了单例的创建，保证了多线程模式下 单例对象的唯一性  

* 具体实现

``` java
// 写法1
class Singleton {
    // 1. 类加载时，先不自动创建单例
    //  即，将单例的引用先赋值为 Null
    private static  Singleton ourInstance  = null；
    
    // 2. 构造函数 设置为 私有权限
    // 原因：禁止他人创建实例 
    private Singleton() {
    }
    
// 3. 加入同步锁
public static synchronized Singleton getInstance(){
        // 先判断单例是否为空，以避免重复创建
        if ( ourInstance == null )
            ourInstance = new Singleton();
        return ourInstance;
    }
}


// 写法2
// 该写法的作用与上述写法作用相同，只是写法有所区别
class Singleton{ 

    private static Singleton instance = null;

    private Singleton(){
}

    public static Singleton getInstance(){
        // 加入同步锁
        synchronized(Singleton.class) {
            if (instance == null)
                instance = new Singleton();
        }
        return instance;
    }
}
```

* 缺点：每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能）

> 实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步

4.2.3 DCL双重检索(懒汉式的改进)    

* 在同步锁的基础上，添加1层 if判断：若单例已创建，则不需再执行加锁操作就可获取实例，从而提高性能
* 具体实现

``` java
class Singleton {
    private static  volatile  Singleton ourInstance  = null；

    private Singleton() {
    }
    
    public static  Singleton newInstance() {
     // 加入双重校验锁
    // 校验锁1：第1个if
    if( ourInstance == null){  // ①
     synchronized (Singleton.class){ // ②
      // 校验锁2：第2个 if
      if( ourInstance == null){
          ourInstance = new Singleton();
          }
      }
  }
        return ourInstance;
   }
}

// 说明
// 校验锁1：第1个if
// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作
// 即直接跳到执行 return ourInstance

// 校验锁2：第2个 if 
// 作用：防止多次创建单例问题
// 原理
  // 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance()
  // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕
  // 3. 当线程A释放同步锁时，单例已创建，即instance已非空
  // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例
```

* 缺点：实现复杂 = 多种判断，易出错
* volatile作用：以下会涉及到Java内存模型的知识
  * 禁止指令重排序。我们知道new Singleton()是一个非原子操作，编译器可能会重排序【构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成】。而线程B在线程A赋值完时判断instance就不为null了，此时B拿到的将是一个没有初始化完成的半成品。
  * 保证可见性。线程A在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程B在主存中判断instance还是null，那么线程B又将在自己的工作线程中创建一个实例，这样就创建了多个实例。
  * volatile禁止指令重排序只能保证volatile修饰的代码之后的代码不会在它之前执行。

4.2.3 静态内部类

* 根据 静态内部类的特性，同时解决了按需加载、线程安全的问题，同时实现简洁  

> 在静态内部类里创建单例，在装载该内部类时才会去创建单例
> 线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例

* 具体实现

``` Java
public class Singleton_InnerClass {

  // 创建静态内部类
  private static class SingleHolder {
    // 在静态内部类里面创建单例
    private static final Singleton_InnerClass INSTANCE = new Singleton_InnerClass();
  }

  private Singleton_InnerClass() {}

  // 延迟加载、按需创建
  public static Singleton_InnerClass newInstance() {
    return SingleHolder.INSTANCE;
  }
}

// 调用过程说明：
      // 1. 外部调用类的newInstance() 
      // 2. 自动调用SingleHolder.INSTANCE
       // 2.1 此时单例类SingleHolder得到初始化
       // 2.2 而该类在装载 & 被初始化时，会初始化它的静态域，从而创建单例；
       // 2.3 由于是静态域，因此只会JVM只会加载1遍，Java虚拟机保证了线程安全性
     // 3. 最终只创建1个单例
``` 

5 不使用synchronized和lock，实现一个线程安全的单例 
5.1 实现方式：CAS(Compare And Swap)  
5.2 原理：CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
5.3 具体实现  

```java 
public class Singleton_CAS {

  private static final AtomicReference<Singleton_CAS> INSTANCE = new AtomicReference<>();

  private Singleton_CAS() {}

  public static Singleton_CAS getInstance() {
    for (; ; ) {
      Singleton_CAS singleton = INSTANCE.get();
      if (singleton != null) {
        return singleton;
      }

      singleton = new Singleton_CAS();
      if (INSTANCE.compareAndSet(null, singleton)) {
        return singleton;
      }
    }
  }
}
```

5.4 优缺点  

* 用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度
* CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销
* 另外，如果N个线程同时执行到singleton = new Singleton();的时候，会有大量对象创建，很可能导致内存溢出

6 总结  

![avatar](pic/p92.png)

#### 工厂模式
1. 引言
1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。  
2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。  
3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。  
4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。  
   最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.  
这就是工厂模式。  

2. 分类
工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。   
工厂模式可以分为三类：   
1）简单工厂模式（Simple Factory）   
2）工厂方法模式（Factory Method）   
3）抽象工厂模式（Abstract Factory）   
这三种模式从上到下逐步抽象，并且更具一般性。   
GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。  
将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。  

3. 区别
工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
两者皆可。 

##### 简单工厂

1. 含义  
简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法）  
现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。  
2. 解决的问题  
将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。
即使用者可直接消费产品而不需要知道其生产的细节
3. 模式原理  

3.1 模式组成  

| 组成（角色） | 关系 | 作用 |
| ------ | ------ | ------ |
| 抽象产品（Product） | 具体产品的父类 | 描述产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品 |
| 工厂（Creator） | 被外界调用 | 根据传入不同参数从而创建不同具体产品类的实例 |

3.2 UML类图

![avatar](pic/p93.png)

3.3 使用步骤
创建抽象产品类 & 定义具体产品的公共接口；
创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例
4. 实例
接下来我用一个实例来对简单工厂模式进行更深一步的介绍。
4.1 实例概况
背景：小成有一个塑料生产厂，用来做塑料加工生意
目的：最近推出了3个产品，小成希望使用简单工厂模式实现3款产品的生产
4.2 使用步骤
实现代码如下：
步骤1. 创建抽象产品类，定义具体产品的公共接口

``` java
abstract class Product{
    public abstract void Show();
}
```

步骤2. 创建具体产品类（继承抽象产品类），定义生产的具体产品

//具体产品类A

``` java
class  ProductA extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
```

//具体产品类B

``` java
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}
```

//具体产品类C

``` java
class  ProductC extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}
```

步骤3. 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例

``` java
class  Factory {
    public static Product Manufacture(String ProductName){
//工厂类里用switch语句控制生产哪种商品；
//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。
        switch (ProductName){
            case "A":
                return new ProductA();

            case "B":
                return new ProductB();

            case "C":
                return new ProductC();

            default:
                return null;

        }
    }
}
```

步骤4. 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例

``` java
//工厂产品生产流程
public class SimpleFactoryPattern {
    public static void main(String[] args){
        Factory mFactory = new Factory();

        //客户要产品A
        try {
//调用工厂类的静态方法 & 传入不同参数从而创建产品实例
            mFactory.Manufacture("A").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品B
        try {
            mFactory.Manufacture("B").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品C
        try {
            mFactory.Manufacture("C").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品D
        try {
            mFactory.Manufacture("D").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
    }
}
```

``` java
结果输出：
生产出了产品A
生产出了产品B
生产出了产品C
没有这一类产品
```

5.优点
将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
6. 缺点
工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。
7. 应用场景
客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
当工厂类负责创建的对象（具体产品）比较少时。

##### 工厂方法模式

1.介绍
1.1 定义  
工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。
1.2 主要作用
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。
1.3 解决的问题
简单工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则
> 即简单工厂模式的缺点  
> 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点

2.模式原理
2.1 UML类图

![avatar](pic/p94.png)

2.2 模式组成

| 组成（角色） | 关系 | 作用  |
| :------| :------ | :------ |
| 抽象产品（Product） | 具体产品的父类 | 描述具体产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品 |
| 抽象工厂（Creator） | 具体工厂的父类 | 描述具体工厂的公共接口 |
| 具体工厂（Concrete Creator） | 抽象工厂的子类；被外界调用 | 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 |

2.3 使用步骤
步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
步骤2： 创建抽象产品类 ，定义具体产品的公共接口；
步骤3： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

3.实例讲解
3.1 实例概况
背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；
冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；
解决方案：小成决定置办塑料分厂B来生产B类产品；
>即工厂方法模式

3.2 使用步骤
步骤1： 创建抽象工厂类，定义具体工厂的公共接口

``` java
abstract class Factory{
    public abstract Product Manufacture();
}
```

步骤2： 创建抽象产品类 ，定义具体产品的公共接口；

``` java
abstract class Product{
    public abstract void Show();
}
```

步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；

``` java
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
```

//具体产品B类

``` java
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```


步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；

//工厂A类 - 生产A类产品

``` java
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}
```

//工厂B类 - 生产B类产品

``` java
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```

步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

``` java
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();

        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```
结果：

``` java
生产出了产品A
生产出了产品B
```

4.优点

* 更符合开-闭原则
新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可

> 简单工厂模式需要修改工厂类的判断逻辑

* 符合单一职责原则
每个具体工厂类只负责创建对应的产品

>简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。

> 简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

5.缺点
添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
一个具体工厂只能创建一种具体产品

6.应用场景

* 当一个类不知道它所需要的对象的类时
* 在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
* 当一个类希望通过其子类来指定创建对象时
* 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
* 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

##### 抽象工厂模式

引言  
在工厂方法模式中，发现工厂方法模式存在一个严重的问题：
一个具体工厂只能创建一类产品
而在实际过程中，一个工厂往往需要生产多类产品。为了解决上述的问题，我们又使用了一种新的设计模式：抽象工厂模式。

1.介绍

1.1 定义
抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。

> 抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类

1.2 主要作用
允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。

1.3 解决的问题
每个工厂只能创建一类产品

>即工厂方法模式的缺点

2.模式原理

2.1 UML类图

![image](pic/p97.png)

2.2 模式组成

| 组成（角色） | 关系 | 作用 |
|  :------ |  :------ | :------ |
| 抽象产品族（AbstractProduct） | 抽象产品的父类 | 描述抽象产品的公共接口 |
| 抽象产品（Product） | 具体产品的父类 | 描述具体产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 | 描述生产的具体产品 |
| 抽象工厂（Creator） | 具体工厂的父类 | 描述具体工厂的公共接口 |
| 具体工厂（Concrete Creator） | 抽象工厂的子类；被外界调用 | 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 |

![image](pic/p98.png)

2.3 使用步骤
步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
步骤2： 创建抽象产品族类 ，定义抽象产品的公共接口；
步骤3： 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；
步骤4： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例

3.实例讲解

3.1 实例概况

背景：小成有两间塑料加工厂（A厂仅生产容器类产品；B厂仅生产模具类产品）；随着客户需求的变化，A厂所在地的客户需要也模具类产品，B厂所在地的客户也需要容器类产品；
冲突：没有资源（资金+租位）在当地分别开设多一家注塑分厂
解决方案：在原有的两家塑料厂里增设生产需求的功能，即A厂能生产容器+模具产品；B厂间能生产模具+容器产品。

3.2 使用步骤

步骤1： 创建抽象工厂类，定义具体工厂的公共接口

``` java
abstract class Factory{
   public abstract Product ManufactureContainer();
    public abstract Product ManufactureMould();
}
```

步骤2： 创建抽象产品族类 ，定义具体产品的公共接口；

``` java
abstract class AbstractProduct{
    public abstract void Show();
}
```

步骤3： 创建抽象产品类 ，定义具体产品的公共接口；

``` java
//容器产品抽象类
abstract class ContainerProduct extends AbstractProduct{
    @Override
    public abstract void Show();
}
```

``` java
//模具产品抽象类
abstract class MouldProduct extends AbstractProduct{
    @Override
    public abstract void Show();
}
```

步骤4： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；

``` java
//容器产品A类
class ContainerProductA extends ContainerProduct{
    @Override
    public void Show() {
        System.out.println("生产出了容器产品A");
    }
}
```

``` java
//容器产品B类
class ContainerProductB extends ContainerProduct{
    @Override
    public void Show() {
        System.out.println("生产出了容器产品B");
    }
}
```

``` 
//模具产品A类
class MouldProductA extends MouldProduct{

    @Override
    public void Show() {
        System.out.println("生产出了模具产品A");
    }
}
```

```
//模具产品B类
class MouldProductB extends MouldProduct{

    @Override
    public void Show() {
        System.out.println("生产出了模具产品B");
    }
}
```

步骤5：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；

```
//A厂 - 生产模具+容器产品
class FactoryA extends Factory{

    @Override
    public Product ManufactureContainer() {
        return new ContainerProductA();
    }

    @Override
    public Product ManufactureMould() {
        return new MouldProductA();
    }
}
```

```
//B厂 - 生产模具+容器产品
class FactoryB extends Factory{

    @Override
    public Product ManufactureContainer() {
        return new ContainerProductB();
    }

    @Override
    public Product ManufactureMould() {
        return new MouldProductB();
    }
}
```

步骤6：客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例

```
//生产工作流程
public class AbstractFactoryPattern {
    public static void main(String[] args){
        FactoryA mFactoryA = new FactoryA();
        FactoryB mFactoryB = new FactoryB();
        //A厂当地客户需要容器产品A
        mFactoryA.ManufactureContainer().Show();
        //A厂当地客户需要模具产品A
        mFactoryA.ManufactureMould().Show();

        //B厂当地客户需要容器产品B
        mFactoryB.ManufactureContainer().Show();
        //B厂当地客户需要模具产品B
        mFactoryB.ManufactureMould().Show();

    }
}
```

结果：

```
生产出了容器产品A
生产出了容器产品B
生产出了模具产品A
生产出了模具产品B
```

4.优点

* 降低耦合

抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；

* 更符合开-闭原则

新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可


>简单工厂模式需要修改工厂类的判断逻辑


* 符合单一职责原则
每个具体工厂类只负责创建对应的产品


> 简单工厂中的工厂类存在复杂的switch逻辑判断

* 不使用静态工厂方法，可以形成基于继承的等级结构。

>简单工厂模式的工厂类使用静态工厂方法


5.缺点

抽象工厂模式很难支持新种类产品的变化。
这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。

>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。

6.应用场景

* 一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。
* 这个系统有多个系列产品，而系统中只消费其中某一系列产品
* 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。

##### 建造者模式

1.简介
1.1 模式说明
隐藏创建对象的建造过程 & 细节，使得用户在不知对象的建造过程 & 细节的情况下，就可直接创建复杂的对象

>用户只需要给出指定复杂对象的类型和内容；
>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)

1.2 作用（解决的问题）

* 降低创建复杂对象的复杂度
* 隔离了创建对象的构建过程 & 表示

从而：

* 方便用户创建复杂的对象（不需要知道实现过程）
* 代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

例子：造汽车 & 买汽车。

工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）
汽车购买者（用户）：你只需要说出你需要的型号（对象的类型和内容），然后直接购买就可以使用了（不需要知道汽车是怎么组装的（车轮、车门、发动机、方向盘等等））

2.模式原理
2.1 UML类图

![image](pic/p101.png)

2.2 模式讲解

指挥者（Director）直接和客户（Client）进行需求沟通；
沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
各个具体建造者负责进行产品部件的构建；
最终构建成具体产品（Product）。

3.实例讲解
3.1 实例概况

* 背景

小成希望去电脑城买一台组装的台式主机

* 过程

电脑城老板（Diretor）和小成（Client）进行需求沟通（买来打游戏？学习？）
了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）
指挥装机人员（ConcreteBuilder）去构建组件；
将组件组装起来成小成需要的电脑（Product）

3.2 使用步骤
步骤1：定义组装的过程（Builder）：组装电脑的过程

```
public  abstract class Builder {  

//第一步：装CPU
//声明为抽象方法，具体由子类实现 
    public abstract void  BuildCPU()；

//第二步：装主板
//声明为抽象方法，具体由子类实现 
    public abstract void BuildMainboard（）；

//第三步：装硬盘
//声明为抽象方法，具体由子类实现 
    public abstract void BuildHD（）；

//返回产品的方法：获得组装好的电脑
    public abstract Computer GetComputer（）；
}
```

步骤2： 电脑城老板委派任务给装机人员（Director）

```
public class Director{
    //指挥装机人员组装电脑
    public void Construct(Builder builder){
            
         builder. BuildCPU();
         builder.BuildMainboard（）;
         builder. BuildHD（）;
    }
 }

```

步骤3： 创建具体的建造者（ConcreteBuilder）:装机人员
  
```
//装机人员1
  public class ConcreteBuilder extend  Builder{
    //创建产品实例
    Computer computer = new Computer();

    //组装产品
    @Override
    public void  BuildCPU(){  
       computer.Add("组装CPU")
    }  

    @Override
    public void  BuildMainboard（）{  
       computer.Add("组装主板")
    }  

    @Override
    public void  BuildHD（）{  
       computer.Add("组装主板")
    }  

    //返回组装成功的电脑
     @Override
      public  Computer GetComputer（）{  
      return computer
    }  
}
```

步骤4： 定义具体产品类（Product）：电脑

```
public class Computer{
    
    //电脑组件的集合
    private List<String> parts = new ArrayList<String>()；
     
    //用于将组件组装到电脑里
    public void Add(String part){
    parts.add(part);
}
    
    public void Show(){
          for (int i = 0;i<parts.size();i++){    
          System.out.println(“组件”+parts.get(i)+“装好了”);
          }
          System.out.println(“电脑组装完成，请验收”);
          
 
}

}

```

步骤5：客户端调用-小成到电脑城找老板买电脑

```
public class Builder Pattern{
  public static void main(String[] args){

//逛了很久终于发现一家合适的电脑店
//找到该店的老板和装机人员
  Director director = new Director();
  Builder builder = new ConcreteBuilder();

//沟通需求后，老板叫装机人员去装电脑
director.Construct(builder);

//装完后，组装人员搬来组装好的电脑
Computer computer = builder.GetComputer();
//组装人员展示电脑给小成看
computer.Show()；

    }
        
}
```
   
结果输出

```
组件CUP装好了
组件主板装好了
组件硬盘装好了
电脑组装完成，请验收
```

整合版

```
ublic class CBuilder {

  private final Computer computer;

  public CBuilder(Computer computer) {
    this.computer = computer;
  }

  public Computer GetComputer() {
    return computer;
  }

  public static class Builder {

    private final Computer computer;

    public Builder() {
      this(new Computer());
    }

    public Builder(Computer computer) {
      this.computer = computer;
    }

    public Builder buildCPU(String str) {
      computer.Add(str);
      return this;
    }

    public Builder buildMainBoard(String str) {
      computer.Add(str);
      return this;
    }

    public Builder BuildHD(String str) {
      computer.Add(str);
      return this;
    }

    public CBuilder build() {
      return new CBuilder(computer);
    }
  }
}
```

##### 原型模式

定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

类型：创建类模式

类图：

![image](pic/p102.png)

1.使用场景

* 资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
* 性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
* 一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。

原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：

* 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。
* 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。

原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。


2.示例：以拳皇游戏中草薙京的复制为例子

```
public class Prototype implements Cloneable {

  private String name;
  private Date birthday;

  @Override
  public Object clone() throws CloneNotSupportedException {
    return super.clone(); // 直接调用Object对象的clone方法
  }

  public Prototype(String name, Date birthday) {
    this.name = name;
    this.birthday = birthday;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Date getBirthday() {
    return birthday;
  }

  public void setBirthday(Date birthday) {
    this.birthday = birthday;
  }
}
```

```
fun main(args: Array<String>) {
    val s1 = Prototype("草薙京", Calendar.getInstance(Locale.CHINA).time)
    val s2 = s1.clone() as Prototype

    println(s1)
    println(s1.name)
    println(s1.birthday)


    println("-----------------------")

    println(s2)
    println(s2.name)
    println(s2.birthday)
}
```

结果：

```
factory.prototype.Prototype@2f92e0f4
草薙京
Sat Jun 22 12:06:29 CST 2019
-----------------------
factory.prototype.Prototype@5305068a
草薙京
Sat Jun 22 12:06:29 CST 2019
```
从运行结果可看出复制出的是一个新对象并且和原型对象有相同属性值。

3.原型模式的注意事项

* 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。
* 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。

4.优点

性能优良：原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

5.缺点

逃避构造函数的约束（clone的时候，构造函数不会执行）：这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，需要在实际应用时考虑。
需要注意类中可变引用成员浅拷贝带来的问题，可以考虑使用深拷贝（对成员也进行一次clone，并且赋值给新对象的成员）
类成员中有final类型的成员，这个类不能进行clone。（此时应该去掉final关键字）「如果原型模式中的数组、容器对象、引用对象作为成员变量被finali修饰时，无法对它们单独clone，因为final修饰的变量需要初始化，不能重新赋值」

#### 适配器模式

1.介绍
1.1 模式说明
定义一个包装类，用于包装不兼容接口的对象

>包装类 = 适配器Adapter；  
>被包装对象 = 适配者Adaptee = 被适配的类

1.2 主要作用
把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。

>适配器模式的形式分为：类的适配器模式 & 对象的适配器模式

1.3 解决的问题
原本由于接口不兼容而不能一起工作的那些类可以在一起工作

2.模式原理
2.1 类的适配器模式
类的适配器模式是把适配的类的API转换成为目标类的API。
2.1.1 UML类图 & 组成

![image](pic/p106.png)

在上图中可以看出：

* 冲突：Target期待调用Request方法，而Adaptee并没有（这就是所谓的不兼容了）。
* 解决方案：为使Target能够使用Adaptee类里的SpecificRequest方法，故提供一个中间环节Adapter类（继承Adaptee & 实现Target接口），把Adaptee的API与Target的API衔接起来（适配）。

>Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的

2.1.2 使用步骤（代码解析）
步骤1： 创建Target接口；

```
public interface Target {
 
    //这是源类Adapteee没有的方法
    public void Request(); 
}
```


步骤2： 创建源类（Adaptee） ；

```
public class Adaptee {
    
    public void SpecificRequest(){
    }
}
```

步骤3： 创建适配器类（Adapter）

```
//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。
public class Adapter extends Adaptee implements Target {

    //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()
    //因此适配器补充上这个方法名
    //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容
    //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已
    @Override
    public void Request() {
        this.SpecificRequest();
    }

}
```

```
步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标
public class AdapterPattern {

    public static void main(String[] args){

        Target mAdapter = new Adapter()；
        mAdapter.Request（）;
     
    }
}
```

2.1.3 实例讲解
接下来我用一个实例来对类的适配器模式进行更深一步的介绍。
a. 实例概况

* 背景：小成买了一个进口的电视机
* 冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容
* 解决方案：设置一个适配器将插头输出的220V转变成110V

>即适配器模式中的类的适配器模式

b. 使用步骤
步骤1： 创建Target接口（期待得到的插头）：能输出110V（将220V转换成110V）

```
 public interface Target {

    //将220V转换输出110V（原有插头（Adaptee）没有的）
    public void Convert_110v();
}
```

步骤2： 创建源类（原有的插头） ；

```
class PowerPort220V{
//原有插头只能输出220V
    public void Output_220v(){
    }
}
```

步骤3：创建适配器类（Adapter）

```
class Adapter220V extends PowerPort220V implements Target{
   //期待的插头要求调用Convert_110v()，但原有插头没有
    //因此适配器补充上这个方法名
    //但实际上Convert_110v()只是调用原有插头的Output_220v()方法的内容
    //所以适配器只是将Output_220v()作了一层封装，封装成Target可以调用的Convert_110v()而已

    @Override
    public void Convert_110v(){
      this.Output_220v;
    }
}
```

步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标（不需要通过原有插头）

```
//进口机器类
class ImportedMachine {

    @Override
    public void Work() {
        System.out.println("进口机器正常运行");
    }
}
```

```
//通过Adapter类从而调用所需要的方法
public class AdapterPattern {
    public static void main(String[] args){

        Target mAdapter220V = new Adapter220V();
        ImportedMachine mImportedMachine = new ImportedMachine();
       
        //用户拿着进口机器插上适配器（调用Convert_110v()方法）
        //再将适配器插上原有插头（Convert_110v()方法内部调用Output_220v()方法输出220V）
        //适配器只是个外壳，对外提供110V，但本质还是220V进行供电
        mAdapter220V.Convert_110v();
        mImportedMachine.Work();
    }
}
```

2.2 对象的适配器模式
与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。

>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。

2.2.1 UML类图

![image](pic/p107.png)

在上图中可以看出：

* 冲突：Target期待调用Request方法，而Adaptee并没有（这就是所谓的不兼容了）。
* 解决方案：为使Target能够使用Adaptee类里的SpecificRequest方法，故提供一个中间环节Adapter类（包装了一个Adaptee的实例），把Adaptee的API与Target的API衔接起来（适配）。

>Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。

2.2.2 使用步骤（代码解析）

步骤1： 创建Target接口；

```
public interface Target {
 
    //这是源类Adapteee没有的方法
    public void Request(); 
}
```

步骤2： 创建源类（Adaptee） ；

```
public class Adaptee {
    
    public void SpecificRequest(){
    }
}
```

步骤3： 创建适配器类（Adapter）（不适用继承而是委派）

```
class Adapter implements Target{  
    // 直接关联被适配类  
    private Adaptee adaptee;  
    
    // 可以通过构造函数传入具体需要适配的被适配类对象  
    public Adapter (Adaptee adaptee) {  
        this.adaptee = adaptee;  
    }  
    
    @Override
    public void Request() {  
        // 这里是使用委托的方式完成特殊功能  
        this.adaptee.SpecificRequest();  
    }  
}  
```

步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标

```
public class AdapterPattern {
    public static void main(String[] args){
        //需要先创建一个被适配类的对象作为参数  
        Target mAdapter = new Adapter(new Adaptee())；
        mAdapter.Request();
     
    }
}
```


在这里我就不再举实例进行讲解了（详情请看上面“进口机器的插头”），只是在适配类实现时将“继承”改成“在内部委派Adaptee类”而已

3.优缺点
3.1 适配器模式
优点

* 更好的复用性
系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。

* 透明、简单
客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 & 更直接

* 更好的扩展性
在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。

* 解耦性
将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码

* 符合开放-关闭原则
同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类

缺点

* 过多的使用适配器，会让系统非常零乱，不易整体进行把握


3.2 类的适配器模式
优点

* 使用方便，代码简化

仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例

缺点

* 高耦合，灵活性低

使用对象继承的方式，是静态的定义方式


3.3 对象的适配器模式
优点

* 灵活性高、低耦合

采用 “对象组合”的方式，是动态组合方式

缺点

* 使用复杂

需要引入对象实例

>特别是需要重新定义Adaptee行为时需要重新定义Adaptee的子类，并将适配器组合适配

4.应用场景
4.1 适配器的使用场景

* 系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。
* 想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的一些类，包括一些将来可能会被引进的类一起工作。
* 需要一个统一的输出接口，而输入端的类型不可预知。
* Android中ListView、RecycleView等控件的设计就采用了适配器模式。

4.2 类和对象适配器模式的使用场景

1 灵活使用时：选择对象的适配器模式
类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
2 需要同时配源类和其子类：选择对象的适配器


* 对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了；
* 对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。

3 需要重新定义Adaptee的部分行为：选择类适配器

* 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
* 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。

4 仅仅希望使用方便时：选择类适配器

* 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
对于对象适配器，需要额外的引用来间接得到Adaptee。

总结
建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。

#### 桥接模式

1.定义
桥接模式也叫桥梁模式，通过抽象角色引用实现角色，将抽象和实现解耦，使得两者可以独立地变化。其中抽象和实现可以理解为两个不同的维度。

![image](pic/p109.png)

2.使用场景

* 一个类存在两个独立变化的维度，并且两个维度都需要扩展。
* 不希望或不适用使用继承的场景。
* 接口或抽象类不稳定的场景，明知接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的。
* 重用性要求较高的场景，设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。

3. 实现
这里以冲咖啡为例子进行代码实现，实现大杯小杯、加糖不加糖两个维度的搭配。
抽象化角色——咖啡：

```
/**
 * Abstraction是抽象化角色，保持实现化角色的引用
 * 这里的Abstraction代表咖啡
 */
public abstract class Abstraction {

    //抽象化角色，保持实现化角色的引用，是桥接模式的核心
    //这里的实现化角色代表咖啡的调料
    private Implementor mImplementor;

    public Abstraction(Implementor implementor) {
        mImplementor = implementor;
    }

    public Implementor getImplementor() {
        return mImplementor;
    }

    /**
     * 冲咖啡，具体实现由子类实现
     */
    public abstract void operator();

}
```

修正抽象化角色——大杯、小杯的咖啡：

```
/**
 * RefineAbstraction是修正抽象化角色，通过引用实现化角色Implementor对抽象化角色Abstraction进行修正
 * RefineAbstraction1是咖啡的实现类，代表大杯的咖啡
 */
public class RefineAbstraction1 extends Abstraction {

    public RefineAbstraction1(Implementor implementor) {
        super(implementor);
    }

    @Override
    public void operator() {
        System.out.println("大杯的" + this.getImplementor().implement() + "咖啡");
    }
}

public class RefineAbstraction2 extends Abstraction {

    public RefineAbstraction2(Implementor implementor) {
        super(implementor);
    }

    @Override
    public void operator() {
        System.out.println("小杯的" + this.getImplementor().implement() + "咖啡");
    }
}
```

实现化角色——调料：

```
/**
 * Implementor是实现化角色
 * 这里代表咖啡的调料，具体调料由实现类实现
 */
public interface Implementor {

    String implement();

}
```

具体实现化角色——加糖、不加糖：

```
/**
 * ConcreteImplementor具体的实现化角色
 * ConcreteImplementor咖啡的调料的实现类，代表加糖
 * 
 */
public class ConcreteImplementor1 implements Implementor {
    @Override
    public String implement() {
        return "加糖";
    }
}

public class ConcreteImplementor2 implements Implementor {
    @Override
    public String implement() {
        return "不加糖";
    }
}
```

场景类：

```
public class Client {

    public static void main(String[] args) {

        Implementor i1 = new ConcreteImplementor1();//加糖
        Implementor i2 = new ConcreteImplementor1();//不加糖

        Abstraction a1 = new RefineAbstraction1(i1);//大杯、加糖
        Abstraction a2 = new RefineAbstraction1(i2);//大杯、不加糖
        Abstraction a3 = new RefineAbstraction2(i1);//小杯、加糖
        Abstraction a4 = new RefineAbstraction2(i2);//小杯、不加糖

        a1.operator();
        a2.operator();
        a3.operator();
        a4.operator();
    }

}
```

运行结果：

```
大杯的加糖咖啡
大杯的加糖咖啡
小杯的加糖咖啡
小杯的加糖咖啡
```

4.优点
抽象和实现分离。解决了继承的缺点，桥接模式实现了不受抽象的约束，不用再绑定在一个固定的抽象层次上。
优秀的扩充能力。抽象和实现都可以独立扩展。
实现细节对客户透明。客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。

5.缺点
桥接模式的引入会增加系统的理解与设计难度。由于聚合关联关系建立在抽象层，要求开发者针对抽象设计和编程。
实际中不容易发现可以使用桥接模式的地方。桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

#### 装饰者模式
1.定义
装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。装饰模式中，通过装饰者给被装饰者扩展了功能。

![image](pic/p115.png)

装饰者和被装饰者拥有相同的组件接口。被装饰者是系统的核心组件，完成特定功能。装饰者则可以在被装饰者的方法前后，加上特定的前置处理和后置处理，增强被装饰者的功能

* 组件接口：为装饰者和被装饰者的超类或接口。定义被装饰者的核心功能，以及装饰者需要加强的功能
* 具体组件（被装饰者）：实现组件接口的的核心方法，完成具体业务逻辑
* 装饰者：实现组件接口，持有一个被装饰对象
* 具体装饰者：具体实现装饰的业务逻辑。各个具体装饰者是可以相互叠加的

2.使用场景

需要扩展一个类的功能，或给一个类增加附加功能。
需要动态地给一个对象增加功能，这些功能可以再动态地撤销。
需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。
Java中的IO流的架构。
Android中的Context家族。

3.实现

场景：奶茶哥哥的奶茶店开张了，我们推出了两种产品—奶茶和茶叶茶。我们的饮料需要实现自己的描述和自己的价格。

组件接口

```
// 饮料的基类(组件接口)
public interface MilkTea {

  String getDescription();

  int cost();
}
```

具体组件---被装饰者

```
// 具体组件：珍珠奶茶(被装饰者)
public class PearlMilkTea implements MilkTea {
    @Override
    public String getDescription() {
        return "这是珍珠奶茶";
    }

    @Override
    public int cost() {
        return 10;
    }
}

// 具体组件：丝袜奶茶(被装饰者)
public class SilkMilkTea implements MilkTea {
    @Override
    public String getDescription() {
        return "这是丝袜奶茶";
    }

    @Override
    public int cost() {
        return 12;
    }
}
```

装饰者

```
// 调料的基类(装饰者)
public abstract class CondimentDecorator implements MilkTea {

  protected MilkTea milkTea;

  public CondimentDecorator(MilkTea milkTea) {
    this.milkTea = milkTea;
  }
}
```

具体装饰者

```
public class Matcha extends CondimentDecorator {

  public Matcha(MilkTea milkTea) {
    super(milkTea);
  }

  @Override
  public String getDescription() {
    return milkTea.getDescription() + "，这是加入了抹茶";
  }

  @Override
  public int cost() {
    return 5 + milkTea.cost();
  }
}

public class Fruits extends CondimentDecorator {

  public Fruits(MilkTea milkTea) {
    super(milkTea);
  }

  @Override
  public String getDescription() {
    return milkTea.getDescription() + "，加入了水果调料";
  }

  @Override
  public int cost() {
    return 3 + milkTea.cost();
  }
}
```

测试

```
public static void main(String[] args) {
    MilkTea milkTea = new SilkMilkTea();
    System.out.println(milkTea.getDescription() + "---" + milkTea.cost());

    MilkTea tea = new Fruits(new PearlMilkTea());
    System.out.println(tea.getDescription() + "---" + tea.cost());

    tea = new Matcha(tea);
    System.out.println(tea.getDescription() + "---" + tea.cost());
}
```

结果：

```
这是丝袜奶茶---12
这是珍珠奶茶，加入了水果调料---13
这是珍珠奶茶，加入了水果调料，加入了抹茶调料---18
```

4.装饰者模式和代理模式的区别

这两个模式真心在实现上太像了，都是对业务处理的前后增加前置后置的实现。网上找了很多人对这两者的理解，这里总结下我的看法。

装饰模式: 

* 以对客户端透明的方式扩展对象的功能 
* 可以说是继承关系的一个替代方案 
* 用户更关心装饰后的功能

比如上面的奶茶，用户希望得到的是—奶茶+珍珠+抹茶，以及他们的总价

代理模式： 

* 代理模式对代理的对象施加控制，并不提供对象本身的增强功能 
* 用户通过代理来访问目标的功能，使用者关心的是原始功能都有什么功能,而对于代理的时候的处理却不知道

使用目的不同：代理模式是给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用；装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能

构造不同：代理模式内部保持对目标对象的引用；装饰模式是通过构造函数传参的方式得到目标对象

5.优点
装饰模式可以动态地扩展一个实现类的功能。
装饰模式是继承关系的一个替代方案。不管装饰多少层，最终返回的对象还是抽象类。
装饰类和被装饰类可以独立发展，而不会相互耦合。
6.缺点
多层的装饰是比较复杂的。
应该尽量减少装饰类的数量，以便降低系统的复杂度。

#### 外观模式

1.介绍
1.1 定义
也叫门面模式，是一种比较常用的封装模式：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。

>通过创建一个统一的外观类，用来包装子系统中一个或多个复杂的类，客户端可通过调用外观类的方法来调用内部子系统中所有方法

如下图：

![image](pic/p116.png)

给个网站的导航例子你就懂了：以前我需要在搜索栏逐个搜索网站地址；有了网站导航（用了外观模式）后，就方便很多了

![image](pic/p117.png)

1.2 主要作用

* 实现客户类与子系统类的松耦合
* 降低原有系统的复杂度
* 提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。

>引入外观角色之后，用户只需要与外观角色交互；  
>用户与子系统之间的复杂逻辑关系由外观角色来实现


1.3 解决的问题

* 避免了系统与系统之间的高耦合度
* 使得复杂的子系统用法变得简单

2.模式原理
2.1 UML类图 & 组成

![image](pic/p118.png)

2.2 实例讲解
接下来我用一个实例来对建造者模式进行更深一步的介绍。
a. 实例概况

背景：小成的爷爷已经80岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；
冲突：行动不方便，走过去关闭那么多电器很麻烦，代码如下：

1.电器类：

```
//灯类
public class SubSystemA_Light {  
     public void on(){  
        System.out.println("打开了灯....");  
    }  
      
     public void off(){  
        System.out.println("关闭了灯....");  
    }  
}  

//电视类
public class SubSystemB_Television {  
     public void on(){  
        System.out.println("打开了电视....");  
    }  
      
     public void off(){  
        System.out.println("关闭了电视....");  
    }  
}  

//空调类
public class SubSystemC_Aircondition {  
     public void on(){  
        System.out.println("打开了空调....");  
    }  
      
     public void off(){  
        System.out.println("关闭了空调....");  
    }  
}  
```

客户端调用：小成爷爷使用电器情况

```
public class Facade Pattern{ 
  public static void main(String[] args){
    {
        SubSystemA_Light light = new SubSystemA_Light();
        SubSystemB_Television television = new SubSystemB_Television();
        SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition();

        //起床后开电器
        System.out.prinln("起床了")；
        light.on()；
        television.on();
        aircondition.on()；
       System.out.prinln("可以看电视了")；

       //睡觉时关电器
       System.out.prinln("睡觉了")；
        light.off()；
        television.off();
        aircondition.off()；
         System.out.prinln("可以睡觉了")；
    }
}
```

结果

```
起床了
打开了灯
打开了电视
打开了空调
可以看电视了

睡觉了
关闭了灯
关闭了电视
关闭了空调
可以睡觉了
```

从上面可以看出，在不使用外观模式的情况下，小成爷爷需要对每个电器都进行操作，非常不方便

>客户端与三个子系统都发生了耦合，使得客户端程序依赖与子系统

解决方案
小成买了一个智能家具控制器（外观对象/统一接口）给他爷爷，他爷爷只需要一键就能打开/关闭 灯、电视机、空调

>即用外观模式来为所有子系统设计一个统一的接口  
>客户端只需要调用外观类中的方法就可以了，简化了客户端的操作


1.电器类同上

外观类：智能遥控器

```
public class Facade{
      
  SubSystemA_Light light；
  SubSystemB_Television television ；
  SubSystemC_Aircondition aircondition；
    

  //传参
  public Facade(SubSystemA_Light light,SubSystemB_Television television,SubSystemC_Aircondition aircondition){  
    this.light = light;  
    this.television  = television ;  
    this.aircondition =aircondition;  
    
  }  
  //起床后一键开电器
  public void on{
    System.out.prinln("起床了")； 
    light.on()； 
    television.on(); 
    aircondition.on()；
    
  }

  public void off(){
    //睡觉时一键关电器
    System.out.prinln("睡觉了")； 
    light.off()； 
    television.off(); 
    aircondition.off()； 
  }
}
```

客户端调用：爷爷使用智能遥控器的时候

```
public class Facade Pattern{ 
  public static void main(String[] args){
  
    //实例化电器类
    SubSystemA_Light light = new SubSystemA_Light();
    SubSystemB_Television television = new SubSystemB_Television();
    SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition();
    
    //传参
    Facade facade = new Facade(light,television,aircondition);
    
    //客户端直接与外观对象进行交互
    facade.on;
    System.out.prinln("可以看电视了")； 
    facade.off;
    System.out.prinln("可以睡觉了")； 
  }
}

```
结果

```
起床了
打开了灯
打开了电视
打开了空调
可以看电视了

睡觉了
关闭了灯
关闭了电视
关闭了空调
可以睡觉了
```

3.优缺点
在全面解析完后，我来分析下其优缺点：
3.1 优点

* 降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系

> 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类
> 减少了与子系统的关联对象，实现了子系统与客户之间
的松耦合关系，松耦合使得子系统的组件变化不会影响到它的客户。

* 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。

> 引入外观角色之后，用户只需要与外观角色交互；  
> 用户与子系统之间的复杂逻辑关系由外观角色来实现

* 降低原有系统的复杂度和系统中的编译依赖性，并简化了系统在不同平台之间的移植过程

> 因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。

3.2 缺点

* 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”
* 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。

4.使用场景

* 为一个复杂的模块或子系统提供一个供外界访问的接口。
* 子系统相对独立。外界对子系统的访问只要黑箱操作即可。
* 预防低水平人员带来的风险扩散。降低个人代码质量对整体项目的影响风险，规定低水平人员只能在指定的子系统中开发，然后再提供门面接口进行访问操作。
* Android中第三方SDK的设计，比如AndFix、Tinker、Gilde等就采用了外观模式。

5.与适配器模式的区别

* 外观模式的实现核心主要是——由外观类去保存各个子系统的引用，实现由一个统一的外观类去包装多个子系统类，然而客户端只需要引用这个外观类，然后由外观类来调用各个子系统中的方法。
* 这样的实现方式非常类似适配器模式，然而外观模式与适配器模式不同的是：适配器模式是将一个对象包装起来以改变其接口，而外观是将一群对象 ”包装“起来以简化其接口。它们的意图是不一样的，适配器是将接口转换为不同接口，而外观模式是提供一个统一的接口来简化接口。

#### 组合模式

1.定义
组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

![image](pic/p127.png)

2.使用场景

* 维护和展示部分-整体关系的场景，如树形菜单、关系型数据库、文件和文件夹管理。
* 从一个整体中能够独立出部分模块或功能的场景。
* Android中View与ViewGroup的设计就采用了组合模式。

3.实现
以文件夹、文件为例子来实现组合模式。

抽象构件角色：

```
/*
 * 抽象构件角色:定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性
 * 例子：文件夹、文件的抽象
 */
public abstract class Component {

  protected String name;

  public Component(String name) {
    this.name = name;
  }

  public abstract void add(Component component);

  public abstract void remove(Component component);

  public abstract List<Component> getSize();
}
```

树枝构件：

```
/*
 * 树枝构件：树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。
 * 例子：文件夹
 */
public class Composite extends Component {

  private final List<Component> mList = new ArrayList<>();

  public Composite(String name) {
    super(name);
  }

  @Override
  public void add(Component component) {
    this.mList.add(component);
  }

  @Override
  public void remove(Component component) {
    this.mList.remove(component);
  }

  @Override
  public List<Component> getSize() {
    return this.mList;
  }

  @Override
  public String toString() {
    return "Composite{" + "mList=" + mList + ", name='" + name + '\'' + '}';
  }
}
```

叶子构件：

```
/* 叶子构件：叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。
 * 例子：文件
 *
 */
public class Leaf extends Component {

  public Leaf(String name) {
    super(name);
  }

  @Override
  public void add(Component component) {
    throw new UnsupportedOperationException("叶子节点不支持该操作");
  }

  @Override
  public void remove(Component component) {
    throw new UnsupportedOperationException("叶子节点不支持该操作");
  }

  @Override
  public List<Component> getSize() {
    throw new UnsupportedOperationException("叶子节点不支持该操作");
  }

  @Override
  public String toString() {
    return "Leaf{" + "name='" + name + '\'' + '}';
  }
}
```

测试：

```
public static void main(String[] args) {
    Component c1 = new Composite("C盘");
    Component c2 = new Composite("文件夹");
    Component c3 = new Leaf("A.txt");
    Component c4 = new Leaf("B.dat");

    c1.add(c2);
    c1.add(c3);
    c2.add(c4);

    System.out.println(c1.getSize());
    System.out.println(c2.getSize());
}
```

结果：

```
[Composite{mList=[Leaf{name='B.dat'}], name='文件夹'}, Leaf{name='A.txt'}]
[Leaf{name='B.dat'}]
```

应用组合模式的会员卡消费

根据我们会员卡的消费，模拟一下组合模式的实现

首先：
1.我们的部件有，总店，分店，加盟店！
2.我们的部件共有的行为是：刷会员卡
3.部件之间的层次关系，也就是店面的层次关系是，总店下有分店、分店下可以拥有加盟店。
有了我们这几个必要条件后，我的要求就是目前店面搞活动当我在总店刷卡后，就可以累积相当于在所有下级店面刷卡的积分总额，设计的代码如下：

```
/**总店**/
abstract class Market(val name: String) {

    abstract fun add(market: Market)

    abstract fun remove(market: Market)

    abstract fun payByCard()
}
```

```
/**分店*/
class MarketBranch(name: String) : Market(name) {

    private val mList = mutableListOf<Market>()

    override fun add(market: Market) {
        mList.add(market)
    }

    override fun remove(market: Market) {
        mList.remove(market)
    }

    override fun payByCard() {
        println(this.name + "消费,积分已累计加入到会员卡中了")
        mList.forEach { market -> market.payByCard() }
    }
}
```

```
/**加盟店*/
class MarketJoin(name: String) : Market(name) {
    override fun add(market: Market) {
        throw UnsupportedOperationException("分店不支持此操作")
    }

    override fun remove(market: Market) {
        throw UnsupportedOperationException("分店不支持此操作")
    }

    override fun payByCard() {
        println(this.name + "消费,积分已累加入该会员卡")
    }
}
```

测试：

```
companion object {
    @JvmStatic
    fun main(args: Array<String>) {
        val rootBranch: Market = MarketBranch("总店")
        val chqBranch: Market = MarketBranch("朝阳区分店")
        val sltBranch: Market = MarketJoin("朝阳区分店分店一三里屯加盟店")
        val wjBranch: Market = MarketJoin("朝阳区分店分店二望京加盟店")


        chqBranch.add(sltBranch)
        chqBranch.add(wjBranch)
        rootBranch.add(chqBranch)
        rootBranch.payByCard()

    }
}
```

结果:

```
总店消费,积分已累计加入到会员卡中了
朝阳区分店消费,积分已累计加入到会员卡中了
朝阳区分店分店一三里屯加盟店消费,积分已累加入该会员卡
朝阳区分店分店二望京加盟店消费,积分已累加入该会员卡
```


4.优点

* 高层模块调用简单。高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。
* 节点自由增加、删除。非常容易扩展，符合开闭原则，对以后的维护非常有利。

5.缺点

* 普通的组合模式不符合依赖倒置原则，而透明的组合模式是符合的。
* 因为构件的抽象都是一样的，所以透明的组合模式在新增构件的时候不好对构件类型进行限制，容易产生运行时的异常。

#### 享元模式

1.定义
享元模式：使用共享对象可以有效地支持大量的细粒度的对象。这是在这么多种设计模式中极少的以提高程序性能为目的的模式。其主要思想为—如果系统中存在多个相同对象，那么只需要一份对象的拷贝，而不必在每次使用的时候去新建一个对象。

共享技术：防止对象分配过多而造成系统的性能问题，甚至OOM
细粒度：区分一个对象的内部状态和外部状态，通过外部状态唯一标识一个对象，防止重复对象更多
内部状态：可以共享的信息，存储在对象内部并且不会随环境改变
外部状态：不可以共享的信息，随着环境的改变而改变，是对象的索引值

角色及作用划分

* 抽象享元:定义享元所需要实现的业务接口(抽象类或接口)
* 享元工厂:创建享元类，维护共同的享元对象(核心组件)
* 具体享元类:实现抽象享元类，完成具体逻辑
* 客户端:使用享元模式组件，通过享元工厂获取享元对象

![image](pic/p128.png)

2.使用场景

系统中存在着大量相似的对象
细粒度的对象都具备外部状态和内部状态，外部状态不随环境而变化
需要缓冲池的场合

3.实现

场景：我们设计了一个文本域，如果我们将文本域中的每一个文字都定义为一个对象，那么如果有1万字就需要1万个对象，这会很消耗内存。那么我们就可以考虑使用享元模式来实现。

抽象享元
```
public abstract class Flyweight {

    //内部状态，可以共享的信息，存储在对象内部并且不会随环境改变
    private String mIntrinsic;

    //外部状态，不可以共享的信息，随着环境的改变而改变，是对象的索引值
    protected final String mExtrinsic;

    public Flyweight(String extrinsic) {
        mExtrinsic = extrinsic;
    }
}
```

具体享元类

```
public class ConcreteFlyweight extends Flyweight {
    
    public ConcreteFlyweight(String extrinsic) {
        super(extrinsic);
    }
    
}
```

享元工厂

```
public class FlyweightFactory {

    //池容器
    private static Map<String, Flyweight> sPool = new HashMap<>();

    /**
     * 通过外部状态结合池来管理对象
     * @param extrinsic
     * @return
     */
    public static Flyweight getFlyweight(String extrinsic) {

        Flyweight result = null;

        if (sPool.containsKey(extrinsic)) {
            result = sPool.get(extrinsic);
        } else {
            result = new ConcreteFlyweight(extrinsic);
            sPool.put(extrinsic, result);
        }

        return result;
    }

}
```

ViewPager的Adapter中Fragment的创建可以使用该模式

```
public class Fragment {
}

public class BlackFragment extends Fragment {
}

public class WhiteFragment extends Fragment {
}
```

```
public class FragmentFactory {

  private static final int BLACK_POSITION = 0;
  private static final int WHITE_POSITION = 1;

  private static Map<Integer, Fragment> mList = new HashMap<>();

  public static Fragment createPerson(int position) {

    Fragment fragment = mList.get(position);
    if (fragment != null) {
      return fragment;
    } else {
      switch (position) {
        case BLACK_POSITION:
          fragment = new BlackFragment();
          break;
        case WHITE_POSITION:
          fragment = new WhiteFragment();
          break;
        default:
          break;
      }
      mList.put(position, fragment);
    }
    return fragment;
  }

  public static int getPersonSize() {
    return mList.size();
  }
}
```

4.优点

* 减少对象的创建，降低应用程序的内存占用，增强程序的性能，防止OOM

5.缺点

* 为了实现共享，需要剥离对象的外部、内部状态，使得系统更加复杂
* 外部状态具有固化性，不随着环境、内部状态的变化而变化，否则共享池就会出现混乱

#### 代理模式

1.介绍
Java中的代理设计模式(Proxy),也叫做委托模式，提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.  
代理设计模式在现实生活中无处不在，举个例子:  
朋友圈中卖面膜的同学,她们从厂家拿货，然后在朋友圈中宣传，然后卖给熟人。

![avatar](pic/p59.png)

按理说，顾客可以直接从厂家购买产品，但是现实生活中，很少有这样的销售模式。一般都是厂家委托给代理商进行销售，顾客跟代理商打交道，而不直接与产品实际生产者进行关联。所以，<font color = red>代理就有一种中间人的味道。</font>  
再举个例子，大家都买过房吧，一般情况下是由中介带着你去，而这个中介也是类似代理人的作用，你也要明白，真正的买房人是你，你负责出钱，中介只是负责传达你的要求而已，当然啦，一些额外的功能就是需要出点钱给中介，毕竟人家那么辛苦，坑点茶水费还是要的，大家都懂，后来想起了这个代理模式，也就理解了，哈哈,大家会发现，设计模式都是源于生活，在生活中处处都有设计模式的影子,我觉得<font color = red>学习设计模式一定要理解，理解，理解，重要的事情说三遍。</font>

代理模式是面向对象编程中比较常见的设计模式。

![avatar](pic/p60.png)

需要注意的有下面几点：

1. 用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。
2. 接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。
3. 代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。
4. 用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。

2.使用场景

* 当无法或者不想直接访问某个对象或者访问某个对象存在困难的时候都可以通过代理来访问。
* Android中的IPC机制就使用到了代理模式。
* 面向切面编程（AOP）中，核心就是动态代理。

3.代理模式的分类

##### 静态代理

静态代理，指的是在编译的时候就已经存在了，需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。
eg:  
我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。  
现在用代码来进行模拟:  
首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。

```java
public interface Movie {
	void play(String name);
}
``` 
然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。

```java
//真正对象
public class RealMovie implements Movie {

	@Override
	public void play(String name) {
		 System.out.println("您正在观看电影: " + name);
	}

}
```

这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？

```java
//代理对象
public class Cinema implements Movie {
	
	RealMovie movie;
	
	public Cinema(RealMovie movie) {
		this.movie = movie;
	}


	@Override
	public void play(String name) {
		
		guanggao(true);
		
		movie.play(name);
		
		guanggao(false);
	}
	
	public void guanggao(boolean isStart){
		if ( isStart ) {
			System.out.println("电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！");
		} else {
			System.out.println("电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！");
		}
	}

}
```

通过测试：

```java
public static void main(String[] args) {
		
		Movie realmovie = new RealMovie();
		
		Movie movie = new Cinema(realmovie);
		
		movie.play("《肖申克的救赎》");

	}
```

运行结果：

```java
电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！
您正在观看电影： 《肖申克的救赎》
电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！
```

##### 动态代理

顾名思义是动态的，Java中的动态一般指的是在运行时的状态，是相对编译时的静态来区分，就是在运行时生成一个代理对象帮我们干活。  
以买房为例子，如果静态代理是我们在还没有买房的时候(就是编译的时候)预先找好的中介，那么动态代理就是在买房过程中找的，注意:买房过程中说明是在买房这件事情的过程中，就是代码在运行的时候才找的一个中介。  
Java中的动态代理要求必须实现一个接口，InvocationHandler，动态代理也必须有一个真实的对象，不管是什么代理，只是帮忙传达指令，最终还是必须有原来的对象去干活的。  
eg:假设有一个大商场，商场有很多的柜台，有一个柜台卖茅台酒。我们进行代码的模拟。  

```java
public interface SellWine {	
	 void mainJiu();
}
```

SellWine 是一个接口，你可以理解它为卖酒的许可证。

```java
public class MaotaiJiu implements SellWine {
	@Override
	public void mainJiu() {
		System.out.println("我卖得是茅台酒。");
	}
}
```

然后创建一个类 MaotaiJiu,对的，就是茅台酒的意思。
我们还需要一个商店代理类来卖酒：

```java
public class Shop implements InvocationHandler {

  private SellWine sellWine;

  public Shop(SellWine sellWine) {
    this.sellWine = sellWine;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("销售开始 代理是： " + this.getClass().getSimpleName());
    method.invoke(sellWine, args);
    System.out.println("销售结束");
    return null;
  }
}
```
然后，我们就可以卖酒了。

```java
public class Test {

	public static void main(String[] args) {
		
		/*SellWine sellWine =
        (SellWine)
            Proxy.newProxyInstance(
                wine.getClass().getClassLoader(), wine.getClass().getInterfaces(), handler);*/

    SellWine sellWine =
        (SellWine)
            Proxy.newProxyInstance(
                wine.getClass().getClassLoader(), new Class[]{SellWine.class}, new Shop(wine));
			
	}

}
```

结果：

```java
销售开始 代理是： Shop
我卖得是茅台酒。
销售结束
```

4.优点

* 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。
* 代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了保护目标对象的作用。

5.缺点

* 由于在客户端和真实对象之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢；
* 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

#### 模板方法模式

1.定义
模板方法模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

>模板方法模式是基于”继承“的；

![image](pic/p129.png)

2.使用场景

* 多个子类有公有的方法，并且逻辑基本相同时。
* 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。
* 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数（Hook Method）约束其行为。
* Android中，抽取BaseActivity就使用到了模板方法模式。

3.解决的问题

* 提高代码复用性
* 将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中
* 实现了反向控制
* 通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 & 符合“开闭原则”

4.实例讲解

对于炒菜过程可以使用该模式，比如炒土豆丝和炒西红柿鸡蛋明显有相同的步骤，也有不同步骤

>为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。

创建抽象模版

```
public abstract class Cooks {

  public final void cook() {

    // 倒植物油
    pourPlantOil();
    // 是否倒动物油
    if (isPourAnimalOil()) pourAnimalOil();
    // 热油
    heatOil();
    // 倒蔬菜
    pourVegetable();
    // 倒调料
    pourSauce();
    // 翻炒
    fry();
    // 装盘
    Plating();
  }

  private void Plating() {
    System.out.println("出锅装盘");
  }

  private void fry() {
    System.out.println("翻炒");
  }

  protected abstract void pourSauce();

  protected abstract void pourVegetable();

  /** 钩子函数：子类可以通过钩子函数（Hook Method）约束父类的行为。 */
  protected abstract boolean isPourAnimalOil();

  private void pourAnimalOil() {
    System.out.println("放动物油");
  }

  private void heatOil() {
    System.out.println("热油");
  }

  private void pourPlantOil() {
    System.out.println("倒植物油");
  }
}
```

创建具体模板

```
public class CookPotato extends Cooks {
  @Override
  protected void pourSauce() {
    System.out.println("倒入盐、酱油、鸡精");
  }

  @Override
  protected void pourVegetable() {
    System.out.println("倒入土豆丝和辣椒");
  }

  @Override
  protected boolean isPourAnimalOil() {
    return true;
  }
}
```

```
public class CookTomato extends Cooks {
  @Override
  protected void pourSauce() {
    System.out.println("倒入盐");
  }

  @Override
  protected void pourVegetable() {
    System.out.println("倒入鸡蛋，西红柿");
  }

  @Override
  protected boolean isPourAnimalOil() {
    return false;
  }
}
```

测试

```
public static void main(String[] args) {
    Cooks cookPo = new CookPotato();
    cookPo.cook();

    System.out.println("^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^");

    Cooks cookTo = new CookTomato();
    cookTo.cook();
  }
```

结果

```
倒植物油
放动物油
热油
倒入土豆丝和辣椒
倒入盐、酱油、鸡精
翻炒
出锅装盘
^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^--^_^
倒植物油
热油
鸡蛋，西红柿
倒入盐
翻炒
出锅装盘
```

4 优点和缺点

4.1 优点

* 封装不变部分，扩展可变部分。把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。
* 行为由父类控制，子类实现。基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。
* 提取公共部分代码，便于维护。

4.2 缺点

* 子类对父类产生了影响：模板方法模式中抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果。
* 增加阅读难度：在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。

#### 命令模式

1.定义
命令模式是一个高内聚的模式，其定义为：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

![image](pic/p130.png)

2.使用场景

需要抽象出待执行的动作，然后以参数的形式提供出来。替代过程设计中的回调机制。
在不同的时刻指定、排列和执行请求。
需要支持事务操作、取消功能、日志功能。
Android中的事件传递机制就使用到了命令模式。

3.实现
以项目经理分别下发写代码、设计UI两条命令给程序员、视觉设计师为例子来实现命令模式。
接收者角色及其实现：

```
接收者角色及其实现：
/**
 * 接收者角色：该角色就是干活的角色，命令传递到这里是应该被执行的。
 * 例子：程序员、视觉设计师的基类
 */
public abstract class Receiver {

    public abstract void doSomething();

}

/**
 * 例子：程序员
 */
public class ConcreteReceiver1 extends Receiver{

    @Override
    public void doSomething() {
        System.out.println("写代码");
    }
}

/**
 * 例子：视觉设计师
 */
public class ConcreteReceiver2 extends Receiver{

    @Override
    public void doSomething() {
        System.out.println("设计UI");
    }
}
```

```
命令角色及其实现：
/**
 * 命令角色：需要执行的所有命令都在这里声明。
 */
public abstract class Command {

    protected Receiver mReceiver;

    public Command(Receiver receiver) {
        this.mReceiver = receiver;
    }

    public abstract void execute();
}

/**
 * 例子：写代码的命令，下发给程序员
 */
public class ConcreteCommand1 extends Command {

    public ConcreteCommand1() {
        super(new ConcreteReceiver1());
    }

    public ConcreteCommand1(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void execute() {
        this.mReceiver.doSomething();
    }
}

/**
 * 例子：设计UI的命令，下发给视觉设计师
 */
public class ConcreteCommand2 extends Command {

    public ConcreteCommand2() {
        super(new ConcreteReceiver2());
    }

    public ConcreteCommand2(Receiver receiver) {
        super(receiver);
    }

    @Override
    public void execute() {
        this.mReceiver.doSomething();
    }
}
```

```
调用者角色：
/**
 * 调用者角色：接收客户端的命令，并执行命令。
 * 例子：项目经理
 */
public class Invoker {

    private Command mCommand;

    public void setCommand(Command command) {
        this.mCommand = command;
    }

    public void action() {
        this.mCommand.execute();
    }
}
```

场景类：

```
public class Client {

    public static void main(String[] args) {
        Invoker invoker = new Invoker();

        invoker.setCommand(new ConcreteCommand1());
        invoker.action();

        invoker.setCommand(new ConcreteCommand2());
        invoker.action();
    }
}
```

```
运行结果：
写代码
设计UI
```

模拟对电视机的操作有开机、关机、换台命令。代码如下

```
//执行命令的接口
public abstract class Command {

  public abstract void execute();
}

public class CommandOn  extends Command{


    private TvReceiver receiver;

    public CommandOn(TvReceiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
     receiver.turnOn();
    }
}

public class CommandOff extends Command {

  private TvReceiver receiver;

  public CommandOff(TvReceiver receiver) {
    this.receiver = receiver;
  }

  @Override
  public void execute() {
    receiver.turnOff();
  }
}

public class CommandChanel extends Command {

  private TvReceiver receiver;

  private int channel;

  public CommandChanel(TvReceiver receiver, int channel) {
    this.receiver = receiver;
    this.channel = channel;
  }

  @Override
  public void execute() {
    receiver.changeChannel(channel);
  }
}
```

```
//命令接收者Receiver
public class TvReceiver {

  private int currentChannel = 0;

  public void turnOn() {
    System.out.println("The tv is on.");
  }

  public void turnOff() {
    System.out.println("The tv is off.");
  }

  public void changeChannel(int channel) {
    this.currentChannel = channel;
    System.out.println("Now tv channel is " + channel);
  }
}
```

```
//可以看作是遥控器Invoker
public class Control {

  private Command command;

  public void setCommand(Command command) {
    this.command = command;
  }

  public void action() {
    command.execute();
  }
}
```

测试

```
public static void main(String[] args) {

    TvReceiver receiver = new TvReceiver();

    Command onCommand = new CommandOn(receiver);
    Command offCommand = new CommandOff(receiver);
    Command channelCommand = new CommandChanel(receiver, 4);
    Control control = new Control();

    control.setCommand(onCommand);
    control.action();

    control.setCommand(channelCommand);
    control.action();

    control.setCommand(offCommand);
    control.action();
  }
```

结果

```
The tv is on.
Now tv channel is 4
The tv is off.
```

4.优点

类间解耦。调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底是哪个接收者执行。
可扩展性。Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合。
命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少Command子类的膨胀问题。

5.缺点

命令模式如果有N个命令Command的子类就有N个，类数量膨胀得非常大。


#### 迭代器模式

1.定义
迭代器模式：在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。
使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。
迭代器(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴漏聚集的内部表象。

![image](pic/p131.png)


2.为什么聚集需要迭代器

多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂性和多样性，数组就是最基本的聚集，也是其他Java聚集对象的设计基础。
Java聚集(Collection)对象是实现了共同的java.util.Collection接口的对象，是Java语言对聚集的概念的直接支持。
聚集对象必须提供适当的方法，允许客户端按照一个线性顺序遍历所有元素对象 ，把元素对象提取出来或者删除掉等。一个使用聚集的系统必然会使用这些方法操作聚集对象，因而在使用聚聚的系统演化过程中，会出现两类情况。
◆ 迭代逻辑没有改变，但是需要将一种聚集对象换成另一种聚集，因为不同的聚集具有不同的遍历接口，所以需要修改客户端代码，以便将已有的迭代调用换成新聚集对象所要求的接口。
◆ 聚集不改变，但是迭代方式需要改变，比如原来只需要读取元素和删除元素，但现在需要增加新的；或者原来的迭代仅仅遍历所有的元素，而现在则需要对元素加以过滤等。这时就只好修改聚集对象，修改已有的遍历方法，或者增加新的方法。
显然，出现这种情况是因为所涉及的聚集设计不符合“开-闭”原则，也就是因为没有将不变的结构从系统中抽象出来，与可变成分分割，并将可变部分的各种实现封装起来。一个聪明的做法无疑是应当使用更加抽象的处理方法，使得在进行迭代时，客户端根本无需知道所使用的聚集是哪个类型；而当客户端需要使用全新的迭代逻辑时，只需要引进一个新的迭代器对象即可，根本无需修改聚集对象本身。
迭代器模式模式便是这样的一个抽象化的概念，这一模式之所以能够做到这一点，是因为它将迭代逻辑封装到一个独立的迭代器对象汇总，从而与聚集本身分隔开。迭代器对象是对遍历的抽象化，不同的聚集对象可以提供相同的迭代器对象，从而使客户端无需知道聚集的低层结构，一个聚集可以提供多个不同的迭代器对象，从而使得遍历逻辑的变化不会影响到聚集对象本身。

迭代器模式有两种实现方式，分别是白箱聚集与外禀迭代器和黑箱聚集于内禀迭代器。

3.白箱聚集与外禀迭代器
如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。
如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代器模式对迭代器对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。

![image](pic/p132.png)

由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代器可以从外部控制聚集元素的迭代过程。这样一来迭代器所控制的仅仅是一个游标而已，这种迭代器叫做游标迭代器（Cursor Iterator）。由于迭代器是在聚集结构之外的，因此这样的迭代器又叫做外禀迭代器（Extrinsic Iterator）。

4.实现
一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代器可以通过聚集的遍历方法实现迭代功能。
因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代器角色往往仅仅保持迭代的游标位置。

5.角色
抽象迭代器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。
具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。
聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。
具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。
客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代器对象的迭代接口，也有可能通过迭代器操作聚集元素的增加和删除。

抽象聚集角色类
这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。

```
public abstract class Aggregate {
    /**
     * 工厂方法，创建相应迭代器对象的接口
     */
    public abstract Iterator createIterator();
}
```

具体聚集角色类
实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。

```
public class ConcreteAggregate extends Aggregate {
    
    private Object[] objArray = null;
    /**
     * 构造方法，传入聚合对象的具体内容
     */
    public ConcreteAggregate(Object[] objArray){
        this.objArray = objArray;
    }
    
    @Override
    public Iterator createIterator() {
        
        return new ConcreteIterator(this);
    }
    /**
     * 取值方法：向外界提供聚集元素
     */
    public Object getElement(int index){
        
        if(index < objArray.length){
            return objArray[index];
        }else{
            return null;
        }
    }
    /**
     * 取值方法：向外界提供聚集的大小
     */
    public int size(){
        return objArray.length;
    }
}
```

抽象迭代器角色类

```
public interface Iterator {
    /**
     * 迭代方法：移动到第一个元素
     */
    public void first();
    /**
     * 迭代方法：移动到下一个元素
     */
    public void next();
    /**
     * 迭代方法：是否为最后一个元素
     */
    public boolean isDone();
    /**
     * 迭代方法：返还当前元素
     */
    public Object currentItem();
}
```

具体迭代器角色类

```
public class ConcreteIterator implements Iterator {
    //持有被迭代的具体的聚合对象
    private ConcreteAggregate agg;
    //内部索引，记录当前迭代到的索引位置
    private int index = 0;
    //记录当前聚集对象的大小
    private int size = 0;
    
    public ConcreteIterator(ConcreteAggregate agg){
        this.agg = agg;
        this.size = agg.size();
        index = 0;
    }
    /**
     * 迭代方法：返还当前元素
     */
    @Override
    public Object currentItem() {
        return agg.getElement(index);
    }
    /**
     * 迭代方法：移动到第一个元素
     */
    @Override
    public void first() {
        
        index = 0;
    }
    /**
     * 迭代方法：是否为最后一个元素
     */
    @Override
    public boolean isDone() {
        return (index >= size);
    }
    /**
     * 迭代方法：移动到下一个元素
     */
    @Override
    public void next() {
 
        if(index < size)
        {
            index ++;
        }
    }
 
}
```

客户端类

```
public class Client {
 
    public void operation(){
        Object[] objArray = {"One","Two","Three","Four","Five","Six"};
        //创建聚合对象
        Aggregate agg = new ConcreteAggregate(objArray);
        //循环输出聚合对象中的值
        Iterator it = agg.createIterator();
        while(!it.isDone()){
            System.out.println(it.currentItem());
            it.next();
        }
    }
    public static void main(String[] args) {
        
        Client client = new Client();
        client.operation();
    }
} 
```

上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。

6.意义
一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代器模式，并创建一个迭代器对象进行迭代呢？
客户端当然可以自行进行迭代，不一定非得需要一个迭代器对象。但是，迭代器对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代器责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代器作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。
此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代器模式和一个外界的迭代器对象是有意义的。具有同一迭代接口的不同迭代器对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。

7.黑箱聚集与内禀迭代器
如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的窄接口。
聚集对象为迭代器对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代器对象适当公开，以便迭代器对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代器对象进行这些工作，而不是直接操控聚集对象。

![image](pic/p133.png)

在JAVA语言中，实现双重接口的办法就是将迭代器类设计成聚集类的内部成员类。这样迭代器对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代器模式的实现方案。这种同时保证聚集对象的封装和迭代器功能的实现的方案叫做黑箱实现方案。
由于迭代器是聚集的内部类，迭代器可以自由访问聚集的元素，所以迭代器可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代器是在聚集的结构之内定义的，因此这样的迭代器又叫做内禀迭代器（Intrinsic Iterator）。

8.应用
为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代器接口的具体迭代器类，同时聚集并不向外界提供访问自己内部元素的方法。

抽象聚集角色类
这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。

```
public abstract class Aggregate {
    /**
     * 工厂方法，创建相应迭代器对象的接口
     */
    public abstract Iterator createIterator();
}
```

抽象迭代器角色类

```
public interface Iterator {
    /**
     * 迭代方法：移动到第一个元素
     */
    public void first();
    /**
     * 迭代方法：移动到下一个元素
     */
    public void next();
    /**
     * 迭代方法：是否为最后一个元素
     */
    public boolean isDone();
    /**
     * 迭代方法：返还当前元素
     */
    public Object currentItem();
}
```

具体聚集角色类
实现了抽象聚集角色所要求的接口，也就是createIterator()方法。此外，聚集类有一个内部成员类ConcreteIterator，这个内部类实现了抽象迭代器角色所规定的接口；而工厂方法createIterator()所返还的就是这个内部成员类的实例。

```
public class ConcreteAggregate extends Aggregate {
    
    private Object[] objArray = null;
    /**
     * 构造方法，传入聚合对象的具体内容
     */
    public ConcreteAggregate(Object[] objArray){
        this.objArray = objArray;
    }
    
    @Override
    public Iterator createIterator() {
 
        return new ConcreteIterator();
    }
    /**
     * 内部成员类，具体迭代器类
     */
    private class ConcreteIterator implements Iterator
    {
        //内部索引，记录当前迭代到的索引位置
        private int index = 0;
        //记录当前聚集对象的大小
        private int size = 0;
        /**
         * 构造函数
         */
        public ConcreteIterator(){
            
            this.size = objArray.length;
            index = 0;
        }
        /**
         * 迭代方法：返还当前元素
         */
        @Override
        public Object currentItem() {
            return objArray[index];
        }
        /**
         * 迭代方法：移动到第一个元素
         */
        @Override
        public void first() {
            
            index = 0;
        }
        /**
         * 迭代方法：是否为最后一个元素
         */
        @Override
        public boolean isDone() {
            return (index >= size);
        }
        /**
         * 迭代方法：移动到下一个元素
         */
        @Override
        public void next() {
 
            if(index < size)
            {
                index ++;
            }
        }
    }
}
```

客户端类

```
public class Client {
 
    public void operation(){
        Object[] objArray = {"One","Two","Three","Four","Five","Six"};
        //创建聚合对象
        Aggregate agg = new ConcreteAggregate(objArray);
        //循环输出聚合对象中的值
        Iterator it = agg.createIterator();
        while(!it.isDone()){
            System.out.println(it.currentItem());
            it.next();
        }
    }
    public static void main(String[] args) {
        
        Client client = new Client();
        client.operation();
    }
 }
```

9.使用场景

需要遍历一个容器对象的时候。
由于Java API已经提供了java.util.Iterator接口，并且基本的容器类已经实现了这个接口。换句话说，Java已经把迭代器模式融入到基本的API中，因此开发者不需要手写迭代器模式。

上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。

10.迭代器模式优点
迭代器模式简化了聚集的接口。迭代器具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。
每一个聚集对象都可以有一个或多个迭代器对象，每一个迭代器的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。
由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化

11.缺点
类文件增加。

#### 观察者模式

1.定义
观察者模式也叫发布订阅模式/模型，在项目中常用：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

![image](pic/p134.png)

主题接口/抽象被观察者：定义被观察对象的基本操作，需要提供观察者的添加、删除、通知功能
具体主题/具体被观察者:具体实现主题接口的方法
观察者接口:	定义观察者的基本方法，需要提供依赖对象状态改变时，本对象的更新功能
具体观察者:	观察者接口的具体实现

2.使用场景

关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。
事件多级触发场景。
跨系统的消息交换场景，如消息队列的处理机制。
Android中的列表控件、消息处理机制、广播、RxJava（扩展的观察者模式）等等

3.实例
珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动

抽象的观察者

```
public interface Observer {

  void update();
}
```

抽象的被观察者，在其中声明方法（添加、移除观察者，通知观察者）

```
public interface Observable {

  void addObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObserver();
}
```

具体的观察者
保镖

```
public class SecurityObserver implements Observer {
  @Override
  public void update() {
    System.out.println("运输车有行动，保安贴身保护");
  }
}
```

强盗

```
public class ThiefObserver implements Observer {
  @Override
  public void update() {
    System.out.println("运输车有行动，强盗准备动手");
  }
}
```

警察

```
public class PoliceObserver implements Observer {
  @Override
  public void update() {
    System.out.println("运输车有行动，警察护航");
  }
}
```

具体的被观察者

```
public class TransportObservable implements Observable {

  private final List<Observer> mList = new ArrayList<>();

  @Override
  public void addObserver(Observer observer) {
    mList.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    mList.remove(observer);
  }

  @Override
  public void notifyObserver() {
    for (Observer observer : mList) {
      observer.update();
    }
  }
}
```

测试

```
public static void main(String[] args) {

    Observable observable = new TransportObservable();

    Observer police = new PoliceObserver();
    Observer security = new SecurityObserver();
    Observer thief = new ThiefObserver();

    observable.addObserver(police);
    observable.addObserver(security);
    observable.addObserver(thief);

    observable.notifyObserver();
  }
```

结果

```
运输车有行动，警察护航
运输车有行动，保安贴身保护
运输车有行动，强盗准备动手
```

4.推拉模式

“推”的方式是指，Subject维护一份观察者的列表，每当有更新发生，Subject会把更新消息主动推送到各个Observer去。Subject主动向Observer推送消息，不管对方是否需要，推送的信息通常是目标对象的全部或部分数据，相当于广播通信。

“拉”的方式是指，各个Observer维护各自所关心的Subject列表，自行决定在合适的时间去Subject获取相应的更新数据。Subject在通知Observer时只传递少量信息，如果观察者需要更具体的信息，再由Observer主动去拉取数据。这样的模型实现中会把Subject自身通过update方法传入到Observer。

“推”的好处包括：

1、高效。如果没有更新发生，不会有任何更新消息推送的动作，即每次消息推送都发生在确确实实的更新事件之后，都是有意义的。

2、实时。事件发生后的第一时间即可触发通知操作。

3、可以由Subject确立通知的时间，可以避开一些繁忙时间。

4、可以表达出不同事件发生的先后顺序。

“拉”的好处包括：

1、如果观察者众多，Subject来维护订阅者的列表，可能困难，或者臃肿，把订阅关系解脱到Observer去完成。

2、Observer可以不理会它不关心的变更事件，只需要去获取自己感兴趣的事件即可。

3、Observer可以自行决定获取更新事件的时间。

4、拉的形式可以让Subject更好地控制各个Observer每次查询更新的访问权限。


实例：老师观察学生状态

观察者

```
public interface Observer {

  void update(Subject subject);
}
```

具体观察者

```
public class ConcreteObserver implements Observer {

  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ConcreteObserver(Subject subject) {
    subject.addObserver(this);
  }

  @Override
  public void update(Subject subject) {
    String state = subject.getState();
    System.out.println(name+"："+state);
  }
}

public class ConcreteObserver1 implements Observer {

  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ConcreteObserver1(Subject subject) {
    subject.addObserver(this);
  }

  @Override
  public void update(Subject subject) {
    String state = subject.getState();
    System.out.println(name+"：该回家"+state);
  }
}
```

被观察者

```
public interface Subject {

  void addObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObservers();

  String getState();

  void setState(String sate);
}
```

具体被观察者

```
public class ConcreteSubject implements Subject {

  private List<Observer> observers = new ArrayList<Observer>();
  private String state;

  @Override
  public void addObserver(Observer observer) {
    observers.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    observers.remove(observer);
  }

  @Override
  public void notifyObservers() {
    for (Observer observer : observers) {
      observer.update(this);
    }
  }

  @Override
  public String getState() {
    return state;
  }

  @Override
  public void setState(String state) {
    this.state = state;
    System.out.println("学生们正在：" + state);
    notifyObservers();
  }
}
```

测试

```
public static void main(String[] args) {
    Subject subject = new ConcreteSubject();
    ConcreteObserver o1 = new ConcreteObserver(subject);
    ConcreteObserver1 o2 = new ConcreteObserver1(subject);
    o1.setName("Pony");
    o2.setName("Tod");
    subject.setState("study");
  }
```

结果

```
学生们正在：study
Pony：study
Tod：该回家study
```

实例：观众读取报纸推送消息
jdk观察者模式

```
public class ReaderObserver implements Observer {

  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public void update(Observable o, Object arg) {
    System.out.println(name + "读取推送信息：" + arg);
    System.out.println(name + "读取拉取信息：" + ((NewsPaperObservable) o).getState());
  }
}
```

```
public class NewsPaperObservable extends Observable {

  private String state;

  public String getState() {
    return state;
  }

  public NewsPaperObservable() {}

  public void setState(String state) {
    this.state = state;
    // 必须调用这个方法来通知Observer状态发生了改变
    setChanged();
    notifyObservers(state);
  }
}
```

```
public static void main(String[] args) {
    ReaderObserver observer = new ReaderObserver();
    ReaderObserver observer1 = new ReaderObserver();
    NewsPaperObservable observable = new NewsPaperObservable();

    observer.setName("张三");
    observer1.setName("李四");

    observable.addObserver(observer);
    observable.addObserver(observer1);

    observable.setState("NBA大事件");
  }
```

```
李四读取推送信息：NBA大事件
李四读取拉取信息：NBA大事件
张三读取推送信息：NBA大事件
张三读取拉取信息：NBA大事件
```


5.优点

* 观察者和被观察者之间是抽象耦合。观察者和被观察者的扩展比较方便。
* 建立一套触发机制。例如建立一条触发链。

5.缺点

* 开发效率问题。一个被观察者，多个观察者，开发和调试就会比较复杂。
* 运行效率问题。多个观察者、多级触发等情况下，因为在Java默认是顺序执行，所以一个观察者卡壳，会影响整体的执行效率，这时候推荐考虑采用异步的方式。


#### 中介者模式

1.定义
中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

![image](pic/p136.png)

* 抽象同事:同事是指一些内部属性紧密相关的对象，当一个属性改变时，会尝试改变关联对象的相关内容，它们在定义时关联中介者
* 同事:实现具体的内容，以及和中介者的交互
* 抽象中介者:定义了改变时的方法
* 中介者:实现一个同事改变时所需要实现的业务

2.使用场景

* 当对象之间的交互很多而且每个对象的行为操作都依赖彼此时，为了防止在修改一个对象的行为同时涉及修改很多其他对象的行为。
* 出现了网状结构导致出现紧密耦合的时候，中介者模式可以将多对多变成一对多的关系，实现星形结构，降低系统复杂性，提高系统扩展性。
* Android中Activity就充当了中介者的角色。
* MVC、MVP等框架。

3.实现
下面以一个完整的买房子的过程为例子，介绍中介者模式的简单实现。
中介者及其实现：

```
/**
 * 中介者：协调各个同事角色，实现协作
 */
public abstract class Mediator {

    protected ConcreteColleague1 mColleague1;
    protected ConcreteColleague2 mColleague2;

    public abstract void doSomething1();

    public abstract void doSomething2();

    public ConcreteColleague1 getColleague1() {
        return mColleague1;
    }

    public void setColleague1(ConcreteColleague1 colleague1) {
        mColleague1 = colleague1;
    }

    public ConcreteColleague2 getColleague2() {
        return mColleague2;
    }

    public void setColleague2(ConcreteColleague2 colleague2) {
        mColleague2 = colleague2;
    }
}
```

```
/**
 * 例子：房产中介
 */
public class ConcreteMediator extends Mediator {

    @Override
    public void doSomething1() {
        System.out.println("房产中介：帮你找到卖家");
        //通知卖家整理好房子
        this.mColleague2.selfMethod2();
        this.mColleague2.depMethod2();
    }

    @Override
    public void doSomething2() {
        System.out.println("房产中介：帮你找到买家");
        this.mColleague1.selfMethod1();
    }

}
```

同事类及其实现：

```
/**
 * 同事类
 */
public abstract class Colleague {

    protected Mediator mMediator;

    public Colleague(Mediator mediator) {
        mMediator = mediator;
    }
}

```

```
/**
 * 买家
 */
public class ConcreteColleague1 extends Colleague {

    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }

    /**
     * 自发行为：同事本身的行为，例如改变对象自身的状态，处理自己的行为
     */
    public void selfMethod1() {
        System.out.println("买家：付款，购买房子");
    }

    /**
     * 依赖行为：自己不能完成的业务，必须依赖中介者才能完成的行为
     */
    public void depMethod1() {
        System.out.println("买家：嘿，房产中介，我要买房");
        //通知中介者，我要买房
        this.mMediator.doSomething1();
    }
}
```

```
/**
 * 卖家
 */
public class ConcreteColleague2 extends Colleague {

    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }

    public void selfMethod2() {
        System.out.println("卖家：嘿，房子整理中……房子整理好了");
    }

    public void depMethod2() {
        System.out.println("卖家：嘿，房产中介，帮我告诉买家，房子整理好了，房子可以出售");
        //通知中介者，房子可以出售
        this.mMediator.doSomething2();
    }
}
```

场景类：

```
public class Client {

    public static void main(String[] args) {
        Mediator mediator = new ConcreteMediator();
        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);
        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);
        mediator.setColleague1(colleague1);
        mediator.setColleague2(colleague2);

        //买房子
        colleague1.depMethod1();
    }

}
```

运行结果：

```
买家：嘿，房产中介，我要买房
房产中介：帮你找到卖家
卖家：嘿，房子整理中……房子整理好了
卖家：嘿，房产中介，帮我告诉买家，房子整理好了，房子可以出售
房产中介：帮你找到买家
买家：付款，购买房子
```

4.优点

中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖。同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。
降低系统复杂度，提高系统的可扩展性。

5.缺点

中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。
中介者模式容易被误用。如果几个类之间的依赖关系并不复杂，使用中介者模式反而会使得逻辑结构变复杂。

#### 状态模式

1.定义
当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。

![image](pic/p135.png)

环境(Context):也称上下文，状态决定它的现状
抽象状态(State):定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为
具体状态(ConcreteState):	每一个具体状态类都实现了环境（Context）的一个状态所对应的行为

2.使用场景

* 行为随状态改变而改变的场景。这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结果也会不同，在这种情况下需要考虑使用状态模式。
* 条件、分支判断语句的替代者。在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。
* Android中的硬件操作，例如WIFI、蓝牙等大多都使用了状态模式。
* Android中的权限机制、登录功能设计等都使用了状态模式。

实例

抽象状态角色：

```
/**
 * 抽象状态角色：接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。
 */
public abstract class State {

    //抽象环境中声明一个环境角色，提供各个状态类自行访问。
    protected Context mContext;

    public void setContext(Context context) {
        this.mContext = context;
    }

    //提供所有状态的抽象行为，由各个实现类实现。
    public abstract void handle1();
    public abstract void handle2();

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```

具体状态角色：

```
/**
 * 具体状态角色：每一个具体状态必须完成两个职责：
 * 1. 本状态的行为管理以及趋向状态处理，通俗地说，就是本状态下要做的事情。
 * 2. 以及本状态如何过渡到其他状态。
 */
public class ConcreteState1 extends State{

    @Override
    public void handle1() {
        System.out.println("ConcreteState1下必须处理的逻辑");
    }

    @Override
    public void handle2() {
        //本状态不能处理，需要切换状态，并且委托给下一个状态去处理
        System.out.println("当前状态" + this + "不能处理，切换到"+Context.STATE2);
        this.mContext.setCurrentState(Context.STATE2);
        this.mContext.handle2();
    }
}

public class ConcreteState2 extends State{

    @Override
    public void handle1() {
        System.out.println("当前状态" + this + "不能处理，切换到"+Context.STATE1);
        this.mContext.setCurrentState(Context.STATE1);
        this.mContext.handle1();
    }

    @Override
    public void handle2() {

        System.out.println("ConcreteState2下必须处理的逻辑");
    }
}
```

环境角色：

```
/**
 * 环境角色：定义客户端需要的接口，并且负责具体状态的切换。
 */
public class Context {

    //定义所有状态
    public static final State STATE1 = new ConcreteState1();
    public static final State STATE2 = new ConcreteState2();
    //当前状态
    private State mCurrentState;

    public Context() {
        //初始化
        STATE1.setContext(this);
        STATE2.setContext(this);
        this.mCurrentState = STATE1;
    }

    public State getCurrentState() {
        return this.mCurrentState;
    }

    public void setCurrentState(State state) {
        this.mCurrentState = state;
    }

    //行为委托给State去处理
    public void handle1() {
        this.mCurrentState.handle1();
    }

    public void handle2() {
        this.mCurrentState.handle2();
    }
}
```

场景类：

```
public class Client {

    public static void main(String[] args) {
        Context context = new Context();
        System.out.println("当前状态：" + context.getCurrentState());
        context.handle1();
        System.out.println("当前状态：" + context.getCurrentState());
        context.handle2();
        System.out.println("当前状态：" + context.getCurrentState());
    }
}
```

运行结果：
当前状态：ConcreteState1
ConcreteState1下必须处理的逻辑
当前状态：ConcreteState1
当前状态ConcreteState1不能处理，切换到ConcreteState2
ConcreteState2下必须处理的逻辑
当前状态：ConcreteState2

4.优点

结构清晰。避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，提高系统的可维护性。
遵循设计原则。很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，需要要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。
封装性非常好。这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。

5.缺点

状态模式的缺点是状态过多的时候，状态子类会太多，也就是类膨胀

#### 策略模式

1.介绍
1.1 定义
定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 & 让算法可在不影响客户端的情况下发生变化

>简单来说：准备一组算法 & 将每一个算法封装起来，让外部按需调用 & 使得互换

1.2 作用（解决的问题）
将算法的责任和本身进行解耦，使得：

算法可独立于使用外部而变化
客户端方便根据外部条件选择不同策略来解决不同问题


>策略模式仅仅封装算法（包括添加 & 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定


2.模式原理
2.1 UML类图 & 组成

![image](pic/p137.png)

* 环境(Context):持有一个(Strategy)的引用
* 抽象策略(Strategy):定义所有的具体策略类所需的实现的方法
* 具体策略(ConcreteStrategy):实现具体方法，定义方法中的具体算法

3.使用场景

多个类只有在算法或行为上稍有不同的场景。
算法需要自由切换的场景。
需要屏蔽算法规则的场景。
同一抽象有多个子类，而且需要使用if-else、switch-case来选择具体的子类的时候。
Android中，设计图片加载框架的时候，可以使用策略模式来选择加载策略。

4.实现

a. 实例概况

背景：小成有一家百货公司，最近在定年度的促销活动
冲突：每个节日用同一个促销活动太枯燥，没吸引力
解决方案：针对不同节目使用不同促销活动进行促销

策略的抽象及其实现：
```
/** 抽象策略角色 通常为接口，定义每个策略或算法必须具有的方法和属性。 */
public interface Strategy {
  void doing(String someThing);
}

/** 具体策略角色 实现抽象策略中的操作，该类含有具体的算法。 */
public class SpringFestivalStrategy implements Strategy {
  @Override
  public void doing(String someThing) {
    System.out.println("正在搞" + someThing + "活动");
  }
}

public class AutumnFestivalStrategy implements Strategy {
  @Override
  public void doing(String someThing) {
    System.out.println("正在搞" + someThing + "活动");
  }
}

public class ChristmasStrategy implements Strategy {
  @Override
  public void doing(String someThing) {
    System.out.println("正在搞" + someThing + "活动");
  }
}
``` 

上下文角色：

```
/** Context封装角色：它也叫做上下文角色 起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 */
public class Context {

  private Strategy strategy;

  public Context(Strategy strategy) {
    this.strategy = strategy;
  }

  public void setStrategy(Strategy strategy) {
    this.strategy = strategy;
  }

  public void show(String str) {
    strategy.doing(str);
  }
}
```

测试

```
public static void main(String[] args) {
    Strategy s1 = new SpringFestivalStrategy();
    Strategy s2 = new AutumnFestivalStrategy();
    Strategy s3 = new ChristmasStrategy();

    // 执行策略1
    Context context = new Context(s1);
    context.show("春节");

    // 替换策略，然后执行策略2
    context.setStrategy(s2);
    context.show("中秋节");

    context.setStrategy(s3);
    context.show("圣诞节");
  }
```

结果

```
正在搞春节活动
正在搞中秋节活动
正在搞圣诞节活动
```

5.优点
封装性好，使用简单。
算法可以自由切换。
避免使用多重条件判断。
扩展性良好。扩展只需要增加策略的具体实现类，替换策略。符合开闭原则。
6.缺点
随着策略的增加，策略类数量增多。
所有的策略类都需要对外暴露，与迪米特原则相违背。

#### 责任链模式

1.定义
使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。

![image](pic/p138.png)

* 抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。
* 具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

2.使用场景

多个对象可以处理同一个请求，但是具体由哪个对象处理需要在运行时动态决定。
在处理对象不明确的前提下，向多个对象提交一个请求。
需要动态指定一组对象来处理请求。

3.实现

a.简单示例

抽象处理者

```
public abstract class Handler {
    
	/**
	 * 持有后继的责任对象
	 */
	protected Handler successor;
	/**
	 * 示意处理请求的方法，虽然这个示意方法是没有传入参数的
	 * 但实际是可以传入参数的，根据具体需要来选择是否传递参数
	 */
	public abstract void handleRequest();
	/**
	 * 取值方法
	 */
	public Handler getSuccessor() {
	    return successor;
	}
	/**
	 * 赋值方法，设置后继的责任对象
	 */
	public void setSuccessor(Handler successor) {
	    this.successor = successor;
	}
}    
```

具体处理者角色

```
public class ConcreteHandler extends Handler {
    /**
     * 处理方法，调用此方法处理请求
     */
    @Override
    public void handleRequest() {
        /**
         * 判断是否有后继的责任对象
         * 如果有，就转发请求给后继的责任对象
         * 如果没有，则处理请求
         */
        if(getSuccessor() != null){            
            System.out.println("放过请求");
            getSuccessor().handleRequest();            
        }else{            
            System.out.println("处理请求");
        }
    }
 
}
```

测试

```
public static void main(String[] args) {
    //组装责任链
    Handler handler1 = new ConcreteHandler();
    Handler handler2 = new ConcreteHandler();
    handler1.setSuccessor(handler2);
    //提交请求
    handler1.handleRequest();
}
```

结果

```

```

可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。
由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。
因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。

![image](pic/p139.png)

b.申请聚餐费用的管理

申请聚餐费用的管理，申请聚餐费用的大致流程一般是，由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。
不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。

![image](pic/p140.png)

当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。申请人只要直接与项目经理交互就可以，其余的工作在黑盒中，究竟流程是怎样的，最后是由谁审批通过的，申请人无需关心。

![image](pic/p141.png)

![image](pic/p142.png)

抽象处理者角色类

```
public abstract class Handler {
/**
 * 持有下一个处理请求的对象
 */
protected Handler successor = null;
/**
 * 取值方法
 */
public Handler getSuccessor() {
    return successor;
}
/**
 * 设置下一个处理请求的对象
 */
public void setSuccessor(Handler successor) {
    this.successor = successor;
}
/**
 * 处理聚餐费用的申请
 * @param user    申请人
 * @param fee    申请的钱数
 * @return        成功或失败的具体通知
 */
public abstract String handleFeeRequest(String user , double fee);
}
```

具体处理者角色

```
public class ProjectManager extends Handler {
 
    @Override
    public String handleFeeRequest(String user, double fee) {
        
    String str = "";
    //项目经理权限比较小，只能在500以内
    if(fee < 500){
        //为了测试，简单点，只同意张三的请求
        if("张三".equals(user)){
            str = "成功：项目经理同意【" + user + "】的聚餐费用，金额为" + fee + "元";    
        }else{
            //其他人一律不同意
            str = "失败：项目经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元";
        }
    }else{
        //超过500，继续传递给级别更高的人处理
        if(getSuccessor() != null){
            return getSuccessor().handleFeeRequest(user, fee);
        }
    }
    return str;
    }
 }
```

```
public class DeptManager extends Handler {
 
    @Override
    public String handleFeeRequest(String user, double fee) {
        
        String str = "";
        //部门经理的权限只能在1000以内
        if(fee < 1000)
        {
            //为了测试，简单点，只同意张三的请求
            if("张三".equals(user)){
                str = "成功：部门经理同意【" + user + "】的聚餐费用，金额为" + fee + "元";    
            }else{
                //其他人一律不同意
                str = "失败：部门经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元";
            }
        }else{
            //超过1000，继续传递给级别更高的人处理
            if(getSuccessor() != null){
                return getSuccessor().handleFeeRequest(user, fee);
            }
        }
        return str;
    }
 
}

```

```
public class GeneralManager extends Handler {
 
    @Override
    public String handleFeeRequest(String user, double fee) {
        
        String str = "";
        //总经理的权限很大，只要请求到了这里，他都可以处理
        if(fee >= 1000){
            //为了测试，简单点，只同意张三的请求
            if("张三".equals(user)){
                str = "成功：总经理同意【" + user + "】的聚餐费用，金额为" + fee + "元";    
            }else{
                //其他人一律不同意
                str = "失败：总经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元";
            }
        }else{
            //如果还有后继的处理对象，继续传递
            if(getSuccessor() != null){
                return getSuccessor().handleFeeRequest(user, fee);
            }
        }
        return str;
    }
 
}
```

```
public static void main(String[] args) {
    //先要组装责任链
    Handler h1 = new GeneralManager();
    Handler h2 = new DeptManager();
    Handler h3 = new ProjectManager();
    h3.setSuccessor(h2);
    h2.setSuccessor(h1);
    
    //开始测试
    String test1 = h3.handleFeeRequest("张三", 300);
    System.out.println("test1 = " + test1);
    String test2 = h3.handleFeeRequest("李四", 300);
    System.out.println("test2 = " + test2);
    System.out.println("---------------------------------------");
    
    String test3 = h3.handleFeeRequest("张三", 700);
    System.out.println("test3 = " + test3);
    String test4 = h3.handleFeeRequest("李四", 700);
    System.out.println("test4 = " + test4);
    System.out.println("---------------------------------------");
    
    String test5 = h3.handleFeeRequest("张三", 1500);
    System.out.println("test5 = " + test5);
    String test6 = h3.handleFeeRequest("李四", 1500);
    System.out.println("test6 = " + test6);
}
```

4.职责链灵活在哪

1. 改变内部的传递规则
在内部，项目经理完全可以跳过人事部到那一关直接找到总经理。
每个人都可以去动态地指定他的继任者。
2. 可以从职责链任何一关开始。
如果项目经理不在，可以直接去找部门经理，责任链还会继续，没有影响。
3. 用与不用的区别
不用职责链的结构，我们需要和公司中的每一个层级都发生耦合关系。
如果反映在代码上即使我们需要在一个类中去写上很多丑陋的if….else语句。
如果用了职责链，相当于我们面对的是一个黑箱，我们只需要认识其中的一个部门，然后让黑箱内部去负责传递就好了

5.纯的与不纯的责任链模式

* 一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，二是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。
* 在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。
纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。

6.优点

责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌。
请求和处理解耦，提高了系统的灵活性。

7.缺点

性能问题。每个请求都是从链头遍历到链尾,特别是在链比较长的时候,性能是一个非常大的问题。（观察者模式也有类似问题）
调试不很方便。特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。


