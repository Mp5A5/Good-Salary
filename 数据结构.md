## 常用数据结构简介
#### 简介
数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。  

数据结构的基本功能

* 如何插入一条新的数据项
* 如何寻找某一特定的数据项
* 如何删除某一特定的数据项
* 如何迭代的访问各个数据项，以便进行显示或其他操作

#### 常用的数据结构

![avatar](pic/p79.png)

这几种结构优缺点如下：先有个大概印象，后面会详细讲解！！！

![avatar](pic/p80.png)

#### 算法
算法简单来说就是解决问题的步骤。  
在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。  

1.算法的5个特征

* 有穷性：对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。
* 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。
* 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。
* 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。
* 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。

2.算法的设计原则

* 正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：
1. 程序语法错误。
2. 程序对于几组输入数据能够得出满足需要的结果。
3. 程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果。
4. 程序对于一切合法的输入数据都能得到满足要求的结果。
5. 通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。
* 可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。
* 健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。
* 高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。  

前面三点 正确性，可读性和健壮性相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。  
相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；
表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；  
复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。

然后我们在说说算法的存储量，包括：

* 程序本身所占空间；
* 输入数据所占空间；
* 辅助变量所占空间；

一个算法的效率越高越好，而存储量是越低越好。

## 并发集合了解哪些？

Java并发集合

1.引言
Java集合包括ArrayList、HashSet、HashMap、ArrayQueue等集合都有一个共同的特点，那就是线程不安全性，在并发情况下都不能保证数据的一致性。（当然，这个集合必须是共享了，所以才会有数据不一致）
所以，当我们在进行并发任务时候，共享了一个不适用于并发的数据结构，也就是将此数据结构变成了程序中的成员变量，那么我们将会遇到数据的不一致，进而影响到我们程序的运行。
为了应对并发场景的出现，Java在后续迭代过程中（具体应该是JDK1.5版本），推出了java.util.concurrent包。该包的出现，让Java并发编程变得更加轻松，帮助开发者编写更加高效、易维护、结构清晰的程序。
在java.util.concurrent包中，不但包含了线程安全的集合，还涉及到了多线程、CAS、线程锁等相关内容，可以说是完整覆盖了Java并发的知识栈。

2 并发集合实现1
JDK1.5的出现，对于集合并发编程来说，java developer有了更多的选择。不过，在JDK1.5之前，Java也还是提供了一些解决方案。
（1）最为简单直接的就是在程序中我们自己对共享变量进行加锁。不过，缺点也显而易见，手动实现线程安全间接增加了程序的复杂度，以及代码出错的概率---例如：线程死锁的产生；
（2）我们还可以使用Java集合框架中的Vector、Hashtable实现类，这两个类都是线程安全的。不过，Java已不提倡使用。
（3）此外，我们还可以使用集合工具类--Collections，通过调用其中的静态方法，来得到线程安全的集合。具体方法，包括：Collections.synchronizedCollection(Collection<T> c)、Collections.synchronizedSet(Set<T> s)、Collections.synchronizedList(List<T>)、Collections.synchronizedMap(Map<K, V>)。
究其原理，他们都是通过在方法中加synchronized同步锁来实现的。我们知道synchronized锁的开销较大，在程序中不建议使用。

并发集合实现2
在java.util.concurrent包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。
阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行。
非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。
下面，就来看下concurrent包下，到底存在了哪些线程安全的集合：

![image](pic/p99.png )

List：
CopyOnWriteArrayList

Set：
CopyOnWriteArraySet
ConcurrentSkipListSet

Queue：
BlockingQueue:
    LinkedBlockingQueue
    DelayQueue
    PriorityBlockingQueue
    ConcurrentLinkedQueue
    TransferQueue:
        LinkedTransferQueue
    BlockingDeque:
        LinkedBlockingDeque
        ConcurrentLinkedDeque

Map集合：

![image](pic/p100.png )

Map:
ConcurrentMap:
    ConcurrentHashMap
    ConcurrentSkipListMap
    ConcurrentNavigableMap

通过以上可以看出，java.util.concurrent包为每一类集合都提供了线程安全的实现。

## 列举java的集合以及集合之间的继承关系

![avatar](pic/p81.png )

##### Iterable
Iterator是迭代器类，而Iterable是为了只要实现该接口就可以使用foreach，进行迭代.
Iterable中封装了Iterator接口，只要实现了Iterable接口的类，就可以使用Iterator迭代器了。
实现此接口允许对象成为“for-each loop”语句的目标

``` java
public interface Iterable<T> {
    
    //返回类型为T元素的迭代器
    Iterator<T> iterator();

    //对Iterable的每个元素执行给定的操作，直到所有元素都被处理或引发异常。 除非实现类另有规定，否则按照迭代的顺序执行操作（如果指定了迭代顺序）。 动作抛出的异常被抛出给调用者。
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }

	 //在Iterable描述的元素上创建一个Iterable
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
##### Iterator
一个集合的迭代器。 Iterator替代Enumeration在Java集合框架。 迭代器有两个方面不用于Enumeration：

* 迭代器允许调用者在具有明确定义的语义的迭代期间从底层集合中删除元素。
* 方法名称已得到改进。

此接口是成员Java Collections Framework 。

``` java
public interface Iterator<E> {

    boolean hasNext();

   
    E next();

    //从底层集合中删除此迭代器返回的最后一个元素（可选操作）。此方法只能调用一次next() 。 如果底层集合在迭代过程中以任何方式进行修改而不是通过调用此方法，则迭代器的行为是未指定的。
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    //对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 如果指定了该顺序，则按迭代的顺序执行操作。 动作抛出的异常被抛出给调用者。
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
##### Collection

集合体系中的根接口。 集合表示一组称为其元素的对象。 有些集合允许有重复元素而其他则不允许。 有些是有序的，有些是无序的。 JDK不提供此接口的任何直接实现：它提供了更具体的子接口（如Set和List）的实现。 此接口通常用于传递集合并在需要最大通用性的情况下对其进行操作。  
包或多个集合（可能包含重复元素的无序集合）应直接实现此接口。  
所有通用Collection实现类（通常通过其子接口间接实现Collection）应提供两个“标准”构造函数：void（无参数）构造函数，它创建一个空集合，以及一个有参构造函数，其中一个参数类型 Collection，使用与其参数相同的元素创建新集合。 实际上，后一个构造函数允许用户复制任何集合，从而生成所需实现类型的等效集合。 没有办法强制执行此约定（因为接口不能包含构造函数），但Java平台库中的所有通用Collection实现都符合。  
如果此集合不支持该操作，则指定此接口中包含的“破坏性”方法（即修改其操作集合的方法）将抛出UnsupportedOperationException。 如果是这种情况，调用对集合没有影响，则这些方法可能（但不是必须）抛出UnsupportedOperationException。 例如，如果要添加的集合为空，则可以（但不是必须）在不可修改的集合上调用addAll（Collection）方法抛出异常。  
某些集合实现对它们可能包含的元素有限制。 例如，某些实现禁止null元素，并且一些实现对其元素的类型有限制。 尝试添加不合格的元素会引发未经检查的异常，通常是NullPointerException或ClassCastException。 尝试查询不合格元素的可能会引发异常，或者它可能只是返回false; 一些实现将展示前一种行为，一些将展示后者。 更一般地，尝试对不合格的元素进行操作，其完成不会导致将不合格的元素插入到集合中，可以在实现的选择中抛出异常或者它可以成功。 此类异常在此接口的规范中标记为“可选”。  
由每个集合决定自己的同步策略。 在实现没有更强的保证的情况下，未定义的行为可能是由于另一个线程正在调用集合上的任何方法的调用引起的; 这包括直接调用，将集合传递给可能执行调用的方法，以及使用现有迭代器来检查集合。  
Collections框架接口中的许多方法都是根据equals方法定义的。 例如，contains（Object o）方法的规范：“当且仅当此集合包含至少一个元素e时才返回true（o == null？e == null：o.equals（e））“。 不应将此规范解释为使用非null参数o调用Collection.contains将导致对任何元素e调用o.equals（e）。 实现可以自由地优化，从而避免等同调用，例如，首先比较两个元素的哈希码。 （Object.hashCode（）规范保证具有不等哈希码的两个对象不能相等。）一般地，各种集合框架接口的实现可以自由地利用底层Object方法的指定行为，只要实现者认为它是合适的  。  
执行集合的递归遍历的某些集合操作可能会失败，而自引用实例的例外情况是集合直接或间接包含自身。 这包括clone（），equals（），hashCode（）和toString（）方法。 可以可选地处理自引用场景，但是大多数当前实现不这样做。  
此接口是Java集合框架的成员。
#### ArrayList

![avatar](pic/p82.png )

##### AbstractList

此类提供List接口的骨干实现，以最大限度地减少实现由“随机访问”数据存储（例如数组）支持的此接口所需的工作量。对于顺序访问数据（例如链接列表），应优先使用AbstractSequentialList，而不是此类。  
要实现不可修改的列表，程序员只需要扩展此类并提供get（int）和size（）方法的实现。  
要实现可修改的列表，程序员必须另外覆盖set（int，E）方法（否则会抛出UnsupportedOperationException）。如果列表是可变大小的，则程序员必须另外覆盖add（int，E）和remove（int）方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和集合构造函数。  
与其他抽象集合实现不同，程序员不必提供迭代器实现;迭代器和列表迭代器是由这个类在“随机访问”方法之上实现的：get（int），set（int，E），add（int，E）和remove（int）。  
此接口是Java集合框架的成员。 
在这个抽象类中，我们可以发现，很多方法的实现，都是抛出一个UnsupportedOperationException异常，等待具体的实现类来实现．  
未实现的方法：  

* 添加元素 add(E e)、add(int index,  E element)
* 替换指定索引位置的元素 set(int index, Eelement) 
* 删除指定所引处的元素 remove(int index) 
* 凡是涉及到与数据存储结构有关的方法均不能实现

在indexOf方法的实现中，我们可以看到，它是采用的顺序遍历的方式，这是最常见但是同时效率也是最低的遍历方式．

``` java
/**
     * 功能：获取集合第一次出现的指定元素的索引
     * 实现：
     * 1.获取List集合特有迭代器listIterator
     * 2.如果待查找参数为null，遍历集合找到第一个为null的元素并返回，如果没找到返回-1
     * 3.如果待查找参数不为null，遍历集合使用equals方法找到第一个相同元素并返回，没有返回-1
     */
    public int indexOf(Object o) {
        ListIterator<E> it = listIterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return it.previousIndex();
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return it.previousIndex();
        }
        return -1;
```
同时，我们也能看到，AbstractList是允许其中的元素为null的．如果找到元素，则返回其所在的位置，否则返回-1.
在各种查找算法中，性能最好的，似乎就是O(logn)了．但是这些算法都需要数据是有序的．那么存不存在一种算法，即使数据是无序的，其时间复杂度也比O(n)好呢?
确实存在，那就是哈希算法，如果能够确定有效的哈希函数，那么查找性能是O(1)．远比O(n)要好的多．可是，如何设计这么一个高效的哈希函数呢?
但是，使用这种方式，我们能保证，读取的时候，如果按照索引来读取，读取到的元素的顺序，跟元素被插入时的顺序相同．而如果使用哈希函数，则不能保证这一点．
AbstractList中，还为我们提供了一个获取元素的最后出现位置的方法，跟上面那个获取第一次出现位置的方法没什么不同，只不过是从后面开始遍历的．

``` java
/**
     * 功能：获取集合最后一次出现指定元素的索引
     * 实现：
     * 1.同上一个方法类似
     */
    public int lastIndexOf(Object o) {
        ListIterator<E> it = listIterator(size());
        if (o==null) {
            while (it.hasPrevious())
                if (it.previous()==null)
                    return it.nextIndex();
        } else {
            while (it.hasPrevious())
                if (o.equals(it.previous()))
                    return it.nextIndex();
        }
        return -1;
    }
```
除此之外, AbstractList还提供了一个iterator()方法，这个方法相信各位已经很熟悉了，它会获取一个实现了Iterator接口的Itr类用于迭代当前的List.

```java
 //继承自父类的迭代器 iterator()
/**
     * 功能：获取迭代器
     * 实现：
     * 1.通过匿名内部类实现迭代器，创建迭代器Iterator实现类并返回
     */
    public Iterator<E> iterator() {
        return new Itr();
    }
    private class Itr implements Iterator<E> {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        /**
         * 元素索引指针
         */
        int cursor = 0;
 
        /**
         * Index of element returned by most recent call to next or
         * previous.  Reset to -1 if this element is deleted by a call
         * to remove.
         */
        /**
         *最近一次调用返回到下一个或上一个的元素索引。 如果通过删除调用删除此元素，则重置为-1。
         * 通俗点说，他保存cursor操作前的索引
         */
        int lastRet = -1;
 
        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        /**
         * 迭代器认为后备列表应具有的modCount值。 如果违反了此期望，则迭代器已检测到并发修改。
         */
        int expectedModCount = modCount;
 
        /**
         * 功能：检查是否还有下一个元素
         * 实现：
         * 1.迭代器每次迭代出一个元素时元素索引指针cursor都会下移
         * 2.通过检查元素指针cursor是否等于集合长度判断时候还有元素
         */
        public boolean hasNext() {
            return cursor != size();
        }
 
        /**
         * 功能：获取当前元素索引指针(cursor)处的元素
         * 实现：
         * 1.检测是否发生并发修改，并发修改则抛出异常
         * 2.获取当前元素索引指针所指向的元素，保存当前索引到lastRet、cursor++
         * 3.返回回去到的元素
         */
        public E next() {
            checkForComodification();
            try {
                int i = cursor;
                E next = get(i);
                lastRet = i;
                cursor = i + 1;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }
 
        /**
         * 功能：删除lastRet索引处的元素
         * 实现：
         * 1.对lastRet进行和是否并发修改进行检查
         * 2.调用AbstractList超类的remove方法删除lastRet索引处的元素
         * 3.如果元素索引指针cursor大于lastRet，则将cursor迁移一位，lastRet置为-1
         */
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
 
            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }
 
        /**
         * 功能：检查是否发生并发修改
         * 实现：
         * 1.通过modCount和expectedModCount是否相等检查
         */
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

```
但是，它不是线程安全的．也就是说，如果我们已经获取到了Iterator了，而此后这个List被其他的线程修改了，那么会抛出运行时异常．
它还提供了一个listIterator()的方法，它会返回一个实现了ListIterator接口的ListItr类.那么Itr和ListItr有什么区别呢?

```java
/**
     * 功能：List特有迭代器
     * 实现：调用listIterator(final int index)获取迭代器
     * 注：每次调用，迭代器都能从头开始
     */
    public ListIterator<E> listIterator() {
        return listIterator(0);
    }
 
    /**
     * 功能：获取List集合特有迭代器
     * 实现：
     * 1.检查索引范围无误后创建并返回迭代器实现类对象
     */
    public ListIterator<E> listIterator(final int index) {
        rangeCheckForAdd(index);
 
        return new ListItr(index);
    }
 
    private class ListItr extends Itr implements ListIterator<E> {
        /**
         * ListItr类有参构造器，初始化开始元素索引指针位置
         */
        ListItr(int index) {
            cursor = index;
        }
 
        /**
         * 功能：检查cursor指针前面是否还有元素
         * 实现:
         * 1.通过cursor是否等于0判断
         */
        public boolean hasPrevious() {
            return cursor != 0;
        }
 
        /**
         * 功能：获取前一个元素
         * 实现：
         * 1.检查是否发生并发操作，是则抛异常
         * 2.将现在cursor向前移动一位，获取元素并返回
         */
        public E previous() {
            checkForComodification();
            try {
                int i = cursor - 1;
                E previous = get(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }
 
        /**
         * 功能：获取当前指针索引
         */
        public int nextIndex() {
            return cursor;
        }
 
        /**
         * 功能：获取上一个元素指针索引
         */
        public int previousIndex() {
            return cursor-1;
        }
 
        /**
         * 功能：替换元素
         * 实现：
         * 1.检查lastRet是否越界，检查时候并发操作
         * 2.调用AbstractList的set方法进行替换
         */
        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
 
            try {
                AbstractList.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
 
        /**
         * 功能：添加元素
         * 实现：
         * 1.检查是否并发操作，是则抛异常
         * 2.调用AbstractList的add方法进行添加操作，并将元素指针索引 + 1
         */
        public void add(E e) {
            checkForComodification();
 
            try {
                int i = cursor;
                AbstractList.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
```
我们从名字上应该也能看出来，Itr类是ListItr的父类，它实现了Iterator接口，并实现了了一下几个方法:hasNext, next, remove, checkForComodification.我们可以看到，它只能向后遍历(这里称向索引大的元素遍历称为向后遍历),并且，只能从数据容器的起点开始读，也只能移除某个元素，而无法在迭代的过程中，重新设置此元素的值．
而ListItr呢，继承了Itr的那些特性，同时通过实现ListIterator类，增加了自己的特性．它相对于Itr增加了如下方法:hasPrevious, previous, set, add.从这些函数的名字中，我们就可以知道，它支持向前遍历，在遍历的过程中重新设置元素的值，以及在遍历过程中增加元素．
并且，我们可以看到它的构造函数声明如下:

``` java 
ListItr(int index) {
   cursor = index;
}
```
我们可以看到，我们可以从指定的位置开始进行迭代．
在Itr和ListItr的实现中，我们可以看到，基本上每个方法的实现，都会调用一个叫做checkForComodification()的方法．这个方法是干什么的呢?Itr和ListItr中，都会维护一个变量，叫做expectedModCount，它记录了它认为List被修改的次数，刚开始时，它被初始化为List被修改的次数．checkForComodification()方法，通过将这个变量，和另一个表示List实际被修改的次数的叫做modCount的变量比较，就能得知，在获取到Iterator之后，List是否被修改过，进而抛出ConcurrentModificationException异常．
当然，前面也介绍了,Itr和ListItr实际上也可以在遍历过程中修改List，所以我们在那些修改List的结构的方法中，就需要再同步一下expectedModCount和modCount的值．防止是由于Iterator本身修改了List而导致抛出ConcurrentModificationException.
以Itr的remove为例:

``` java
public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }
```
那modCount这个变量的值都是在什么情况下会被修改呢?
当我们的子类在实现AbstractList时，对于那些修改List结构的方法，比如会造成List的大小发生了变化的函数，那么我们可以在这些方法内部，让modCount+1.来实现让Iterator发现List被修改过并抛出错误的功能．
我们为什么需要让Iterator发现List被修改过并抛出异常呢?这是为了防止在并发的环境下，造成不确定的问题．

AbstractList还给我们提供了一个removeRange方法，通过这个方法，我们可以删除一定范围内的元素，并将此范围右侧的元素左移(但是我并没有发现它实现了将元素左移的功能).此方法接受两个参数，一个是fromIndex,另一个是toIndex，分别代表要删除的元素的范围的起点和终点，不包含终点．如果你指定的fromIndex和toIndex相同，那么并不会删除那一个特定的元素，而是会一点作用没有，相当于并没有调用这个函数．

``` java 
* 功能：删除集合的所有元素
     * 实现：
     * 1.调用removeRange方法删除集合整个范围内的所有元素
     */
    public void clear() {
        removeRange(0, size());
    }
 
    /**
     * 功能：删除指定范围内的所有元素
     * 实现：
     * 1.通过特有迭代器获取fromIndex索引处开始到结尾的所有元素
     * 2.通过for循环，逐个删除元素
     */
    protected void removeRange(int fromIndex, int toIndex) {
        ListIterator<E> it = listIterator(fromIndex);
        for (int i=0, n=toIndex-fromIndex; i<n; i++) {
            it.next();
            it.remove();
        }
    }

```

AbstractList提供了一个addAll(int index, Collection<? extends E> c)方法，

``` java
/**
     * 功能：在指定位置添加一个集合的元素
     * 实现：
     * 1.检查是否并发操作
     * 2.遍历参数集合并调用add(int index, E e)方法进行这个添加，每次添加后索引+1
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);
        boolean modified = false;
        for (E e : c) {
            add(index++, e);
            modified = true;
        }
        return modified;
    }

```

AbstractList提供了一个subList()方法，它接受两个参数，一个是AbstractList开始切分位置，另一个是AbstractList结束拆分的位置．
这个方法，会返回一个SubList，如果当前AbstractList实现了RandomAccess接口，那么就返回RandomAccessSubList．
那么SubList又是个什么鬼呢?
AbstractList的subList()方法，在形成子列表时，并不会创建一个新的AbstractList,并将父AbstractList中的相应的元素拷贝进去．那它是怎样做的呢?
它是写了一个Wrapper,这个Wrapper就是SubList．既然是一个Wrapper,那么它内部肯定是封装了一个AbstractList实例，并维护了一些其他信息．我们来看一下这个类的属性，以及其构造方法:

```java
class SubList<E> extends AbstractList<E> {
    private final AbstractList<E> l;
    private final int offset;
    private int size;

    SubList(AbstractList<E> list, int fromIndex, int toIndex) {
        if (fromIndex < 0)
            throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
        if (toIndex > list.size())
            throw new IndexOutOfBoundsException("toIndex = " + toIndex);
        if (fromIndex > toIndex)
            throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                               ") > toIndex(" + toIndex + ")");
        l = list;
        offset = fromIndex;
        size = toIndex - fromIndex;
        this.modCount = l.modCount;
    }
```
其中l这个AbstractList，就是要获取子列表的那个AbstractList的实例．offset这个属性，代表的是，从哪里开始是子列表．就是subList()方法的fromIndex参数．size这个属性，代表的是子列表的长度，就是subList的toIndex - fromIndex的值．
从其他的函数中，我们可以发现，实际上，修改这个SubList就是修改的原AbstractList．同时，我们也会发现，如果我们在获取到SubList之后，做了一些会造成AbstractList的modCount属性发生变化的操作，那么就会让SubList失效并抛出ConcurrentModificationException了．
SubList能改变原集合的值，所以我们在使用时要慎重，如果不想改变原集合的值，那么我们就要把这个subList保存到另一个集合中使用它。

##### AbstractCollection

此类提供Collection接口的骨干实现，以最大限度地减少实现此接口所需的工作量。  
要实现不可修改的集合，程序员只需要扩展此类并提供迭代器和大小方法的实现。 （迭代器方法返回的迭代器必须实现hasNext和next。）  
要实现可修改的集合，程序员必须另外覆盖此类的add方法（否则会抛出UnsupportedOperationException），并返回迭代器方法，必须实现其remove方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和Collection构造函数。  
此类中每个非抽象方法的文档详细描述了它的实现。如果正在实施的集合允许更有效的实现，则可以覆盖这些方法中的每一个。  
此接口是Java集合框架的成员。

``` java
public abstract class AbstractCollection<E> implements Collection<E> {
   
    protected AbstractCollection() {
    }

    public abstract Iterator<E> iterator();

    public abstract int size();
	
	//判断集合是否为空
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * 判断是否包含指定的元素
     * （1）如果参数为null，查找值为null的元素，如果存在，返回true，否则返回false。
     * （2）如果参数不为null，则根据equals方法查找与参数相等的元素，如果存在，则返回true，否则返回false。
     * 注意：这里必须对null单独处理，否则null.equals会报空指针异常
     */
    public boolean contains(Object o) {
        Iterator<E> it = iterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return true;
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return true;
        }
        return false;
    }

    
    /**
     * 功能：将集合元素转换为数组
     * 实现：
     * （1）创建一个数组，大小为集合中元素的数量
     * （2）通过迭代器遍历集合，将当前集合中的元素复制到数组中（复制引用）
     * （3）如果集合中元素比预期的少，则调用Arrays.copyOf()方法将数组的元素复制到新数组中，并返回新数组
     * （4）如果集合中元素比预期的多，则调用finishToArray方法生成新数组，并返回新数组，否则返回（1）中创建的数组
     */
    public Object[] toArray() {
        Object[] r = new Object[size()];
        Iterator<E> it = iterator();
        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) // 比预想的元素要少
                return Arrays.copyOf(r, i);
            r[i] = it.next();
        }
        return it.hasNext() ? finishToArray(r, it)/*比预想的元素多*/ : r;
    }
    
	/**
	*如果参数数组的长度小于集合的长度，则用反射创建一个T类型的数组，否则就是用这个数组的引用，
	*还是通过迭代器遍历数组范围的集合元素将其元素 引用复制到数组当中，判断集合的元素是
	*否大于小于等于预期大小（size的大小）分不同的处理情况来处理。
	*/
	//功能：通过泛型约束返回指定类型的数组
   // (1) 如果参数数组长度大于等于集合的长度，则将当前集合的元素复制到参数数组当中
   // (2) 如果参数数组的长度小于集合的长度，则通过数组的反射创建T类型的新数组来容纳集合元素
    public <T> T[] toArray(T[] a) {
        // Estimate size of array; be prepared to see more or fewer elements
        int size = size();
        T[] r = a.length >= size ? a :
                  (T[])java.lang.reflect.Array
                  .newInstance(a.getClass().getComponentType(), size);
        Iterator<E> it = iterator();

        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) { // fewer elements than expected 在数组长度范围内出现没有下一个元素的情况，说明集合大小小于数组的长度
                if (a == r) { //如果a 和 r 所引用的数组相同，则将剩下的数组元素都赋值为null，作为集合元素的结束标志
                    r[i] = null; // null-terminate
                } else if (a.length < i) {//如果参数数组的长度小于集合的长度，也就是r是通过反射新创建的数组，则通过Arrays.copyOf方法截短返回
                    return Arrays.copyOf(r, i);
                } else {//r是通过反射新创建的数组，但是参数数组长度大于集合长度，
                          //即a的长度大于新创建的r数组的长度(这在单线程情况下不可能发生，但是在
                          //并发情况下参数数组的长度可能发生变化)，则将r数组复制到a数组当中，并
                          //将参数数组多的元素设置为null
                    System.arraycopy(r, 0, a, 0, i);//将创建的r数组所有元素复制到a数组当中
                    if (a.length > i) {
                        a[i] = null;
                    }
                }
                return a;
            }
            r[i] = (T)it.next(); //类型转换，可能会抛出ClassCastException异常
        }
        // more elements than expected
        // 如果集合长度大于数组的长度则拓展数组r，否则(集合长度正好等于数组的长度)直接返回数组r
        return it.hasNext() ? finishToArray(r, it) : r;
    }

	/**
	*数组的最大可分配大小为整数的最大值，但是有些虚拟机会保留几个字节大小的空间存储头部，
	*所以为了保险起见最大可分配的数组大小为整数最大值-8，否则会抛出内存溢出错误
	*/
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    
	/**
     *  （1）对数组进行扩容：即创建一个更长的数组，然后将原数组的内容复制到新数组中
     *  （2）扩容大小：cap + cap/2 +1
     *  （3）扩容前需要先判断是否数组长度是否溢出
     */
    private static <T> T[] finishToArray(T[] r, Iterator<?> it) {
        int i = r.length;//记录数组有效长度
        while (it.hasNext()) {
            int cap = r.length;//数组最大可用容量
            if (i == cap) {//当数组有效长度和数组最大可用容量相等时，再次扩容
                int newCap = cap + (cap >> 1) + 1; //扩容为 cap + cap/2 +1
                // overflow-conscious code
                if (newCap - MAX_ARRAY_SIZE > 0)//新扩大的容量发生溢出
                    newCap = hugeCapacity(cap + 1);
                //Arrays.copyOf方法内部创建了一个新的长度为newCap数组，
                //并将元素复制到这个新的数组当中，底层调用的是System.arraycopy native方法
                r = Arrays.copyOf(r, newCap);
            }
            r[i++] = (T)it.next();//数组有效长度自增，并复制引用
        }
        // trim if overallocated 截短数组长度到有效长度
        return (i == r.length) ? r : Arrays.copyOf(r, i);
    }

    /**
     * 判断数组容量是否溢出，最大为整型数据的最大值
     */
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow 超出整型的最大值则数值溢出为负值
            throw new OutOfMemoryError
                ("Required array size too large");
        return (minCapacity > MAX_ARRAY_SIZE) //如果大于最大容量则返回整数的最大值，否则返回集合的最大容量。
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    // Modification Operations
    
	 //未实现的方法
    //子类必须以自己的方式实现这两个方法。除此外，AbstractCollection 中默认不支持添加单个元素，如果直接调用 add(E) 方法，会报错：  因此，如果子类是可添加的数据结构，需要自己实现 add(E) 方法  
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }

    /**
     * 集合允许null元素
     * 功能：移除指定元素
     * （1）如果参数为null，则找到第一个值为null的元素，并将其删除，返回true，如果不存在null的元素，返回false。
     * （2）如果参数不为null，则根据equals方法找到第一个与参数相等的元素，并将其删除，返回true，如果找不到，返回false。
     */
    public boolean remove(Object o) {
        Iterator<E> it = iterator();
        if (o==null) {
            while (it.hasNext()) {
                if (it.next()==null) {
                    it.remove();
                    return true;
                }
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next())) {
                    it.remove();
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * 遍历参数集合，依次判断参数集合中的元素是否在当前集合中，
     * 只要有一个不存在，则返回false
     * 如果参数集合中所有的元素都在当前集合中，则返回true
     */
    public boolean containsAll(Collection<?> c) {
        for (Object e : c)
            if (!contains(e))
                return false;
        return true;
    }

    /**
     * 遍历参数集合，依次将参数集合中的元素添加当前集合中
     */
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }

    /**
     * 功能：移除参数集合的元素
     * （1）获取当前集合的迭代器进行遍历
     * （2）如果当前集合中的元素包含在参数集合中，则删除当前集合中的元素
     *  注：只要参数集合中有任何一个元素在当前元素中，则返回true，表示当前集合有发送变化，否则返回false。
     */
    public boolean removeAll(Collection<?> c) {
        boolean modified = false;
        Iterator<?> it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

    /***
     * 功能：求参数集合与当前集合的交集
     * （1）获取当前集合的迭代器进行遍历
     * （2）如果当前集合中的元素不在参数集合中，则将其移除。
     *  注意：如果当前集合是参数集合中的子集，则返回false，表示当前集合未发送变化，否则返回true。
     */
    public boolean retainAll(Collection<?> c) {
        boolean modified = false;
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            if (!c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

     //删除所有元素
    public void clear() {
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
    }


    public String toString() {
        Iterator<E> it = iterator();
        if (! it.hasNext())
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

}
```  
##### RandomAccess

> 标记接口，Marker interface，它们是一类没有定义任何接口方法的接口，表现为一个空接口 
没有接口方法意味着实现该接口的类无需实现任何接口方法，仅仅作为一种标记，以供其他方法判断 
作用就是当某个类实现这个接口后即拥有了这个接口的功能，Java 虚拟机在运行时会识别到它 
标记接口是Java的语言特性 。  

> 在计算机科学中，随机访问（RandomAccess）是从大量的可寻址元素的数据中访问任何元素大致和访问其他元素一样简洁有效，不管多少元素在这个集合中。与随机访问相反的是顺序访问（SequenceAccess）

RandomAccess 就是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机和顺序访问的List中性能更加高效（在Collections二分查找时）。 
Collections的binarySearch方法：

``` java
public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {
    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}
```
在进行二分查找时，首先判断list是否实现了RandomAccess，然后选择执行最优算法。 
如果集合类是RandomAccess的实现，则尽量用for(int i = 0; i < size; i++) 即for循环来遍历，而不是用Iterator 
迭代器来进行迭代。
> JDK中说的很清楚，在对List特别是Huge size的List的遍历算法中，要尽量来判断是属于RandomAccess(如：ArrayList)还是SequenceAccess(如：LinkedList)

``` java
/**
 * Marker interface used by <tt>List</tt> implementations to indicate that
 * they support fast (generally constant time) random access.  The primary
 * purpose of this interface is to allow generic algorithms to alter their
 * behavior to provide good performance when applied to either random or
 * sequential access lists.
 * List实现所使用的标记接口，用来表明实现了这些接口的list支持快速（通常是常数时间）随机访问。 
 * 这个接口的主要目的是允许一般的算法更改它们的行为，以便在随机或者顺序存取列表时能提供更好的性能
 * <p>The best algorithms for manipulating random access lists (such as
 * <tt>ArrayList</tt>) can produce quadratic behavior when applied to
 * sequential access lists (such as <tt>LinkedList</tt>).  Generic list
 * algorithms are encouraged to check whether the given list is an
 * <tt>instanceof</tt> this interface before applying an algorithm that would
 * provide poor performance if it were applied to a sequential access list,
 * and to alter their behavior if necessary to guarantee acceptable
 * performance.
 * 操作随机访问列表（如ArrayList）的最佳算法在应用于顺序存取列表时，有可能产生二次项行为。
 * 泛型算法列表鼓励在将某个算法应用于顺序存取列表可能导致差的性能之前，先检查给定的列表是
 * 否是这个接口的一个实例，并在需要时去改变这些算法的行为以保证性能。
 * <p>It is recognized that the distinction between random and sequential
 * access is often fuzzy.  For example, some <tt>List</tt> implementations
 * provide asymptotically linear access times if they get huge, but constant
 * access times in practice.  Such a <tt>List</tt> implementation
 * should generally implement this interface.  As a rule of thumb, a
 * <tt>List</tt> implementation should implement this interface if,
 * for typical instances of the class, this loop:
 * 随机访问和顺序存取之间的界限通常是模糊的。例如，一些List实现在变得很大时会导致渐进的非
 * 线性访问时间，但实际上是常量访问时间。这样的List实现通常都应该实现该接口。一般来说，某
 * 个List实现如果（对某些典型的类的实例来说）满足下面的条件，就应该实现这个接口：循环
 * <pre>
 *     for (int i=0, n=list.size(); i < n; i++)
 *         list.get(i);
 * </pre>
 * runs faster than this loop:
 * 比下面的循环运行速度快。
 * <pre>
 *     for (Iterator i=list.iterator(); i.hasNext(); )
 *         i.next();
 * </pre>
 *
 * @since 1.4
 */
public interface RandomAccess {
}
```
<font color=red size=5>__*总结：*__</font>RandomAccess是一个空接口，而空接口的作用一般是起到一个标识的作用。 
通俗点讲，就是判断一个list是否实现了RandomAcess接口，如果实现了，采用简单的for循环进行访问速度比较快。 
如果未实现RandomAcess接口，则采用iterator循环访问速度比较快。 
判断使用instanceof，即```if (list instanceof RandomAccess) ```
###### Cloneable

1 Cloneable的用途
Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。
2 克隆的分类

* 浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，而不拷贝对象包含的引用指向的对象。
* 深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。
举例：对象X中包含对Y的引用，Y中包含对Z的引用。浅拷贝X得到X1，X1中依然包含对Y的引用，Y中依然包含对Z的引用。深拷贝则是对浅拷贝的递归，深拷贝X得到X1，X1中包含对Y1（Y的copy）的引用，Y1中包含对Z1（Z的copy）的引用。

3 克隆代码举例
要让对象可以被克隆，应具备以下2个条件：

* 让该类实现java.lang.Cloneable接口；
* 重写（Override）Object的clone()方法；

``` java
public class Info implements Cloneable {

  private int id;

  private String text;

  public Info(int id, String text) {

    this.id = id;

    this.text = text;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    Info temp = (Info) obj;
    if (id != temp.id) return false;
    if (text == null) {
      if (temp.text != null) {
        return false;
      }
    } else if (!text.equals(temp.text)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}

public static void main(String[] args) throws CloneNotSupportedException {
    Info clone = new Info(1, "I am Mp5A5");
    Info clone1 = (Info) clone.clone();


    System.out.println(clone.getClass() == clone1.getClass()); // true

    System.out.println(clone == clone1); // false

    System.out.println(clone.equals(clone1)); // true
  }
```
4 浅克隆/浅拷贝

``` java
public class MyFile implements Cloneable {

  private String path;

  public Info info;

  public MyFile(String path, Info info) {

    this.path = path;

    this.info = info;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    MyFile temp = (MyFile) obj;
    if (path == null) {
      if (temp.path != null) {
        return false;
      }
    } else if (!path.equals(temp.path)) {
      return false;
    }

    if (info == null) {
      if (temp.info != null) {
        return false;
      }
    } else if (!info.equals(temp.info)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}

public static void main(String[] args) throws CloneNotSupportedException {

    Info info = new Info(2, "Hello world.");

    MyFile file1 = new MyFile("c:", info);

    MyFile file2 = (MyFile) file1.clone();

    System.out.println(file1.getClass() == file2.getClass()); // true

    System.out.println(file1 == file2); // false

    System.out.println(file1.equals(file2)); // true

    System.out.println(file1.info.getClass() == file2.info.getClass()); // true

    System.out.println(file1.info == file2.info); // true

    System.out.println(file1.info.equals(file2.info)); // true
  }

```
5 深克隆/深拷贝
深克隆需要重写（Override）Object类的clone()方法，并且在方法内部调用持有对象的clone方法

``` java
public class MyFile2 implements Cloneable {

  private String path;

  public Info info;

  public MyFile2(String path, Info info) {

    this.path = path;

    this.info = info;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    MyFile2 temp = (MyFile2) obj;
    if (path == null) {
      if (temp.path != null) {
        return false;
      }
    } else if (!path.equals(temp.path)) {
      return false;
    }

    if (info == null) {
      if (temp.info != null) {
        return false;
      }
    } else if (!info.equals(temp.info)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {

    MyFile2 file = (MyFile2) super.clone();
    file.info = (Info) file.info.clone();
    return file;
  }
}

    Info info = new Info(2, "Hello world.");

    MyFile2 file1 = new MyFile2("c:", info);

    MyFile2 file2 = (MyFile2) file1.clone();



    System.out.println(file1.getClass() == file2.getClass());//true

    System.out.println(file1 == file2);//false

    System.out.println(file1.equals(file2));//true

    System.out.println(file1.info.getClass() == file2.info.getClass());//true

    System.out.println(file1.info == file2.info);//false

    System.out.println(file1.info.equals(file2.info));//true
```
##### List

List是一个有序集合(也称为序列)，你可以控制每个元素被插入的位置，和根据索引访问列表中元素。List集合元素可以重复，也可以存入 null 元素。  
List集合是可以根据索引来操纵集合，所以List接口在Collection接口基础增加了一些根据索引操纵集合的接口方法。
![avatar](pic/p83.png)

#### Vector

![avatar](pic/p84.png)

#### Stack

![avatar](pic/p85.png)

#### LinkedList

![avatar](pic/p86.png)

##### AbstractSequentialList

此类提供List接口的骨干实现，以最大限度地减少实现由“顺序访问”数据存储（例如链接列表）支持的此接口所需的工作量。对于随机访问数据（例如数组），应优先使用AbstractList而不是此类。
这个类与AbstractList类相反，它实现了“随机访问”方法（get（int index），set（int index，E element），add（int index，E element）和remove（int index） ））在列表的列表迭代器之上，而不是相反。  
要实现列表，程序员只需要扩展此类并提供listIterator和size方法的实现。对于不可修改的列表，程序员只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。  
对于可修改的列表，程序员还应该实现list迭代器的set方法。对于可变大小的列表，程序员还应该实现列表迭代器的remove和add方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和集合构造函数。  
此类属于Java集合框架

* 非抽象方法：

1.get方法，通过双向迭代器返回集合中元素
``` java
    public E get(int index) {
        try {
            return listIterator(index).next();
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
2.set方法 通过迭代器设置集合中的元素

``` java
    public E set(int index, E element) {
        try {
            ListIterator<E> e = listIterator(index);
            E oldVal = e.next();
            e.set(element);
            return oldVal;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
 3.add方法通过迭代器添加一个元素
 
``` java
    public void add(int index, E element) {
        try {
            listIterator(index).add(element);
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
4.remove方法 通过迭代器将固定位置的元素拿到集合外面

``` java
    public E remove(int index) {
        try {
            ListIterator<E> e = listIterator(index);
            E outCast = e.next();
            e.remove();
            return outCast;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
    
```
5.addAll方法 通过迭代器在固定位置添加一个集合的元素

``` java
    public boolean addAll(int index, Collection<? extends E> c) {
        try {
            boolean modified = false;
            ListIterator<E> e1 = listIterator(index);
            Iterator<? extends E> e2 = c.iterator();
            while (e2.hasNext()) {
                e1.add(e2.next());
                modified = true;
            }
            return modified;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
 ```
 6.Iterator方法 返回的是一个listIterator对象
 
``` java
    public Iterator<E> iterator() {
        return listIterator();
    }
```    
* AbstractSequentialList总结
AbstractSequentialList超类的对集合的增删改查操作都是基于迭代器完成的(包括get方法)。AbstractSequentialList可以这么讲，他是一个按次序访问的线性表的简化版，它是一个超类，他规定了其子类必须去实现ListIterator这个接口。必须用迭代的方式完成对线性表的各项操作。当我们在使用AbstractSequentialList的子类对象时，遍历操作最好是使用迭代器，因为for循环的get也是使用迭代器所以我们不要多此一举再去增加个for循环调用迭代方法了

##### Queue

![avatar](pic/p95.png)

Queue一种队列结构集合,用来存储将要进行处理的元素.通常以FIFO的方式排序元素,但这并不是必须的.比如优先度队列就是一个例外,它是以元素的值来排序.但无论怎样,每个Queue的实现都必须指定它的排序属性.Queue通常不定义元素的equal和hashCode方法.

``` java
public interface Queue<E> extends Collection<E> {

// 向队列中添加一个元素
// 如果添加成功则返回true
// 如果队列容量已满则抛出异常
boolean add(E e);

// 向队列中添加一个元素
// 如果添加成功则返回true
// 如果添加失败则返回false
boolean offer(E e);


// 移除对头元素
// 返回对头元素，如果没有对头元素则抛出异常
// throws NoSuchElementException
E remove();

// 移除对头元素
// 返回对头元素，如果没有对头元素则返回null
E poll();

// 返回对头元素，不会删除对头元素
// 如果没有对头元素则抛出异常
// throws NoSuchElementException
E element();

// 返回对头元素，不会删除对头元素
// 如果队列为空，则返回null
E peek();
```

##### Deque
Deque接口是Queue接口的子接口，代表一个双端队列。同时Deque不仅可以作为双端队列使用，而且可以被当成栈来使用，所以可以使用出栈，入栈的方法。

* 特性：

插入、删除、获取操作支持两种形式：快速失败和返回null或true/false
既具有FIFO特点又具有LIFO特点，即是队列又是栈
不推荐插入null元素，null作为特定返回值表示队列为空
未定义基于元素相等的equals和hashCode

* 源码

``` java
// 将指定元素添加到对头
// 如果没有足够的空间则抛出异常
// throw IllegalArgumentException
void addFirst(E e);



// 将指定元素添加到对头
// 如果添加成功则返回true，如果没有足够的空间则返回false
// 如果是使用容量有限的队列，推荐使用该方法而不是addFirst
boolean offerFirst(E e);


// 将指定元素添加到队尾
// 如果没有足够的空间则抛出异常
// throw IllegalArgumentException
void addLast(E e);

// 添加指定元素到队尾
// 如果添加成功则返回true，如果没有足够空间则返回false
// 如果是使用容量有限的队列，推荐使用该方法而不是addLast
boolean offerLast(E e);

// 移除并返回对头元素
// 如果队列为空，则抛出异常
E removeFirst();

// 移除并返回队尾元素
// 如果队列为空，则抛出异常
E removeLast();

// 移除并返回对头元素
// 如果队列为空则返回null
E pollFirst();

// 移除并返回队尾元素
// 如果队列为空则返回null
E pollLast();

// 查询对头元素
// 如果队列为空，则抛出异常
E getFirst();


// 查询队尾元素
// 如果队列为空，则抛出异常
E getLast();

// 查询对头元素
// 如果队列为空，则返回null
E peekFirst();

// 查询队尾元素
// 如果队列为空，则返回null
E peekLast();

// 移除队列中出现的第一个元素
// 移除成功则返回true，如果队列不包含该元素则返回false
boolean removeFirstOccurrence(Object e);

boolean removeLastOccurrence(Object e);

// 以下是栈方法

void push(E e);

E pop();


// 返回一个逆序的迭代器，从队尾到对头
Iterator<E> descendingIterator();

```

##### ArrayBlockingQueue

[ArrayBlockingQueue的详细介绍及源码分析](https://blog.csdn.net/qq_22798455/article/details/81636772)

##### ConcurrentLinkedQueue

[ConcurrentLinkedQueue的详细介绍及源码分析](https://blog.csdn.net/qq_22798455/article/details/81637397)

##### PriorityQueue

[PriorityQueue的详细介绍及源码分析](https://www.jianshu.com/p/969c1de8ca8c)

#### CopyOnWriteArrayList

![image](pic/p96.png)

1.CopyOnWrite

Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。

2.CopyOnWrite容器
CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

3.实现原理

```
	
	/** 可重入锁对象 */
    final transient ReentrantLock lock = new ReentrantLock();

    /** CopyOnWriteArrayList底层由数组实现，volatile修饰 */
    private transient volatile Object[] array;

    /**
     * 得到数组
     */
    final Object[] getArray() {
        return array;
    }

    /**
     * 设置数组
     */
    final void setArray(Object[] a) {
        array = a;
    }

    /**
     * 初始化CopyOnWriteArrayList相当于初始化数组
     */
    public CopyOnWriteArrayList() {
        setArray(new Object[0]);
    }
```

add方法

在添加元素之前进行加锁操作，保证数据的原子性。在添加过程中，进行数组复制，修改操作，再将新生成的数组复制给集合中的array属性。最后，释放锁；由于array属性被volatile修饰，所以当添加完成后，其他线程就可以立刻查看到被修改的内容。

```
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        //加锁
        lock.lock();
        try {
            //获取集合中的数组：
            Object[] elements = getArray();
            int len = elements.length;
            
            //数组复制：将此线程与其他线程对集合的操作区分开来，无论底层结构如何改变，本线程中的数据不受影响
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            
            //对新的数组进行操作：将新元素添加到新数组中
            newElements[len] = e;
            
            //将原有数组指针指向新的数组对象：
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
}
```

```
public void add(int index, E element) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            if (index > len || index < 0)
                throw new IndexOutOfBoundsException("Index: "+index+
                                                    ", Size: "+len);
            Object[] newElements;
            int numMoved = len - index;
            //len == index 时候先将就数组copy到新数组中，然后将值插入到新数组的末尾
            if (numMoved == 0)
                newElements = Arrays.copyOf(elements, len + 1);
            else {
                //len > index 
				  //先将index之前的数组copy到新数组中
				  //将剩余的元素copy到index+1之后的数组中
                newElements = new Object[len + 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index, newElements, index + 1,
                                 numMoved);
            }
            newElements[index] = element;
            setArray(newElements);
        } finally {
            lock.unlock();
        }
}
```

```

// 插入元素e，先判断当前数组中是否有该元素，有就不插入，没有则调用addIfAbsent(e, snapshot)再做判断
public boolean addIfAbsent(E e) {
    Object[] snapshot = getArray();
    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
        addIfAbsent(e, snapshot);
}

/**
 * 在并发环境中调用addIfAbsent(E e, Object[] snapshot)的时候可能原始数组已经被更改了，所以获取当前数组，然后和传入的数组进行比较操作，然后判断时候需要插入该元素
 */
private boolean addIfAbsent(E e, Object[] snapshot) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
    	 //获取最新数组
        Object[] current = getArray();
        int len = current.length;
        //如果最新数组和传入的数组不相同，说明原始数组已经被更改了
        if (snapshot != current) {
            // 获取更改前和更改后最小的数组长度
            int common = Math.min(snapshot.length, len);
            for (int i = 0; i < common; i++)
            
            	   //更改后数组的元素和初始数组的元素不相同，并且需要插入的元素和当前数组的某个元素相同，则不用插入，这个循环只能判断当前数组是被删减的情况
                if (current[i] != snapshot[i] && eq(e, current[i]))
                    return false;
            //这个是判断当前数组是被添加的情况    
            if (indexOf(e, current, common, len) >= 0)
                return false;
        }
        Object[] newElements = Arrays.copyOf(current, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

size方法

```
public int size() {
    return getArray().length;
}
```

get方法

```
//根据角标，获取对应的数组元素:
public E get(int index) {
    return get(getArray(), index);
}
@SuppressWarnings("unchecked")
private E get(Object[] a, int index) {
    return (E) a[index];
}
```

为了能让get（）方法得到最大的性能，CopyOnWriteArrayList并没有进行加锁处理，而且也不需要加锁处理。
因为，在add（）时候加了锁，首先不会有多个线程同时进到add中去，这一点保证了数组的安全。当在一个线程执行add时，又进行了数组的复制操作，生成了一个新的数组对象，在add后又将新数组对象的指针指向了旧的数组对象指针，注意此时是指针的替换，原来旧的数组对象还存在。这样就实现了，添加方法无论如何操作数组对象，获取方法在获取到集合后，都不会受到其他线程添加元素的影响。
这也就是在执行add()时，为什么还要在加锁的同时又copy了一分新的数组对象！！！

set方法

```
public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
    	 //// 得到原数组的旧值
        Object[] elements = getArray();
        E oldValue = get(elements, index);
		 
		 // 判断新值和旧值是否相等
        if (oldValue != element) {
        	
        	  // 复制新数组，新值在新数组中完成
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len);
            newElements[index] = element;
            setArray(newElements);
        } else {
            // 将array引用指向新数组
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

remove方法

```
public boolean remove(Object o) {
    Object[] snapshot = getArray();
    int index = indexOf(o, snapshot, 0, snapshot.length);
    return (index < 0) ? false : remove(o, snapshot, index);
}

private boolean remove(Object o, Object[] snapshot, int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
    	 //获取当前数组
        Object[] current = getArray();
        int len = current.length;
        //当前数组是否已经更改
        if (snapshot != current) findIndex: {
        	  //已经更改的数组通过循环判断要删除的元素是否在当前数组中，这里使用了goto跳出循环机制
        	  //判断当前数组已经删除元素的情况
            int prefix = Math.min(index, len);
            for (int i = 0; i < prefix; i++) {
                if (current[i] != snapshot[i] && eq(o, current[i])) {
                    index = i;
                    break findIndex;
                }
            }
            if (index >= len)
                return false;
            if (current[index] == o)
                break findIndex;
            //判断当前数组已经增加元素的情况
            index = indexOf(o, current, index, len);
            if (index < 0)
                return false;
        }
        Object[] newElements = new Object[len - 1];
        System.arraycopy(current, 0, newElements, 0, index);
        System.arraycopy(current, index + 1,
                         newElements, index,
                         len - index - 1);
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

迭代器

```
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}

public ListIterator<E> listIterator() {
    return new COWIterator<E>(getArray(), 0);
}

static final class COWIterator<E> implements ListIterator<E> {

private int cursor;

private COWIterator(Object[] elements, int initialCursor) {
    cursor = initialCursor;
    snapshot = elements;
}

public boolean hasNext() {
    return cursor < snapshot.length;
}

public boolean hasPrevious() {
    return cursor > 0;
}

@SuppressWarnings("unchecked")
public E next() {
    if (! hasNext())
        throw new NoSuchElementException();
    return (E) snapshot[cursor++];
}

@SuppressWarnings("unchecked")
public E previous() {
    if (! hasPrevious())
        throw new NoSuchElementException();
    return (E) snapshot[--cursor];
}

public int nextIndex() {
    return cursor;
}

public int previousIndex() {
    return cursor-1;
}
```

![image](pic/p103.png)

总结：

* 在修改时，复制出一个新数组，修改的操作在新数组中完成，最后将新数组交由array变量指向。
* 写加锁，读不加锁
* 在使用迭代器遍历的时候，操作的都是原数组


优缺点

* CopyOnWriteArrayList保证了数据在多线程操作时的最终一致性。
* 缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；
* 只能保证最终的数据一致性，而不能保证实时的数据一致性。这一点也是我们在使用的过程中，必须要考虑到的因素。

CopyOnWrite的应用场景
CopyOnWrite并发容器用于读多写少的并发场景。
比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。
这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。

#### EnumSet

![avatar](pic/p104.png )

##### EnumSet

EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或隐式地指定。

1. EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。
2. EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效,因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll()和retainAll()方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。
3. EnumSet集合不允许加入null元素，如果试图插入null元素，EnumSet将抛出NullPointerException异常。
4. EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的类方法来创建EnumSet对象。
5. 如果只是想判断EnumSet是否包含null元素或试图删除null元素都不会抛出异常，只是删除操作将返回false，因为没有任何null元素被删除。

方法介绍：

* EnumSet allOf(Class elementType): 创建一个包含指定枚举类里所有枚举值的EnumSet集合。
* EnumSet complementOf(EnumSet e): 创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。
* EnumSet copyOf(Collection c): 使用一个普通集合来创建EnumSet集合。
* EnumSet copyOf(EnumSet e): 创建一个指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。
* EnumSet noneOf(Class elementType): 创建一个元素类型为指定枚举类型的空EnumSet。
* EnumSet of(E first,E…rest): 创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。
* EnumSet range(E from,E to): 创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。

源码：

```

public static <E extends Enum<E>> EnumSet<E> of(E e) {
    EnumSet<E> result = noneOf(e.getDeclaringClass());
    result.add(e);
    return result;
}

public final Class<E> getDeclaringClass() {
    Class<?> clazz = getClass();
    Class<?> zuper = clazz.getSuperclass();
    return (zuper == Enum.class) ? (Class<E>)clazz : (Class<E>)zuper;
}

//根据数组长度，小于等于64则返回RegularEnumSet，否则JumboEnumSet
RegularEnumSet是EnumSet的子类，RegularEnumSet的构造函数中会调用EnumSet的构造函数，将枚举类型、枚举数组保存起来,从而返回一个空EnumSet集合
final Class<E> elementType;

final Enum<?>[] universe;
 
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
    Enum<?>[] universe = getUniverse(elementType);
    if (universe == null)
        throw new ClassCastException(elementType + " not an enum");

    if (universe.length <= 64)
        return new RegularEnumSet<>(elementType, universe);
    else
        return new JumboEnumSet<>(elementType, universe);
}

private static <E extends Enum<E>> E[] getUniverse(Class<E> elementType) {
    return SharedSecrets.getJavaLangAccess()
                                    .getEnumConstantsShared(elementType);
}
```

为什么要定义getDeclaringClass，而不直接使用getClass呢？
先看如下例子：
public enum MyEnum {

   A {
       void doSomething() { ... }
   },


   B {
       void doSomethingElse() { ... }
   };}

现象：MyEnum.A.getClass()和MyEnum.A.getDeclaringClass()是不一样的。
原因：Java enum values are permitted to have value-specific class bodies（Java枚举值允许有特定于值的类主体），这将生成表示A和B的类主体的内部类。这些内部类将是MyEnum的子类。因此MyEnum.A.getClass()返回的是类A(A's class body)的匿名类，而MyEnum.A.getDeclaringClass()会返回MyEnum。
结论：如果是简单的枚举（without constant-specific class bodies），这2种方法返回的结果是一样的，但如果枚举包含constant-specific class bodies，就会出现不一致。因此对枚举类进行比较的时候，使用getDeclaringClass是万无一失的

[参考资料](https://stackoverflow.com/questions/5758660/java-enum-getdeclaringclass-vs-getclass)

SharedSecrets和JavaLangAccess的作用
我们需要知道JVM里面的实例对象的时候，我们就需要使用到SharedSecrets和JavaLangAccess，通过这两个类来获取Java栈帧中存储的类信息，然后进行挑选，从而找出调用的类。

接下来看一下SharedSecrets和JavaLangAccess的使用方式：

```
public enum MyEnum {
  A {
    void doSomething() {
      System.out.println("a");
    }
  },

  B {
    void doSomethingElse() {
      System.out.println("B");
    }
  },
  C;
}

public static void main(String[] args) {

    JavaLangAccess access = SharedSecrets.getJavaLangAccess();

    Throwable throwable = new Throwable();

    int depth = access.getStackTraceDepth(throwable);

    for (int i = 0; i < depth; i++) {
      StackTraceElement element = access.getStackTraceElement(throwable, i);
      System.out.println(element);
    }

    EnumSet<MyEnum> myEnums = EnumSet.noneOf(MyEnum.class);
    System.out.println(myEnums);
    for (MyEnum myEnum : myEnums) {
      System.out.println(myEnum);
    }

    MyEnum[] enums = access.getEnumConstantsShared(MyEnum.class);

    for (int i = 0; i < enums.length; i++) {
      System.out.println(enums[i]);
    }
    
    
  }
```

结果：

```
A
B
C
enumset.Test.main(Test.java:16)
[]
```

##### RegularEnumSet

```
/**
 * Private implementation class for EnumSet, for "regular sized" enum types
 * (i.e., those with 64 or fewer enum constants).
 */
class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {
    // 使用位向量保存
    private long elements = 0L;
    // 构造方法也是调用抽象类的构造方法来实现
    RegularEnumSet(Class<E>elementType, Enum<?>[] universe) {
        super(elementType, universe);
    }
}
```

>RegularEnumSet是枚举类型的私有实现类，我们无法直接调用，我们只能使用EnumSet，而EnumSet则会根据length相应的调用RegularEnumSet实现类；
>RegularEnumSet保存数据和常规的Set不同，RegularEnumSet中只有一个long类型的elements变量，这是因为保存的时候保存的并不是实际的元素，而是保存的是bit，0和1；

1.源码

add方法

```
/**
 * 如果元素不存在，添加
 */
public boolean add(E e) {
    // 校验枚举类型
    typeCheck(e);

    long oldElements = elements;
    elements |= (1L << ((Enum<?>)e).ordinal());
    return elements != oldElements;
}

/**
 * 用于校验枚举类型，位于EnumSet中
 */
final void typeCheck(E e) {
    Class<?> eClass = e.getClass();
    if (eClass != elementType && eClass.getSuperclass() != elementType)
        throw new ClassCastException(eClass + " != " + elementType);
}
```

首先，每一个枚举元素都有一个属性ordinal，用来表示该元素在枚举类型中的次序或者说下标。

![image](pic/p105.png)

add之后，elements二进制对应的ordinal位设置为了1。其实，add操作就是设置long类型的elements对应下标位置的值是0或者是1，也就是将每一个枚举元素在elements的二进制中占用一位。因为long是64位，所以RegularEnumSet的长度自然是不能大于64的。
判断元素是否添加成功，直接通过判断添加前后elements的值有没有变化来判断。

size方法

```
//统计long类型二进制中1的个数
public int size() {
    return Long.bitCount(elements);
}
```

addAll方法

```
void addAll() {
    if (universe.length != 0)
        elements = -1L >>> -universe.length;
}
```

位移负值运算

众所周知，Java的移位运算符有三个：<<、>>和>>>，第一个是左移，后两个分别是带符号右移和无符号右移，那么移位运算符的右边竟然是一个负数，到底什么意思呢？百度一下无果，于是想到了Oracle官方的JAVA语言规范[^java]，翻了一下，官方文档对移位运算规定的清清楚楚，其描述是这样的：

>If the promoted type of the left-hand operand is int, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator & with the mask value 0x1f (0b11111). The shift distance actually used is therefore always in the range 0 to 31, inclusive.  

> If the promoted type of the left-hand operand is long, then only the six lowest- order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator & with the mask value 0x3f (0b111111). The shift distance actually used is therefore always in the range 0 to 63, inclusive.

大意就是移位操作符左边如果是int类型，则操作符右边的数只有低5位有效（右边的数会首先与0x1f做AND运算），如果操作符左边是long类型，右边的数就只取低6位为有效位。

左边是一个long类型，-1L的补码表示是0xffffffffffffffff(1111...1111共64位)，并且>>>是无符号右移，在右移的时候最高位补0；"-mL"(L=Long)其实只有低6位有效，举个例子来说吧，假设m为5，那么-5在内存中的表示为0xfffffffb(1111...1011)，取低6位(111011)有效，那么实际有效值是0x3b，换成十进制就是59，也就是把-1L右移59位，可见，表达式的结果正好是低5位全1，高位全0。

更一般地，<font color=red > 当n处在[1..64]之间时，（-1L >>> -n）的结果应该是低n位全1，高位全0。</font>

addRange方法

```
void addRange(E from, E to) {
    elements = (-1L >>>  (from.ordinal() - to.ordinal() - 1)) << from.ordinal();
}
```

该方法是添加枚举中某一段范围内的元素。这个方法同样设计的也很精巧，先右无符号位移，将最低位置为1，然后左移对应的位置即可。

complement方法

```
void complement() {
    if (universe.length != 0) {
        elements = ~elements;
        elements &= -1L >>> -universe.length;  // Mask unused bits
    }
}
```

这个方法其实和上面类似，只不过多了一步按位非的操作。
其他方法其实都是和上面这几个方法大差不差，只要明白了位运算，基本上这些方法都可以很快理解的。

EnumSetIterator的next方法

```
private class EnumSetIterator<E extends Enum<E>> implements Iterator<E> {
    /**
     *  elements的值
     */
    long unseen;

    /**
     * elements二进制对应的1的位置
     */
    long lastReturned = 0;

    EnumSetIterator() {
        unseen = elements;
    }

    public boolean hasNext() {
        return unseen != 0;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        if (unseen == 0)
            throw new NoSuchElementException();
        lastReturned = unseen & -unseen;
        unseen -= lastReturned;
        return (E) universe[Long.numberOfTrailingZeros(lastReturned)];
    }

    public void remove() {
        if (lastReturned == 0)
            throw new IllegalStateException();
        elements &= ~lastReturned;
        lastReturned = 0;
    }
}
```

>首先，lastReturned = unseen & -unseen; 计算的是unseen的二进制最低位第一个非0位代表的十进制数。如果unseen是0111，那返回的就是0001，十进制是1，如果unseen是0100，那返回的就是0100，十进制是4。

> 而 Long.numberOfTrailingZeros(lastReturned) 计算的是lastReturned从最低位开始，第一位为1的下标值（或者换一种说法，就是从最低位开始，到第一位为1这中间0的个数）。比如lastReturned是4，二进制是0100，那这里返回的就是2；如果lastReturned是0101，那这里返回的就是0。

leetcode中有一个算法就是计算尾部的零的个数（Trailing Zeros）。

总结
其实RegularEnumSet中进行的操作就是围绕长整型elements的二进制位上的1和0进行的。添加元素，设置为1，删除元素，设置为0，清空，直接将该长整型置为0。

##### JumboEnumSet概述

当枚举元素的个数超过了64之后，就将使用JumboEnumSet来进行操作。其实JumboEnumSet中大部分操作和RegularEnumSet都差不多，有一点不太一样的就是JumboEnumSet里的elements是个long类型的数组。

```
private long elements[];
```

所以，JumboEnumSet中有一步操作就是定位到数组中对应的long元素上。

构造方法

```
JumboEnumSet(Class<E>elementType, Enum<?>[] universe) {
    super(elementType, universe);
    elements = new long[(universe.length + 63) >>> 6];
}
```

这里 new long[(universe.length + 63) >>> 6];，无符号右移可以大致认为除以64，计算的就是数组的容量。


addAll方法

```
void addAll() {
    for (int i = 0; i < elements.length; i++)
        elements[i] = -1;
    elements[elements.length - 1] >>>= -universe.length;
    size = universe.length;
}
```

这里处理的很巧妙。首先，循环设置数组里的long是-1，-1的二进制是1111....1111，所以 elements[elements.length - 1] >>>= -universe.length; 这一步，就是计算long数组中最后一个long元素二进制位上的1和0；

> 比如说，枚举元素是68个，那么elements数组的第一个long元素已经在循环的时候设置为了-1，也就是1111....1111，进行这一步进行的就是将第二个long元素进行位移运算，结果为0000....0000 1111。

##### AbstractSet

```
此类提供Set接口的骨干实现，以最大限度地减少实现此接口所需的工作量。
通过扩展此类来实现集合的过程与通过扩展AbstractCollection实现集合的过程相同，除了此类的子类中的所有方法和构造函数必须遵守Set接口强加的其他约束（例如， add方法不允许允许将多个对象实例添加到集合中。
请注意，此类不会覆盖AbstractCollection类中的任何实现。 它只是添加了equals和hashCode的实现。
此类是Java集合框架的成员。
```

```
public abstract class AbstractSet<E> extends AbstractCollection<E> implements Set<E> {
    /**
	  *唯一构造函数
     */
    protected AbstractSet() {
    }

   
    public boolean equals(Object o) {
        if (o == this)
            return true;

        if (!(o instanceof Set))
            return false;
        Collection<?> c = (Collection<?>) o;
        if (c.size() != size())
            return false;
        try {
            return containsAll(c);
        } catch (ClassCastException unused)   {
            return false;
        } catch (NullPointerException unused) {
            return false;
        }
    }

    
    public int hashCode() {
        int h = 0;
        Iterator<E> i = iterator();
        while (i.hasNext()) {
            E obj = i.next();
            if (obj != null)
                h += obj.hashCode();
        }
        return h;
    }

    
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        boolean modified = false;

        if (size() > c.size()) {
            for (Iterator<?> i = c.iterator(); i.hasNext(); )
                modified |= remove(i.next());
        } else {
            for (Iterator<?> i = iterator(); i.hasNext(); ) {
                if (c.contains(i.next())) {
                    i.remove();
                    modified = true;
                }
            }
        }
        return modified;
    }

}
```

#### TreeSet

![avatar](pic/p108.png )

##### SortedSet和SortedMap

这两个接口提供排序操作，实现他们的子类都具有接口中定义的功能。Set和Map本身不具备排序功能，提供了SortedMap和SortedSet接口之后可以在提供排序方案的同时，增加更多的获取集合特定位置元素的方法。类似：集合的第一个元素，最后一个元素，位于特定元素之间的元素等。

1.SortedSet接口

```
public interface SortedSet<E> extends Set<E> {
    
    //自己定义比较器，对内部元素排序
    Comparator<? super E> comparator();

    //fromElement和toElement之间的元素
    SortedSet<E> subSet(E fromElement, E toElement);

    //toElement之前的元素，不包括toElement
    SortedSet<E> headSet(E toElement);

    //fromElement之后的元素，不包括fromElement
    SortedSet<E> tailSet(E fromElement);

    //第一个元素
    E first();

    //最后一个元素
    E last();

    //Java8新增，生成Spliterator接口，有点类似nio里的selector
    @Override
    default Spliterator<E> spliterator() {
        return new Spliterators.IteratorSpliterator<E>(
                this, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) {
            @Override
            public Comparator<? super E> getComparator() {
                return SortedSet.this.comparator();
            }
        };
    }
}

```

2.SortedMap 接口

```
public interface SortedMap<K,V> extends Map<K,V> {
    
    //比价器，用于Map排序
    Comparator<? super K> comparator();

    //formKey,toKey之间的键值对
    SortedMap<K,V> subMap(K fromKey, K toKey);

    //toKey之前的键值对
    SortedMap<K,V> headMap(K toKey);

    //formKey之后的键值对
    SortedMap<K,V> tailMap(K fromKey);

    //第一个key
    K firstKey();

    //最后一个key
    K lastKey();

    //获取key的Set集合
    Set<K> keySet();

    //集合所有的values
    Collection<V> values();

    //Map中的entrySet集合
    Set<Map.Entry<K, V>> entrySet();
}
```

##### NavigableSet和NavigableMap

提供了针对给定搜索目标返回最接近匹配项的导航方法。
SortedMap和SortedSet接口两个接口jdk1.2就已经提供，扩展的NavigableMap与NavigableSet接口jdk1.6才开始支持。

1.NavigableSet接口

```
public interface NavigableSet<E> extends SortedSet<E>
```

所有已知实现类：
ConcurrentSkipListSet, TreeSet

NavigableSet扩展了 SortedSet，具有了为给定搜索目标返回最接近匹配项的导航方法。方法 lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。

所有这些方法是为查找条目而不是遍历条目而设计的。

```
public interface NavigableSet<E> extends SortedSet<E> {
    
    //返回此set中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。
    E lower(E e);

    //返回此set中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。
    E floor(E e);

    //返回 set中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。
    E ceiling(E e);

    //返回此set中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。
    E higher(E e);

    //获取并移除第一个（最低）元素；如果此set为空，则返回 null。
    E pollFirst();

    // 获取并移除最后一个（最高）元素；如果此set为空，则返回 null。
    E pollLast();

    //以升序返回在此set的元素上进行迭代的迭代器。
    Iterator<E> iterator();

    //返回此set中所包含元素的逆序视图。
    NavigableSet<E> descendingSet();

    // 以降序返回在此set的元素上进行迭代的迭代器。
    Iterator<E> descendingIterator();

    //返回此set的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。
    NavigableSet<E> headSet(E toElement, boolean inclusive);

    //返回此set的部分视图，其元素严格小于toElement。
    SortedSet<E> headSet(E toElement);
    
    //返回此set的部分视图，其元素范围从fromElement到toElement。
    NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
                           E toElement,   boolean toInclusive);

	 // 返回 set的部分视图，其元素从fromElement（包括）到toElement（不包括）。
    SortedSet<E> subSet(E fromElement, E toElement);
	 
    //返回此set的部分视图，其元素大于等于fromElement。
    SortedSet<E> tailSet(E fromElement);
    
    //返回set的部分视图，其元素大于（或等于，如果inclusive为true）fromElement。
    NavigableSet<E> tailSet(E fromElement, boolean inclusive);
}
```

2.NavigableMap接口

```
public interface NavigableMap<K,V> extends SortedMap<K,V>
```

所有已知实现类：
ConcurrentSkipListMap, TreeMap

NavigableMap扩展了SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法。方法lowerEntry、floorEntry、ceilingEntry 和 higherEntry 分别返回与小于、小于等于、大于等于、大于给定键的键关联Map.Entry对象，如果不存在这样的键，则返回null。类似地，方法 lowerKey、floorKey、ceilingKey 和 higherKey只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的。

可以按照键的升序或降序访问和遍历 NavigableMap。descendingMap方法返回映射的一个视图，该视图表示的所有关系方法和方向方法都是逆向的。升序操作和视图的性能很可能比降序操作和视图的性能要好。subMap、headMap 和 tailMap 方法与名称相似的SortedMap 方法的不同之处在于：可以接受用于描述是否包括（或不包括）下边界和上边界的附加参数。任何NavigableMap的Subma 必须实现NavigableMap接口。

此接口还定义了firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回null。

subMap(K, K)、headMap(K) 和tailMap(K) 方法被指定为返回SortedMap，以允许现有SortedMap实现能相容地改进为实现 NavigableMap，但鼓励此接口的扩展和实现重写这些方法以返回NavigableMap。类似地，可以重写SortedMap.keySet() 以返回NavigableSet。

```
public interface NavigableMap<K,V> extends SortedMap<K,V> {

    //返回一个键-值映射关系，它与严格小于给定键的最大键关联；如果不存在这样的键，则返回null。
    Map.Entry<K,V> lowerEntry(K key);

    //返回严格小于给定键的最大键；如果不存在这样的键，则返回null。
    K lowerKey(K key);

    //返回一个键-值映射关系，它与小于等于给定键的最大键关联；如果不存在这样的键，则返回null。
    Map.Entry<K,V> floorEntry(K key);

    //返回小于等于给定键的最大键；如果不存在这样的键，则返回null。
    K floorKey(K key);

    //返回一个键-值映射关系，它与大于等于给定键的最小键关联；如果不存在这样的键，则返回null。
    Map.Entry<K,V> ceilingEntry(K key);

    //返回大于等于给定键的最小键；如果不存在这样的键，则返回null。
    K ceilingKey(K key);

    //返回一个键-值映射关系，它与严格大于给定键的最小键关联；如果不存在这样的键，则返回null。
    Map.Entry<K,V> higherEntry(K key);

    //返回严格大于给定键的最小键；如果不存在这样的键，则返回null。
    K higherKey(K key);

    //返回一个与此映射中的最小键关联的键-值映射关系；如果映射为空，则返回null。
    Map.Entry<K,V> firstEntry();

    //返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回null。
    Map.Entry<K,V> lastEntry();

    //移除并返回与此映射中的最小键关联的键-值映射关系；如果映射为空，则返回null
    Map.Entry<K,V> pollFirstEntry();

    //移除并返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null
    Map.Entry<K,V> pollLastEntry();

    //返回此映射中所包含映射关系的逆序视图
    NavigableMap<K,V> descendingMap();

    //返回此映射中所包含键的 NavigableSet视图
    NavigableSet<K> navigableKeySet();

    //返回此映射中所包含键的逆序 NavigableSet视图
    NavigableSet<K> descendingKeySet();

    //返回此映射的部分视图，其键的范围从fromKey到toKey。
    NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
                             K toKey,   boolean toInclusive);
	 //返回此映射的部分视图，其键值的范围从fromKey（包括）到toKey（不包括）
    SortedMap<K,V> subMap(K fromKey, K toKey);

    //返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey
    NavigableMap<K,V> headMap(K toKey, boolean inclusive);

	 //返回此映射的部分视图，其键值严格小于toKey
    SortedMap<K,V> headMap(K toKey);

    //返回此映射的部分视图，其键的范围从 fromKey到toKey。
    NavigableMap<K,V> tailMap(K fromKey, boolean inclusive);

    //返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）
    SortedMap<K,V> tailMap(K fromKey);
}
```

#### HashSet
![image](pic/p110.png )

#### LinkedHashSet
![image](pic/p111.png )

#### LinkedBlockingQueue
![image](pic/p112.png )

#### ConcurrentLinkedQueue
![image](pic/p113.png )

#### HashMap
![image](pic/p114.png )

##### Map

1.介绍

>是一个将键映射到值的对象。map不能包含重复的键;每个键最多可以映射一个值。
这个接口取代了Dictionary类，它是一个完全抽象的类而不是接口。

>Map接口提供了三个集合视图，允许将映射的内容视为一组键，值集合或键值映射集。map的顺序定义为map集合视图上的迭代器返回其元素的顺序。一些map实现，比如TreeMap类，对它们的顺序做出了特定的保证;其他类，比如HashMap类，没有。

>注意：如果将可变对象用作映射键，则必须要非常小心。如果对象的值以equals比较的方式发生改变，而对象是映射中的键，则不指定映射行为。这种禁止的一个特殊情况是，不允许Map将自己作为一个键来包含。虽然允许映射将自身包含为值，但建议特别小心：Equals和HashCode方法在此类映射上不再得到很好的定义。

>所有通用映射实现类都应该提供两个"标准"构造函数：一个void（无参数）构造函数，它创建一个空映射，一个构造函数具有一个类型为Map的参数，它创建一个具有相同键值的新映射映射作为其论点。实际上，后一个构造函数允许用户复制任何Map，从而生成所需类的等效Map。无法强制执行此建议（因为接口不能包含构造函数），但JDK中的所有通用映射实现都符合要求。

>如果此映射不支持该操作，则此接口中包含的“破坏性”方法（即修改它们操作的映射的方法）抛出UnsupportedOperationException。如果是这种情况，则调用对map没有影响，这些方法可能（但不是必须）抛出UnsupportedOperationException。例如，如果要映射“映射”的映射为空，则在不可修改的映射上调用putAll（Map）方法可能（但不是必须）抛出异常。

>某些Map的实现对它们的键和值有限制的方法。例如，某些实现禁止空键和值，有些实现对其键的类型限制。尝试插入不合规的键或值会引发未经检查的异常，通常是NullPointerException或ClassCastException。尝试查询不合规的键或值可能会引发异常，或者它可能只是返回false;一些实现将展示前一种行为，一些将展示后者。通俗的说，如果尝试对不合规的键或值执行操作，该操作不会导致将不合格的元素插入到映射中，但可能会引发异常，或者根据实现的不同，可能会成功。此类异常在该接口的规范中标记为“可选”。

>集合框架接口中的许多方法都是根据equals方法定义的。例如，containsKey（Object key）方法的规范说：“当且仅当此映射包含key的映射时才返回true（key == null？k == null：key.equals（k） ）“。不应将此规范解释为使用非空参数键调用Map.containsKey将导致为任何键key调用key.equals（k）。可以自由地实现优化，从而避免等于调用，例如，通过首先比较两个key的哈希值。 （Object.hashCode（）规范保证具有不相同哈希码的两个对象不能相等。）一般的，各种集合框架接口的实现可以自由地利用底层Object方法的指定行为，只要实现者认为它是合适的。

>执行映射递归遍历的某些映射操作可能会失败，并且映射直接或间接包含自身的自引用实例会例外。这包括clone（），equals（），hashCode（）和toString（）方法。实现方法可以可选地处理自引用场景，但是大多数不这样做。

```

/**
 *Map将key映射到value(存储键值对);
 *一个map不能存在重复的key;
 *一个key最多可以映射到1个value;
 *这个接口用来替换Dictionary抽象类;
 */
public interface Map<K,V> {

    // Query Operations

    //容量大小
    int size();

    //是否为空
    boolean isEmpty();

    //是否包含该key
    boolean containsKey(Object key);

    //是否包含该value
    boolean containsValue(Object value);

    // 按照指定键获得相对应的值;
    // 如果不能存在指定键值对则返回null;
    V get(Object key);

    // Modification Operations

    //添加指定键值对
    V put(K key, V value);

    // 移除指定键值对;
    // 返回移除前key对应的value;
    V remove(Object key);


    // Bulk Operations

    //将整个Map对象m存入到原Map中
    void putAll(Map<? extends K, ? extends V> m);

    //清除所有键值对
    void clear();


    // Views

    // 返回Map中所有key的视图
    Set<K> keySet();

    // 返回Map中所有value的视图
    Collection<V> values();

    // 返回Map中所有的Entry的视图,也即key-value的视图
    Set<Map.Entry<K, V>> entrySet();

    
    interface Entry<K,V> {
        
        K getKey();


        V getValue();

        
        V setValue(V value);

        
        boolean equals(Object o);

        
        int hashCode();

        
        public static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K,V>> comparingByKey() {
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> c1.getKey().compareTo(c2.getKey());
        }

       
        public static <K, V extends Comparable<? super V>> Comparator<Map.Entry<K,V>> comparingByValue() {
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> c1.getValue().compareTo(c2.getValue());
        }

        
        public static <K, V> Comparator<Map.Entry<K, V>> comparingByKey(Comparator<? super K> cmp) {
            Objects.requireNonNull(cmp);
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> cmp.compare(c1.getKey(), c2.getKey());
        }

        
        public static <K, V> Comparator<Map.Entry<K, V>> comparingByValue(Comparator<? super V> cmp) {
            Objects.requireNonNull(cmp);
            return (Comparator<Map.Entry<K, V>> & Serializable)
                (c1, c2) -> cmp.compare(c1.getValue(), c2.getValue());
        }
    }

    // Comparison and hashing

    
    boolean equals(Object o);

    int hashCode();

    // Defaultable methods
	
	 //返回键对应的值，如果键不存在则返回默认值defaultValue
    default V getOrDefault(Object key, V defaultValue) {
        V v;
        return (((v = get(key)) != null) || containsKey(key))
            ? v
            : defaultValue;
    }

   	 //对map发生forEach操作时，将遍历每个key和value值，并执行指定的操作，直到遍历所有元素或者发生异常为止
    default void forEach(BiConsumer<? super K, ? super V> action) {
        Objects.requireNonNull(action);
        for (Map.Entry<K, V> entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            action.accept(k, v);
        }
    }

    //将每个条目的值替换为在该条目上调用给定函数的结果，直到所有条目都已处理或函数抛出异常。 函数抛出的异常将抛出给调用者。
    default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
        Objects.requireNonNull(function);
        for (Map.Entry<K, V> entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }

            // ise thrown from function is not a cme.
            v = function.apply(k, v);

            try {
                entry.setValue(v);
            } catch(IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
        }
    }

    //如果key已经对应了一个value，则直接返回，否则将key-value键值对放入map
    default V putIfAbsent(K key, V value) {
        V v = get(key);
        if (v == null) {
            v = put(key, value);
        }

        return v;
    }

    //移除元素，先根据key获取curValue，如果curValue和value不相等或者value为空并且key不在map集合中，则说明要移除的元素不存在，直接返回false，否则移除元素并返回true
    default boolean remove(Object key, Object value) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, value) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }

    //更新元素，先根据key获取curValue，如果curValue和oldValue不相等或者curValue为空并且key不在map集合中，则说明要更新的元素不存在，直接返回false，否则将newValue放入并返回true
    default boolean replace(K key, V oldValue, V newValue) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        put(key, newValue);
        return true;
    }

    //更新元素，先根据key获取curValue，如果curValue不为空，或key在map元素中，则将value放入map集合并返回
    default V replace(K key, V value) {
        V curValue;
        if (((curValue = get(key)) != null) || containsKey(key)) {
            curValue = put(key, value);
        }
        return curValue;
    }

    
    default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }

        return v;
    }

    //根据key获取map中的value，如果不为空，则返回，若为空，则根据key调用mappingFunction.apply()获取mValue，如果mValue不为空，则将此mValue放入map集合并返回mValue;
    default V computeIfPresent(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue;
        if ((oldValue = get(key)) != null) {
            V newValue = remappingFunction.apply(key, oldValue);
            if (newValue != null) {
                put(key, newValue);
                return newValue;
            } else {
                remove(key);
                return null;
            }
        } else {
            return null;
        }
    }

    //根据key获取oldValue，根据key和oldValue调用remappingFunction.apply()方法获取newValue，如果newValue不为空则直接将newValue放入key映射的value并返回value，否则移除oldValue并返回空。
    default V compute(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue = get(key);

        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue == null) {
            // delete mapping
            if (oldValue != null || containsKey(key)) {
                // something to remove
                remove(key);
                return null;
            } else {
                // nothing to do. Leave things as they were.
                return null;
            }
        } else {
            // add or replace old mapping
            put(key, newValue);
            return newValue;
        }
    }

    //根据key获取oldValue，如果oldValue为空，则将value的值给newValue，否则根据key和oldValue调用remappingFunction.apply()方法获取newValue，如果newValue为空，则将key移除map集合并返回null，否则将newValue放入key映射的value，并返回value
    default V merge(K key, V value,
            BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                   remappingFunction.apply(oldValue, value);
        if(newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
}
```

##### AbstractMap

此类提供Map接口的骨干实现，以最大限度地减少实现此接口所需的工作量。  
要实现不可修改的Map，只需要继承此类实现entrySet方法，该方法返回set-view映射。通常，返回的Set是AbstractSet。此set不应支持add或remove方法，并且其迭代器不应支持remove方法。  
要实现可修改的映射，必须覆盖此类的put方法（抛出UnsupportedOperationException），以及迭代器返回的迭代器entrySet（）. iterator（）必须实现其remove方法。    
程序员通常应该根据Map接口规范中的建议提供void（无参数）和map构造函数。  
此类中每个非抽象方法的文档详细描述了它的实现。如果正在执行的map有效的措施，则可以覆盖这些方法中的每一个。

1.循环迭代判断获取值类型

```
//是否包含value值
public boolean containsValue(Object value) {
	 //获取Set的迭代器
    Iterator<Entry<K,V>> i = entrySet().iterator();
    //如果value为null，通过循环判断是否有value为null
    //如果value不为null，通过循环判断是否有和value相同的值
    if (value==null) {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (e.getValue()==null)
                return true;
        }
    } else {
        while (i.hasNext()) {
            Entry<K,V> e = i.next();
            if (value.equals(e.getValue()))
                return true;
        }
    }
    return false;
}
```

类似的还有containsKey(Object key)、get(Object key)等很多方法，逻辑都与containsValue类似，都是通过Iteration迭代器遍历Entry数组，如果符合条件，则进行相应操作并返回操作结果；AbstractMap.put(k, v)方法总是抛出不支持此类操作异常，需要其子类重载此方法。

2.获取key或value的集合

```

//用于保存key的Set集合
transient Set<K>        keySet;
//用于保存value的Collection集合
transient Collection<V> values;
//获取key的Set集合
public Set<K> keySet() {
    Set<K> ks = keySet;
    //如果key的Set等于null，则新建一个keySet通过返回一个匿名内部类实现
    if (ks == null) {
        //通过抽象类AbstractSet，实现一个匿名内部类
        ks = new AbstractSet<K>() {
            public Iterator<K> iterator() {
                return new Iterator<K>() {
                    private Iterator<Entry<K,V>> i = entrySet().iterator();

                    public boolean hasNext() {
                        return i.hasNext();
                    }

                    public K next() {
                        return i.next().getKey();
                    }

                    public void remove() {
                        i.remove();
                    }
                };
            }

            public int size() {
                return AbstractMap.this.size();
            }

            public boolean isEmpty() {
                return AbstractMap.this.isEmpty();
            }

            public void clear() {
                AbstractMap.this.clear();
            }

            public boolean contains(Object k) {
                return AbstractMap.this.containsKey(k);
            }
        };
        keySet = ks;
    }
    return ks;
}
```

同理类似的有public Collection<V> values( )方法，获取一个值value的collection集合，原理与获取key的set集合类似，通过匿名内部类实现。

3.equals和hashCode

AbstractMap重写了equals和hashCode两个方法，用于判断对象是否相等，在map中允许重复的value，不允许重复的key，同时某些实体类的value和key值可以为null；AbstractMap方法的equals方法是对比两个集合里键值对的映射关系是否都是相等的，如果相等，则认为是相等的集合（传统的equals方法与物理层的地址有一定的关系）

```
public boolean equals(Object o) {
    if (o == this)
        return true;

    if (!(o instanceof Map))
        return false;
    Map<?,?> m = (Map<?,?>) o;
    if (m.size() != size())
        return false;

    try {
    	 //获取当前集合的迭代器
        Iterator<Entry<K,V>> i = entrySet().iterator();
        while (i.hasNext()) {
        	  //当前集合的Entry
            Entry<K,V> e = i.next();
            //当前集合的key
            K key = e.getKey();
            //当前集合的value
            V value = e.getValue();
            //当前集合的value为null,如果o的key对应的值不为null，当前集合的key存在于o中，则返回false
            if (value == null) {
                if (!(m.get(key)==null && m.containsKey(key)))
                    return false;
            } else {
               //当前集合的value不为null，如果当前集合的value==o对应的key的值，则返回false
                if (!value.equals(m.get(key)))
                    return false;
            }
        }
    } catch (ClassCastException unused) {
        return false;
    } catch (NullPointerException unused) {
        return false;
    }

    return true;
}

public int hashCode() {
    int h = 0;
    Iterator<Entry<K,V>> i = entrySet().iterator();
    while (i.hasNext())
        h += i.next().hashCode();
    return h;
}
```

bstractMap的clone( )方法是重写Object中的，并且是直接调用的Object.clone( )方法获取一个AbstractMap，并将其中的keySet和values置空；

```
protected Object clone() throws CloneNotSupportedException {
    AbstractMap<?,?> result = (AbstractMap<?,?>)super.clone();
    result.keySet = null;
    result.values = null;
    return result;
}
```

AbstractMap有两个内部类SimpleEntry<K, V>和SimpleImmutableEntry<K, V>，他们都是AbstractMap的静态内部类，并且都实现了Map.Entry<K, V>和Serializable接口；

实现Entry接口，用于保存K-V映射关系，两者都重载了equals、hashCode和toString方法，如两者的名字一样，实现都比较简单，此处就不再赘述；
两者的区别主要是final类型的变量不一样，SimpleEntry中key是用final修饰，初始化后是不可更改的，而SimpleImmutableEntry的key和value都是用final修饰的，初始化以后是不可更改的，两者都为其子类的具体实现提供一个简单的入口。SimpleImmutableEntry不支持修改key对应的value；

```
public V setValue(V value) {
    throw new UnsupportedOperationException();
}
```

#### LinkedHashMap

![image](pic/p119.png )

#### HashTable

![image](pic/p120.png )

##### Dictionary

```
Dictionary类是任何类的抽象父类，例如Hashtable，它将键映射到值。 每个键和每个值都是一个对象。 在任何一个Dictionary对象中，每个键最多与一个值相关联。 给定一个Dictionary和一个键，可以查找关联的元素。 任何非null对象都可以用作键和值。  
通常，此类的实现应使用equals方法来确定两个键是否相同。
注意：此类已经废弃了，新的实现方式为Map接口，来扩展此类
```

#### Properties

![image](pic/p121.png )

```
Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。

一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。

因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的 Properties 对象（即包含非 String 的键）上调用 propertyNames 或 list 方法，则该调用将失败。
```

setProperty方法

```
//调用父类的HashTable的put方法
public synchronized Object setProperty(String key, String value) {
    return put(key, value);
}
```

getProperty方法

```
public String getProperty(String key) {
	 //调用父类HashTable的get方法
    Object oval = super.get(key);
    String sval = (oval instanceof String) ? (String)oval : null;
    //通过递归调用
    return ((sval == null) && (defaults != null)) ? defaults.getProperty(key) : sval;
}
```

#### WeakHashMap

![image](pic/p122.png )

#### TreeMap

![image](pic/p123.png )

#### EnumMap

![image](pic/p124.png )

#### IdentityHashMap

![image](pic/p125.png )

#### ConcurrentHashMap和ConcurrentSkipListMap

![image](pic/p125.png )


##集合类以及集合框架

### ArrayList源码解析

ArrayList就是动态数组，是Array的复杂版本，动态的增加和减少元素，实现了Collection和List接口，灵活的设置数组的大小。实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。

#### Function接口

```
public interface Function<T, R> {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);

    /**
     * 先做传入的Function类型的参数的apply操作，再做当前这个接口的apply操作
     * V表示这个Function类型的参数的传入参数类型，也就是本接口的T类型
     */
    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

    /**
     * 先做本接口的apply操作，再做传入的Function类型的参数的apply操作
     */
    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }

    /**
     * 静态方法表示，这个传入的泛型参数T的本身
     */
    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
```

#### UnaryOperator接口

```

  /**
   * 对数据进行操作，生成一个与同类型对象。 方法只有一个static UnaryOperator
   * identity()，该方法返回一个UnaryOerator对象，并且apply()方法中直接返回范型对象。
   */
public interface UnaryOperator<T> extends Function<T, T> {
  
    static <T> UnaryOperator<T> identity() {
        return t -> t;
    }
}
```

#### ArrayList源码

* 由ArrayList<E>可知其支持泛型
* AbstractList提供了List接口的默认实现（个别方法为抽象方法）。
* List接口（extends Collection）定义了列表必须实现的方法。
* RandomAccess是一个标记接口，接口内没有定义任何内容。
* 实现了Cloneable接口的类，可以调用Object.clone方法返回该对象的浅拷贝。
* 通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标记可序列化的语义。


```


/**
 * 概述：
 *  List接口可调整大小的数组实现。实现所有可选的List操作，并允许所有元素，包括null，元素可重复。
 *  除了列表接口外，该类提供了一种方法来操作该数组的大小来存储该列表中的数组的大小。
 * 
 * 时间复杂度：
 *  方法size、isEmpty、get、set、iterator和listIterator的调用是常数时间的。
 *  添加删除的时间复杂度为O(N)。其他所有操作也都是线性时间复杂度。
 *
 * 容量：
 *  每个ArrayList都有容量，容量大小至少为List元素的长度，默认初始化为10。
 *  容量可以自动增长。
 *  如果提前知道数组元素较多，可以在添加元素前通过调用ensureCapacity()方法提前增加容量以减小后期容量自动增长的开销。
 *  也可以通过带初始容量的构造器初始化这个容量。
 *
 * 线程不安全：
 *  ArrayList不是线程安全的。
 *  如果需要应用到多线程中，需要在外部做同步
 *
 * modCount：
 *  定义在AbstractList中：protected transient int modCount = 0;
 *  从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。
 *  此字段由iterator和listiterator方法返回的迭代器和列表迭代器实现使用。
 *  如果意外更改了此字段中的值，则迭代器（或列表迭代器）将抛出concurrentmodificationexception来响应next、remove、previous、set或add操作。
 *  在迭代期间面临并发修改时，它提供了快速失败行为，而不是非确定性行为。
 *  子类是否使用此字段是可选的。
 *  如果子类希望提供快速失败迭代器（和列表迭代器），则它只需在其add(int,e)和remove(int)方法（以及它所重写的、导致列表结构上修改的任何其他方法）中增加此字段。
 *  对add(int, e)或remove(int)的单个调用向此字段添加的数量不得超过1，否则迭代器（和列表迭代器）将抛出虚假的concurrentmodificationexceptions。
 *  如果某个实现不希望提供快速失败迭代器，则可以忽略此字段。
 *
 * transient：
 *  默认情况下,对象的所有成员变量都将被持久化.在某些情况下,如果你想避免持久化对象的一些成员变量,你可以使用transient关键字来标记他们,transient也是java中的保留字(JDK 1.8)
 */

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * 默认数组的初始容量大小为10
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 用于空实例的共享空数组实例
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * 用于默认空实例的共享空数组实例,与EMPTY_ELEMENTDATA区别是，在添加第一个元素时知道要扩展多少
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * 存放元素的数组.
     * ArrayList的容量是该数组的长度.任何空ArrayList是DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * 当第一个元素添加到ArrayList中时DEFAULTCAPACITY_EMPTY_ELEMENTDATA扩展成
     * DEFAULT_CAPACITY
     */
    transient Object[] elementData; // 包级访问权限

    /**
     * ArrayList的大小（ArrayList包含的元素）
     * @serial
     */
    private int size;

    /**
     * 指定初始容量大小的构造方法
     * 当指定容量大于0时，存放元素数组大小为指定容量
     * 当指定容量等于0时，存放元素数组为空数组实例
     * 当指定容量等于<时，抛出IllegalArgumentException
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    /**
     * 默认构造方法，初始容量为10的空列表.
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    /**
     * 参数为Collection元素列表参数的构造方法，指定collection的元素的列表，
     * 按照该collection的迭代器返回的顺序排列
     */
    public ArrayList(Collection<? extends E> c) {
    	 //将传入的数组转化成数组，赋值给ArrayList的存放元素的数组
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {//如果elementData.length不为0，则先赋值
            //c.toarray可能不返回对象Object[]（见JAVA BUG编号6260652）
            //如果elementData.getClass()不是Object[].class，则通过Array.Copy方法将
            //elementData拷贝成一个新数组赋值给原来的elementData
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // 存放元素的数组置为空数组
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }

    /**
     * 因为存放元素的数组长度常常会大于ArrayList实际的容量。内存紧张时，可以调用该方
     * 法删除预留的位置，调整存放元素的数组长度为ArrayList实际的容量。
     * 如果确定不会再有元素添加进来时也可以调用该方法来节约空间
     */
    public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }

    /**
     * ensureCapacity、ensureCapacityInternal、ensureExplicitCapacity
     * 使用指定参数设置数组最小长度
     * 增加此ArrayList实例的容量，以确保它可以容纳由最小长度（minCapacity）的元素数
     */
    public void ensureCapacity(int minCapacity) {
    	 //如果存放元素的数组不为空，则最小扩展长度为0
    	 //如果存放元素的数组为空，则最小扩展长度为默认长度10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)? 0
            : DEFAULT_CAPACITY;
		 //指定的最小长度大于扩展长度
        if (minCapacity > minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }

    private void ensureCapacityInternal(int minCapacity) {
    	 //如果数组为空实例数组，则最小容量取minCapacity和DEFAULT_CAPACITY的最大值
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // 如果最容量大于数组的长度，则增加数组长度
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

    /**
     * 数组分配的最大长度.
     * 虚拟机在数组中保存对象的头信息，最大占8个字节.
     * 尝试分配更大的数组长度会引起内存溢出
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * 增加数组长度已确保至少容纳参数中指定的元素长度
     */
    private void grow(int minCapacity) {
        // 旧数组长度=存放元素数组的长度
        int oldCapacity = elementData.length;
        // 新数组长度=旧数组长度+(旧数组长度右移一位(相当于除以2))
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //如果新数组长度小于参数指定的长度，则将参数指定的长度赋值给新数组长度
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        //如果新数组长度大于数组最大长度则通过参数指定的长度做判断
        //1.参数指定的长度小于0抛出OutOfMemoryError
        //2.参数的指定长度大于数组最大长度，则新数组长度被设置为Integer.MAX_VALUE
        //3.参数的指定长度小于数组最大长度,则新数组长度被设置为MAX_ARRAY_SIZE（则数组最大长度）
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 通过拷贝将旧数组重新赋值
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    /**
     * 返回集合的大小
     */
    public int size() {
        return size;
    }

    /**
     *判断集合是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含参数中的元素
     * 如果集合中包含指定的元素返回true
     * 确切的说,只要集合中至少包含一个指定的元素则返回true
     */
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }

    /**
     * 返回指定元素在集合中第一次出现位置的索引，如果不包含指定元素则返回-1
     * 从这个方法可以得知，ArrayList可以存null值
     */
    public int indexOf(Object o) {
    	 //如果指定元素为null,则循环遍历数组看数组中是否有null元素，如果有则返回数组中第一次出现null元素的索引
    	 //时间复杂度为O(n)
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            //如果指定元素不为null,则循环遍历数组看数组中是否有该指定元素，如果有则返回数组中第一次出现该元素的索引
            //时间复杂度为O(n)
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 返回指定元素在集合中最后一次出现位置的索引，如果不包含指定元素则返回-1
     */
    public int lastIndexOf(Object o) {
        //如果指定元素为null,则循反序环遍历数组看数组中是否有null元素，如果有则返回数组中第一次出现null元素的索引
    	 //时间复杂度为O(n)
        if (o == null) {
            for (int i = size-1; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            //如果指定元素不为null,则反序循环遍历数组看数组中是否有该指定元素，如果有则返回数组中第一次出现该元素的索引
            //时间复杂度为O(n)
            for (int i = size-1; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    /**
     * 浅拷贝当前集合实例（元素本身没有被拷贝）
     */
    public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;//修改次数改为0
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }

    /**
     * 返回包含在集合中所有有序元素的数组
     * 返回的数组是安全的，因为返回的数组没有保留对列表的引用（换句话说，这个方法分配了一个新数组）
     * 调用者可以自由的更改返回的数组
     * 此方法扮演着基于数组和基于集合的API之间的桥梁
     */
    public Object[] toArray() {
        //返回拷贝的新数组
        return Arrays.copyOf(elementData, size);
    }

    /**
     * 返回一个数组，使用运行时确定类型，该数组包含在这个列表中的所有元素（从第一到最后一个元素）
     * 返回的数组容量由参数数组的长度和列表容量较大值确定
     */
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
    	 //参数数组的长度小于集合的容量
        if (a.length < size)
            // 创建一个运行时类型的新数组
            // 通过拷贝存放元素的数组生成一个新数组,新数组的类型为参数的类型
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        
        //调用系统的拷贝方法将存放元素的数组拷贝到参数的数组中
        System.arraycopy(elementData, 0, a, 0, size);
        
        //参数数组的长度大于于集合的容量
        if (a.length > size)
            //直接将参数数组的size索引位置置为null
            a[size] = null;
        return a;
    }

    //包级访问权限，返回指定索引位置的元素
    @SuppressWarnings("unchecked")
    E elementData(int index) {
        return (E) elementData[index];
    }

    /**
     *包级访问权限，返回指定索引位置的元素
     */
    public E get(int index) {
    	 //范围检查，如果index大于等于列表容量，则抛出IndexOutOfBoundsException
        rangeCheck(index);
		 
		 //根据指定的索引，返回当前存放元素数组对应索引位置的元素
        return elementData(index);
    }

    /**
     * 用指定元素element替换列表中指定位置的元素,并返回被替换的元素值
     */
    public E set(int index, E element) {
    	 //范围检查，如果index大于等于列表容量，则抛出IndexOutOfBoundsException
        rangeCheck(index);
		 
		 //在存放元素的数组中获取指定索引位置的旧元素
        E oldValue = elementData(index);
        //将存放元素的数组中所对应索引位置的值替换成指定元素的值
        elementData[index] = element;
        return oldValue;
    }

    /**
     * 将指定元素添加到列表末尾
     * 
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // 一定会增加 modCount!!
        elementData[size++] = e;
        return true;
    }

    /**
     * 在列表中插入指定的元素到指定的位置，将当前位置的元素（如果有）和后续元
     * 素向右移动（在其索引中加1）
     */
    public void add(int index, E element) {
    	 //范围检测
    	 //如果指定位置索引index大于列表容量size或者index小于0，抛出IndexOutOfBoundsException
        rangeCheckForAdd(index);
		 
        ensureCapacityInternal(size + 1);  // 一定会增加 modCount!!
        
        //通过系统的Copy方法，将存放元素的数组整体从指定索引位置index开始向后移动一位
        /*
         *String[] a = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", null, null};
         *System.arraycopy(a, 3, a, 4, 7);
         *a[3] = "x";
         *System.out.println(Arrays.toString(a));
         *结果是：[1, 2, 3, x, 4, 5, 6, 7, 8, 9, 10, null]
         */
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        //将指定位置处的元素替换为指定元素
        elementData[index] = element;
        size++;
    }

    /**
     * 在列表中删除指定位置的元素，将后续元素向左移动一位(从他们的指数中减去一个值)
     */
    public E remove(int index) {
    	 //范围检查，如果指定索引大于等于列表容量，则抛出IndexOutOfBoundsException
        rangeCheck(index);

        modCount++;
        //获取指定索引处的元素
        E oldValue = elementData(index);
		 //移动范围为列表容量减去指定索引值减1
        int numMoved = size - index - 1;
        //如果移动范围大于0，则使用系统copy方法，将存放元素的数组从删除位置向左copy一位
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        //列表容量减一值赋值为null                     
        elementData[--size] = null; // 元素设置为null，使GC回收
		 //返回旧值
        return oldValue;
    }

    /**
     * 删除第一次出现在列表中的指定元素如果该元素存在于列表中
     * 如果列表不包含该元素，则不会更改。 确切的说，删除索引最低的元素
     */
    public boolean remove(Object o) {
    	 //如果指定元素为null,循环列表
        if (o == null) {
            for (int index = 0; index < size; index++)
            	   //如果存在null值
                if (elementData[index] == null) {
                		//调用快速删除方法
                    fastRemove(index);
                    return true;
                }
        } else {//如果指定元素为null,循环列表
        	  //如果存在指定的值，比较值的方法用的equals方法
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * 私有删除方法，跳过边界检查，但没有返回删除的值。
     */
    private void fastRemove(int index) {
        modCount++;
        //移动范围为列表容量减去指定索引值减1
        int numMoved = size - index - 1;
        //如果移动范围大于0，则使用系统copy方法，将存放元素的数组从删除位置向左copy一位
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        //列表容量减一值赋值为null  
        elementData[--size] = null; // clear to let GC do its work
    }

    /**
     * 删除列表中的所有元素
     */
    public void clear() {
        modCount++;

        // 通过循环，将存放元素的数组中的值都置为null，方便GC回收
        for (int i = 0; i < size; i++)
            elementData[i] = null;
        //列表容量置为0
        size = 0;
    }

    /**
     * 将指定集合中的所有元素按指定集合的迭代器返回的顺序添加到该列表的尾端。如果在操作正在进行时修改
     * 了指定的集合，则此操作的行为是不确定的。
     */
    public boolean addAll(Collection<? extends E> c) {
    	 //指定集合转成数组
        Object[] a = c.toArray();
        //获取该数组的长度
        int numNew = a.length;
        //容量检测
        ensureCapacityInternal(size + numNew);  // Increments modCount
        //将该数组从0开始copy到存放元素的数组
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    /**
     * 将指定集合中的元素从指定位置插入到列表中，将当前位置的元素（如果有）和任何后续元素向右移动（增加其索引）。 
     * 新元素将按照它们返回的顺序显示在列表中
     */
    public boolean addAll(int index, Collection<? extends E> c) {
    	 //添加范围检查
        rangeCheckForAdd(index);
        //指定集合转成数组
        Object[] a = c.toArray();
        //获取该数组的长度
        int numNew = a.length;
        //容量检测
        ensureCapacityInternal(size + numNew);  // Increments modCount
		 //移动范围为列表容量减去指定索引值index
        int numMoved = size - index;
        //如果移动范围大于0，
        if (numMoved > 0)
            //调用系统copy方法将存放元素的数组elementData，从指定索引index处copy到elementData中去
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
		 //调用系统copy方法将转换成的数组a从0开始copy到存放元素的数组elementData中去
        System.arraycopy(a, 0, elementData, index, numNew);
        //数组容量添加数组的长度
        size += numNew;
        return numNew != 0;
    }

    /**
     * 删除列表中从开始索引((包括该索引的元素))到结束索引(不包括该索引的元素)的元素即删除从[fromIndex,toIndex)的元素
     * 将任何后续元素向左移动（降低其索引）
     * 通过toIndex-fromIndex缩短列表
     * 如果toIndex==fromIndex，则此操作不会有任何作用
     */
    protected void removeRange(int fromIndex, int toIndex) {
        modCount++;
        //移动元素范围即移动元素的个数
        int numMoved = size - toIndex;
        //调用系统copy方法，将存放元素数组elementData的元素从toIndex开始，copy到存放元素数组elementData中
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // 获取新列表的容量值
        int newSize = size - (toIndex-fromIndex);
        // 将存放元素的数组中的元素从新列表的容量值newSize开始，全部置为null，方便GC回收
        for (int i = newSize; i < size; i++) {
            elementData[i] = null;
        }
        size = newSize;
    }

    /**
     * 检测指定索引的范围是否超出列表的容量
     */
    private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 添加的时候范围检查，如果指定索引大于列表容量或者小于0，则抛出IndexOutOfBoundsException异常
     */
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 抛出异常的日志
     */
    private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }

    /**
     * 从列表中删除指定集合中的元素
     */
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, false);
    }

    /**
     * 列表中保留指定集合中的元素
     */
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    }

    private boolean batchRemove(Collection<?> c, boolean complement) {
        //获取存放元素数组设置为final，即指针地址不可变，但是数组的值可变
        final Object[] elementData = this.elementData;
        //两根指针，w表示写入的指针，r表示读取指针
        int r = 0, w = 0;
        //是否更改
        boolean modified = false;
        try {
        	  //列表循环
            for (; r < size; r++)
                //当removeAll方法调用的时候因为complement=false，所以如果指定集合中不含元素elementData[r]，则将该元素赋值给存放元素数组elementData[w++]
                //当retainAll方法调用的时候因为complement=true，所以如果指定集合中包含元素elementData[r]，则将该元素赋值给存放元素数组elementData[w++]
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // c.contains（）抛出异常与AbstractCollection保持行为兼容性
            // 读入指针不等于列表容量，则调用系统copy方法将存放元素数组从r开始复制
            if (r != size) {
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            // 如果写入指针w不等于列表容量，表示指定集合中的元素在存放元素数组中也有
            //存放元素数组中索引小于写入指针w的都是不包含在指定集合中的，
            //存放元素数组中从写入指针w开始全部置为null
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i < size; i++)
                    elementData[i] = null; 
                modCount += size - w;
                //列表容量为w
                size = w;
                //已更改
                modified = true;
            }
        }
        return modified;
    }

    /**
     * 序列化默认的方法，保存数组实例的状态到一个流（即序列化）
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    /**
     * 序列化默认的方法，从流中读取数组实例(反序列化)
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size > 0) {
            // be like clone(), allocate array based upon size not capacity
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i<size; i++) {
                a[i] = s.readObject();
            }
        }
    }

    /**
     * 返回一个列表迭代器
     */
    public ListIterator<E> listIterator(int index) {
        if (index < 0 || index > size)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }

    /**
     * 返回一个列表迭代器
     */
    public ListIterator<E> listIterator() {
        return new ListItr(0);
    }

    /**
     * 返回一个迭代器，这个迭代器是快速失败模式
     */
    public Iterator<E> iterator() {
        return new Itr();
    }

    /**
     * 通用的迭代器实现，AbstractList.Itr的优化版本
     */
    private class Itr implements Iterator<E> {
        int cursor;       // 游标，下一个元素的索引，默认初始化为0
        int lastRet = -1; // 上次访问的元素的位置
        int expectedModCount = modCount;//迭代过程不运行修改数组，否则就抛出异常
		 //是否还有下一个
        public boolean hasNext() {
            return cursor != size;
        }
		 //下一个元素
        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();//检查数组是否被修改
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;//向后移动游标
            return (E) elementData[lastRet = i];//设置访问的位置并返回这个值
        }
        //删除元素
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();//检查数组是否被修改

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    /**
     * AbstractList.ListItr的优化版本
     */
    private class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor - 1;
        }

        @SuppressWarnings("unchecked")
        public E previous() {
            checkForComodification();
            int i = cursor - 1;
            if (i < 0)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i;
            return (E) elementData[lastRet = i];
        }

        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.set(lastRet, e);
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }

    //返回指定范围的子数组
    public List<E> subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }

    static void subListRangeCheck(int fromIndex, int toIndex, int size) {
        if (fromIndex < 0)
            throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
        if (toIndex > size)
            throw new IndexOutOfBoundsException("toIndex = " + toIndex);
        if (fromIndex > toIndex)
            throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                               ") > toIndex(" + toIndex + ")");
    }
    //子数组
    private class SubList extends AbstractList<E> implements RandomAccess {
        private final AbstractList<E> parent;
        private final int parentOffset;
        private final int offset;
        int size;

        SubList(AbstractList<E> parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }

        public E set(int index, E e) {
            rangeCheck(index);
            checkForComodification();
            E oldValue = ArrayList.this.elementData(offset + index);
            ArrayList.this.elementData[offset + index] = e;
            return oldValue;
        }

        public E get(int index) {
            rangeCheck(index);
            checkForComodification();
            return ArrayList.this.elementData(offset + index);
        }

        public int size() {
            checkForComodification();
            return this.size;
        }

        public void add(int index, E e) {
            rangeCheckForAdd(index);
            checkForComodification();
            parent.add(parentOffset + index, e);
            this.modCount = parent.modCount;
            this.size++;
        }

        public E remove(int index) {
            rangeCheck(index);
            checkForComodification();
            E result = parent.remove(parentOffset + index);
            this.modCount = parent.modCount;
            this.size--;
            return result;
        }

        protected void removeRange(int fromIndex, int toIndex) {
            checkForComodification();
            parent.removeRange(parentOffset + fromIndex,
                               parentOffset + toIndex);
            this.modCount = parent.modCount;
            this.size -= toIndex - fromIndex;
        }

        public boolean addAll(Collection<? extends E> c) {
            return addAll(this.size, c);
        }

        public boolean addAll(int index, Collection<? extends E> c) {
            rangeCheckForAdd(index);
            int cSize = c.size();
            if (cSize==0)
                return false;

            checkForComodification();
            parent.addAll(parentOffset + index, c);
            this.modCount = parent.modCount;
            this.size += cSize;
            return true;
        }

        public Iterator<E> iterator() {
            return listIterator();
        }

        public ListIterator<E> listIterator(final int index) {
            checkForComodification();
            rangeCheckForAdd(index);
            final int offset = this.offset;

            return new ListIterator<E>() {
                int cursor = index;
                int lastRet = -1;
                int expectedModCount = ArrayList.this.modCount;

                public boolean hasNext() {
                    return cursor != SubList.this.size;
                }

                @SuppressWarnings("unchecked")
                public E next() {
                    checkForComodification();
                    int i = cursor;
                    if (i >= SubList.this.size)
                        throw new NoSuchElementException();
                    Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length)
                        throw new ConcurrentModificationException();
                    cursor = i + 1;
                    return (E) elementData[offset + (lastRet = i)];
                }

                public boolean hasPrevious() {
                    return cursor != 0;
                }

                @SuppressWarnings("unchecked")
                public E previous() {
                    checkForComodification();
                    int i = cursor - 1;
                    if (i < 0)
                        throw new NoSuchElementException();
                    Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length)
                        throw new ConcurrentModificationException();
                    cursor = i;
                    return (E) elementData[offset + (lastRet = i)];
                }

                @SuppressWarnings("unchecked")
                public void forEachRemaining(Consumer<? super E> consumer) {
                    Objects.requireNonNull(consumer);
                    final int size = SubList.this.size;
                    int i = cursor;
                    if (i >= size) {
                        return;
                    }
                    final Object[] elementData = ArrayList.this.elementData;
                    if (offset + i >= elementData.length) {
                        throw new ConcurrentModificationException();
                    }
                    while (i != size && modCount == expectedModCount) {
                        consumer.accept((E) elementData[offset + (i++)]);
                    }
                    // update once at end of iteration to reduce heap write traffic
                    lastRet = cursor = i;
                    checkForComodification();
                }

                public int nextIndex() {
                    return cursor;
                }

                public int previousIndex() {
                    return cursor - 1;
                }

                public void remove() {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();

                    try {
                        SubList.this.remove(lastRet);
                        cursor = lastRet;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                public void set(E e) {
                    if (lastRet < 0)
                        throw new IllegalStateException();
                    checkForComodification();

                    try {
                        ArrayList.this.set(offset + lastRet, e);
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                public void add(E e) {
                    checkForComodification();

                    try {
                        int i = cursor;
                        SubList.this.add(i, e);
                        cursor = i + 1;
                        lastRet = -1;
                        expectedModCount = ArrayList.this.modCount;
                    } catch (IndexOutOfBoundsException ex) {
                        throw new ConcurrentModificationException();
                    }
                }

                final void checkForComodification() {
                    if (expectedModCount != ArrayList.this.modCount)
                        throw new ConcurrentModificationException();
                }
            };
        }

        public List<E> subList(int fromIndex, int toIndex) {
            subListRangeCheck(fromIndex, toIndex, size);
            return new SubList(this, offset, fromIndex, toIndex);
        }

        private void rangeCheck(int index) {
            if (index < 0 || index >= this.size)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }

        private void rangeCheckForAdd(int index) {
            if (index < 0 || index > this.size)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }

        private String outOfBoundsMsg(int index) {
            return "Index: "+index+", Size: "+this.size;
        }

        private void checkForComodification() {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
        }

        public Spliterator<E> spliterator() {
            checkForComodification();
            return new ArrayListSpliterator<E>(ArrayList.this, offset,
                                               offset + this.size, this.modCount);
        }
    }

    //forEach迭代方式，底层用的传统的for
    @Override
    public void forEach(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        @SuppressWarnings("unchecked")
        final E[] elementData = (E[]) this.elementData;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            action.accept(elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    /**
     * Java8新增，生成Spliterator接口，有点类似nio里的selector
     */
    @Override
    public Spliterator<E> spliterator() {
        return new ArrayListSpliterator<>(this, 0, -1, 0);
    }

    /** Index-based split-by-two, lazily initialized Spliterator */
    static final class ArrayListSpliterator<E> implements Spliterator<E> {

        private final ArrayList<E> list;
        private int index; // current index, modified on advance/split
        private int fence; // -1 until used; then one past last index
        private int expectedModCount; // initialized when fence set

        /** Create new spliterator covering the given  range */
        ArrayListSpliterator(ArrayList<E> list, int origin, int fence,
                             int expectedModCount) {
            this.list = list; // OK if null unless traversed
            this.index = origin;
            this.fence = fence;
            this.expectedModCount = expectedModCount;
        }

        private int getFence() { // initialize fence to size on first use
            int hi; // (a specialized variant appears in method forEach)
            ArrayList<E> lst;
            if ((hi = fence) < 0) {
                if ((lst = list) == null)
                    hi = fence = 0;
                else {
                    expectedModCount = lst.modCount;
                    hi = fence = lst.size;
                }
            }
            return hi;
        }

        public ArrayListSpliterator<E> trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
            return (lo >= mid) ? null : // divide range in half unless too small
                new ArrayListSpliterator<E>(list, lo, index = mid,
                                            expectedModCount);
        }

        public boolean tryAdvance(Consumer<? super E> action) {
            if (action == null)
                throw new NullPointerException();
            int hi = getFence(), i = index;
            if (i < hi) {
                index = i + 1;
                @SuppressWarnings("unchecked") E e = (E)list.elementData[i];
                action.accept(e);
                if (list.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            }
            return false;
        }

        public void forEachRemaining(Consumer<? super E> action) {
            int i, hi, mc; // hoist accesses and checks from loop
            ArrayList<E> lst; Object[] a;
            if (action == null)
                throw new NullPointerException();
            if ((lst = list) != null && (a = lst.elementData) != null) {
                if ((hi = fence) < 0) {
                    mc = lst.modCount;
                    hi = lst.size;
                }
                else
                    mc = expectedModCount;
                if ((i = index) >= 0 && (index = hi) <= a.length) {
                    for (; i < hi; ++i) {
                        @SuppressWarnings("unchecked") E e = (E) a[i];
                        action.accept(e);
                    }
                    if (lst.modCount == mc)
                        return;
                }
            }
            throw new ConcurrentModificationException();
        }

        public long estimateSize() {
            return (long) (getFence() - index);
        }

        public int characteristics() {
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        }
    }

    @Override
    public boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            @SuppressWarnings("unchecked")
            final E element = (E) elementData[i];
            if (filter.test(element)) {
                removeSet.set(i);
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount > 0;
        if (anyToRemove) {
            final int newSize = size - removeCount;
            for (int i=0, j=0; (i < size) && (j < newSize); i++, j++) {
                i = removeSet.nextClearBit(i);
                elementData[j] = elementData[i];
            }
            for (int k=newSize; k < size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            this.size = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final int expectedModCount = modCount;
        final int size = this.size;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            elementData[i] = operator.apply((E) elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void sort(Comparator<? super E> c) {
        final int expectedModCount = modCount;
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
}
```

### LinkedList源码解析

#### 特点

* LinkedList是一个继承于AbatractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。
* LinkedList实现了List接口，能对它进行队列操作。
* LinkedList实现了Deque接口，即能将LinkedList当作双端队列使用。
* LinkedList实现了java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
* LinkedList是非同步的。

#### 源码

```
/**
 * LinkedList底层使用双向链表，实现了List和deque。实现所有的可选List操作，并可以只有所有元素（包括空值）
 * 其大小理论上仅受内存大小的限制
 *
 * 所有的操作都可以作为一个双联列表来执行（及对双向链表操作）。
 * 把对链表的操作封装起来，并对外提供看起来是对普通列表操作的方法。
 * 遍历从起点、终点、或指定位置开始
 * 内部方法，注释会描述为节点的操作(如删除第一个节点)，公开的方法会描述为元素的操作(如删除第一个元素)
 *
 * LinkedList不是线程安全的，如果在多线程中使用（修改），需要在外部作同步处理。
 * 
 * 需要弄清元素（节点）的索引和位置的区别，不然有几个地方不好理解，具体在碰到的地方会解释。
 * 
 * 迭代器可以快速报错
 */
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{   
    //列表容量
    transient int size = 0;

    /**
     * 链表的头结点          
     */
    transient Node<E> first;

    /**
     * 链表的尾节点
     */
    transient Node<E> last;

    /**
     * 默认构造函数，创建一个空链表
     */
    public LinkedList() {
    }
    
    /**
     * 指定参数为集合Collection的构造方法，按照该collection的迭代器返回的顺序排列
     */
    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }

    /**
     * 使对应参数作为第一个节点
     */
    private void linkFirst(E e) {
        //获取链表的头结点为当前的节点  
        final Node<E> f = first;
        //得到新节点
        final Node<E> newNode = new Node<>(null, e, f);
        //将新节点赋值给链表的头结点
        first = newNode;
        //如果链表的当前节点为null
        if (f == null)
        	  //将新节点赋值给链表的尾结点，因为是双端链表
            last = newNode;
        else //如果链表的头结点不为null
        	  //将新节点赋值给当前节点f的前一个节点
            f.prev = newNode;
        //列表的容量+1    
        size++;
        modCount++;
    }

    /**
     * 使对应参数作为最后一个节点
     */
    void linkLast(E e) {
        //获取链表的尾结点为当前的节点
        final Node<E> l = last;
        //得到新节点
        final Node<E> newNode = new Node<>(l, e, null);
        //将新节点赋值给链表的尾结点
        last = newNode;
        //如果链表的当前节点为null
        if (l == null)
            //将新节点赋值给链表的头结点，因为是双端链表
            first = newNode;
        else
            //将新节点赋值给当前节点l的后一个节点
            l.next = newNode;
        //列表的容量+1      
        size++;
        modCount++;
    }

    /**
     * 在非null节点succ之前插入节点
     */
    void linkBefore(E e, Node<E> succ) {
        // 获取指定节点succ的前节点
        final Node<E> pred = succ.prev;
        // 得到新节点
        final Node<E> newNode = new Node<>(pred, e, succ);
        // 将新节点赋值给指定节点succ的前节点
        succ.prev = newNode;
        // 获取指定节点succ的前节点为null
        if (pred == null)
            //将新节点赋值给链表的头结点，因为指定节点succ就是头结点
            first = newNode;
        else
            //将新节点赋值给指定节点succ的下一个节点
            pred.next = newNode;
        size++;
        modCount++;
    }

    /**
     * 删除头节点并返回删除前头节点的值
     */
    private E unlinkFirst(Node<E> f) {
        // assert f == first && f != null;
        //获取头结点的值
        final E element = f.item;
        //获取头结点的下一个节点
        final Node<E> next = f.next;
        //头结点对应的值赋值为null
        f.item = null;
        //头结点的下一个节点赋值为null，方便GC
        f.next = null; // help GC
        //将删除的头结点的下一个节点设置为头结点
        first = next;
        //如果删除的头结点的下一个节点为null
        if (next == null)
            //将最后一个节点设置为null
            last = null;
        else
            //如果删除的头结点的下一个节点不为null，则将删除的头结点的下一个节点的上一个节点设置为null
            next.prev = null;
        //列表容量-1    
        size--;
        modCount++;
        return element;
    }

    /**
     * 删除尾节点并返回删除前尾节点的值
     */
    private E unlinkLast(Node<E> l) {
        // assert l == last && l != null;
        //获取删除尾节点的值
        final E element = l.item;
        //获取删除尾节点的上一个节点
        final Node<E> prev = l.prev;
        //删除尾节点的值设置为null
        l.item = null;
        //删除尾节点的上一个节点设置为null,方便垃圾回收
        l.prev = null; // help GC
        //将删除的尾结点的上一个节点设置为尾节点
        last = prev;
        //如果删除的尾结点的上一个节点为null
        if (prev == null)
            //将头结点设置为null
            first = null;
        else
            //如果删除的尾结点的上一个节点不为null，则将删除的尾结点的上一个节点的下一个节点设置为null
            prev.next = null;
        //列表容量-1        
        size--;
        modCount++;
        return element;
    }

    /**
     * 删除指定节点并返回被删除节点的值
     */
    E unlink(Node<E> x) {
        // assert x != null;
        //获取删除节点的值
        final E element = x.item;
        //获取删除节点的下一个节点
        final Node<E> next = x.next;
        //获取删除节点的上一个节点
        final Node<E> prev = x.prev;
		 //删除节点的上一个节点为null
        if (prev == null) {
            //将删除节点的下一个节点设置为头节点
            first = next;
        } else {//删除节点的上一个节点不为null
            //将删除节点的下一个节点设置为删除节点的上一个节点的下一个节点
            prev.next = next;
            //将删除节点的上一个节点设置为null
            x.prev = null;
        }
		 //删除节点的下一个节点为null
        if (next == null) {
            //将删除节点的上一个节点设置为尾节点
            last = prev;
        } else {//删除节点的下一个节点不为null
            //将删除节点的上一个节点设置为删除节点的下一个节点的上一个节点
            next.prev = prev;
            //将删除节点的下一个节点设置为null
            x.next = null;
        }
        //将删除节点的值置为null
        x.item = null;
        //列表容量-1
        size--;
        modCount++;
        return element;
    }

    /**
     * 获取头结点对应的值
     */
    public E getFirst() {
        //获取头结点
        final Node<E> f = first;
        //如果头结点为null，则抛出NoSuchElementException异常
        if (f == null)
            throw new NoSuchElementException();
        //返回头结点对应的值    
        return f.item;
    }

    /**
     * 获取头结点对应的值
     */
    public E getLast() {
        //获取尾结点
        final Node<E> l = last;
        //如果尾结点为null，则抛出NoSuchElementException异常
        if (l == null)
            throw new NoSuchElementException();
        //返回尾结点对应的值     
        return l.item;
    }

    /**
     * 删除头节点并返回头结点对应的值
     */
    public E removeFirst() {
        //获取头结点
        final Node<E> f = first;
        //如果头结点为null，则抛出NoSuchElementException异常
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }

    /**
     * 删除头节点并返回头结点对应的值
     */
    public E removeLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }

    /**
     * 添加指定元素作为头结点
     */
    public void addFirst(E e) {
        linkFirst(e);
    }

    /**
     * 添加指定元素作为尾结点
     */
    public void addLast(E e) {
        linkLast(e);
    }

    /**
     * 列表是否包含指定元素
     */
    public boolean contains(Object o) {
        //获取指定元素的索引如果包含则返该元素在列表中的索引，如果不包含则返回-1
        return indexOf(o) != -1;
    }

    /**
     * 返回列表的容量
     */
    public int size() {
        return size;
    }

    /**
     * 添加指定元素到链表的尾端
     */
    public boolean add(E e) {
        linkLast(e);
        return true;
    }

    /**
     * 删除指定元素
     */
    public boolean remove(Object o) {
        //如果指定元素为null
        if (o == null) {
            //从头结点开始遍历，如果某个节点对应的值为null则删除该节点并返回true
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {//如果指定元素为null
            //从头结点开始遍历，如果某个节点对应的值为指定元素则删除该节点并返回true
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 添加指定集合中的元素到列表尾端，并返回有序的集合迭代器
     * 如果在操作正在进行时修改指定的集合，则此操作的行为是不确定的。 （请注意，如果指定的集合是此列表，则会发生这种情况，并且它是非空的。）
     */
    public boolean addAll(Collection<? extends E> c) {
        return addAll(size, c);
    }

    /**
     * 添加指定集合中的元素到列表的指定位置，并返回有序的集合迭代器
     * 将当前位置的元素（如果有）和任何后续元素向右移动（增加其索引）。
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        checkPositionIndex(index);
        //将指定集合转化为数组
        Object[] a = c.toArray();
        //获取数组的长度
        int numNew = a.length;
        //如果长度为0，则直接返回false
        if (numNew == 0)
            return false;
        //上节点，当前节点
        Node<E> pred, succ;
        //指定位置等于列表容量
        if (index == size) {
            //则当前节点设置为null
            succ = null;
            //上节点设置为尾节点
            pred = last;
        } else {//指定位置不等于列表容量
            //采用二分查找的方式，找到指定索引对应的节点
            succ = node(index);
            //获取当前节点的上一个节点
            pred = succ.prev;
        }
        //循环指定集合转化成的数组
        for (Object o : a) {
            @SuppressWarnings("unchecked") E e = (E) o;//强转成泛型表示的类型
            //不断地获取新节点
            Node<E> newNode = new Node<>(pred, e, null);
            //如果上节点为null，则将新节点设置为头结点
            if (pred == null)
                first = newNode;
            else
                //如果上节点不为null，则将新节点设置为上一个结点的下一个节点
                pred.next = newNode;
            //将新节点设置为上一个结点  
            pred = newNode;
        }
        //如果当前节点为null
        if (succ == null) {
            //将上一个结点设置为尾节点
            last = pred;
        } else {//如果当前节点不为null
            //将当前节点设置为上一个结点的下一个节点
            pred.next = succ;
            //将上一个节点设置为当前个结点的上一个节点
            succ.prev = pred;
        }
        //列表容量加上数组长度
        size += numNew;
        modCount++;
        return true;
    }

    /**
     * 清空列表元素
     */
    public void clear() {
        // Clearing all of the links between nodes is "unnecessary", but:
        // - helps a generational GC if the discarded nodes inhabit
        //   more than one generation
        // - is sure to free memory even if there is a reachable Iterator
        //从链表头结点开始遍历
        for (Node<E> x = first; x != null; ) {
            //获取下一个节点
            Node<E> next = x.next;
            //当前节点的值设置为null
            x.item = null;
            //当前节点的下一个节点设置为null
            x.next = null;
            //当前节点的上一个节点设置为null
            x.prev = null;
            //下一个节点设置为当前节点
            x = next;
        }
        //头尾节点均设置为null
        first = last = null;
        //列表容量设置为0
        size = 0;
        modCount++;
    }


    // Positional Access Operations

    /**
     * 获取指定索引位置对应的值
     */
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }

    /**
     * 替换指定索引位置的元素为指定元素
     */
    public E set(int index, E element) {
        checkElementIndex(index);
        //获取指定索引位置对应的节点
        Node<E> x = node(index);
        //获取该节点对应的值
        E oldVal = x.item;
        //将指定的值赋值给该节点
        x.item = element;
        //返回指定索引位置的旧值
        return oldVal;
    }

    /**
     * 列表中插入指定元素到指定的位置
     * 将当前位置的元素（如果有）和任何后续元素向右移动（增加其索引）
     */
    public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    }

    /**
     * 删除指定索引位置的元素
     * 将当前位置的元素（如果有）和任何后续元素向左移动（减去其索引）
     */
    public E remove(int index) {
        checkElementIndex(index);
        //删除指定节点并返回该节点的值
        return unlink(node(index));
    }

    /**
     * 判断当前索引是否是列表的索引
     */
    private boolean isElementIndex(int index) {
        return index >= 0 && index < size;
    }

    /**
     * 判断参数是迭代器或添加操作的有效位置的索引
     */
    private boolean isPositionIndex(int index) {
        return index >= 0 && index <= size;
    }

    /**
     * 抛出日志
     */
    private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size;
    }
    
    //检测元素的索引是否合法
    private void checkElementIndex(int index) {
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
    //检测索引的位置是否合法
    private void checkPositionIndex(int index) {
        if (!isPositionIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    /**
     * 采用二分的方式查找指定索引对应的节点
     */
    Node<E> node(int index) {
        // assert isElementIndex(index);
        //如果指定的索引小于列表容量的一半（size >> 1相当于size/2)
        if (index < (size >> 1)) {
            //获取头结点
            Node<E> x = first;
            //从0到指定索引index正向循环
            for (int i = 0; i < index; i++)
                //当循环到index，得到index对应的节点
                x = x.next;//不断地得到当前节点的下一个节点然后赋值给当前节点
            return x;
        } else {//如果指定的索引大于列表容量的一半
            //获取头结点
            Node<E> x = last;
            //从列表容量-1(size - 1)到指定索引index反向循环
            for (int i = size - 1; i > index; i--)
                //当循环到index，得到index对应的节点
                x = x.prev;//不断地得到当前节点的上一个节点然后赋值给当前节点
            return x;
        }
    }

    // Search Operations

    /**
     * 返回指定元素在列表中第一次出现的位置索引，如果不包含则返回-1
     */
    public int indexOf(Object o) {
        //临时索引
        int index = 0;
        //如果指定元素为null
        if (o == null) {
            //从头结点开始正序遍历
            for (Node<E> x = first; x != null; x = x.next) {
                //如果当前节点对应的值为null
                if (x.item == null)
                    //返回临时索引
                    return index;
                //临时索引自增    
                index++;
            }
        } else {//如果指定元素不为null
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }

    /**
     * 返回指定元素在列表中最后一次出现的位置索引，如果不包含则返回-1
     */
    public int lastIndexOf(Object o) {
        //临时索引
        int index = size;
        //如果指定元素为null
        if (o == null) {
            //从尾结点开始正序遍历
            for (Node<E> x = last; x != null; x = x.prev) {
                index--;
                //如果当前节点对应的值为null
                if (x.item == null)
                    //返回临时索引
                    return index;
            }
        } else {//如果指定元素不为null
            for (Node<E> x = last; x != null; x = x.prev) {
                index--;
                if (o.equals(x.item))
                    return index;
            }
        }
        return -1;
    }

    // Queue operations.
    // 队列操作 JDK 1.5 新增

    /**
     * 检索但不删除此列表的头部（第一个元素）
     * 返回链表头结点的值/返回列表中的第一个值
     * @since 1.5
     */
    public E peek() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
    }

    /**
     * 检索但不删除此列表的头部（第一个元素）
     * 返回链表头结点的值/返回列表中的第一个值
     * @since 1.5
     */
    public E element() {
        return getFirst();
    }

    /**
     * 检索并删除此列表的头部（第一个元素）
     * 返回链表头结点的值/返回列表中的第一个值
     * @since 1.5
     */
    public E poll() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }

    /**
     * 检索并删除此列表的头部（第一个元素）
     * 返回链表头结点的值/返回列表中的第一个值
     * @since 1.5
     */
    public E remove() {
        return removeFirst();
    }

    /**
     * 添加指定元素到列表的末尾,并作为尾节点
     * @since 1.5
     */
    public boolean offer(E e) {
        return add(e);
    }

    // Deque operations
    //双端队列操作  FIFO、LIFO JDK 1.5 新增
    /**
     * 插入指定元素到列表的头部
     * @since 1.6
     */
    public boolean offerFirst(E e) {
        addFirst(e);
        return true;
    }

    /**
     * 插入指定元素到列表的尾部
     * @since 1.6
     */
    public boolean offerLast(E e) {
        addLast(e);
        return true;
    }

    /**
     * 检索但不删除此列表的头部（第一个元素），如果链表为null则返回null
     * @since 1.6
     */
    public E peekFirst() {
        final Node<E> f = first;
        return (f == null) ? null : f.item;
     }

    /**
     * 检索但不删除此列表的最后一个元素，如果链表为null则返回null
     * @since 1.6
     */
    public E peekLast() {
        final Node<E> l = last;
        return (l == null) ? null : l.item;
    }

    /**
     * 检索并删除此列表的头部（第一个元素），如果链表为null则返回null
     * @since 1.6
     */
    public E pollFirst() {
        final Node<E> f = first;
        return (f == null) ? null : unlinkFirst(f);
    }

    /**
     * 检索并删除此列表的最后一个元素，如果链表为null则返回null
     * @since 1.6
     */
    public E pollLast() {
        final Node<E> l = last;
        return (l == null) ? null : unlinkLast(l);
    }

    /**
     * 将元素推送到此列表所表示的堆栈上。 换句话说，将元素插入此列表的前面。
     * @since 1.6
     */
    public void push(E e) {
        addFirst(e);
    }

    /**
     * 弹出此列表所代表的堆栈中的元素。 换句话说，删除并返回此列表的第一个元素。
     * @since 1.6
     */
    public E pop() {
        return removeFirst();
    }

    /**
     * 删除此列表中第一次出现的指定元素（从头到尾遍历列表时）。 如果列表不包含该元素，则不会更改。
     * @since 1.6
     */
    public boolean removeFirstOccurrence(Object o) {
        return remove(o);
    }

    /**
     * 删除此列表中最后次出现的指定元素（从头到尾遍历列表时）。 如果列表不包含该元素，则不会更改。
     * @since 1.6
     */
    public boolean removeLastOccurrence(Object o) {
        //如果指定元素为null
        if (o == null) {
            //从尾到头开始遍历
            for (Node<E> x = last; x != null; x = x.prev) {
                //如果当前节点的值为null
                if (x.item == null) {
                    //删除该节点
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = last; x != null; x = x.prev) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 返回此列表中元素的列表迭代器（按正确顺序），从列表中的指定位置开始
     */
    public ListIterator<E> listIterator(int index) {
        checkPositionIndex(index);
        return new ListItr(index);
    }
    //列表迭代器
    private class ListItr implements ListIterator<E> {
        private Node<E> lastReturned;
        private Node<E> next;
        private int nextIndex;
        private int expectedModCount = modCount;

        ListItr(int index) {
            // assert isPositionIndex(index);
            next = (index == size) ? null : node(index);
            nextIndex = index;
        }

        public boolean hasNext() {
            return nextIndex < size;
        }

        public E next() {
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();

            lastReturned = next;
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        }

        public boolean hasPrevious() {
            return nextIndex > 0;
        }

        public E previous() {
            checkForComodification();
            if (!hasPrevious())
                throw new NoSuchElementException();

            lastReturned = next = (next == null) ? last : next.prev;
            nextIndex--;
            return lastReturned.item;
        }

        public int nextIndex() {
            return nextIndex;
        }

        public int previousIndex() {
            return nextIndex - 1;
        }

        public void remove() {
            checkForComodification();
            if (lastReturned == null)
                throw new IllegalStateException();

            Node<E> lastNext = lastReturned.next;
            unlink(lastReturned);
            if (next == lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = null;
            expectedModCount++;
        }

        public void set(E e) {
            if (lastReturned == null)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.item = e;
        }

        public void add(E e) {
            checkForComodification();
            lastReturned = null;
            if (next == null)
                linkLast(e);
            else
                linkBefore(e, next);
            nextIndex++;
            expectedModCount++;
        }

        public void forEachRemaining(Consumer<? super E> action) {
            Objects.requireNonNull(action);
            while (modCount == expectedModCount && nextIndex < size) {
                action.accept(next.item);
                lastReturned = next;
                next = next.next;
                nextIndex++;
            }
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
	
	//链表节点类
    private static class Node<E> {
    	 //当前节点的值
        E item;
        //下一个节点
        Node<E> next;
        //上一个节点
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }

    /**
     * @since 1.6
     */
    public Iterator<E> descendingIterator() {
        return new DescendingIterator();
    }

    /**
     * 适配器通过列表迭代器ListItr提供降序迭代器
     */
    private class DescendingIterator implements Iterator<E> {
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() {
            return itr.hasPrevious();
        }
        public E next() {
            return itr.previous();
        }
        public void remove() {
            itr.remove();
        }
    }

    //浅拷贝
    @SuppressWarnings("unchecked")
    private LinkedList<E> superClone() {
        try {
            return (LinkedList<E>) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }

    /**
     * 返回浅拷贝实例
     */
    public Object clone() {
        LinkedList<E> clone = superClone();

        // Put clone into "virgin" state
        clone.first = clone.last = null;
        clone.size = 0;
        clone.modCount = 0;

        // Initialize clone with our elements
        for (Node<E> x = first; x != null; x = x.next)
            clone.add(x.item);

        return clone;
    }

    /**
     * 返回包含列表元素的一个有序数组（从列表开始到结束）
     */
    public Object[] toArray() {
        Object[] result = new Object[size];
        int i = 0;
        for (Node<E> x = first; x != null; x = x.next)
            result[i++] = x.item;
        return result;
    }

    /**
     * 返回一个数组，使用运行时确定类型，该数组包含这个列表中的所有元素（从第一到最后一个元素）
     * 返回的数组容量由参数数组的长度和列表容量较大值确定
     */
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        ////参数数组的长度小于集合的容量
        if (a.length < size)
            // 通过反射创建一个为列表容量大小的新数组，数组类型为传入数组的类型
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        int i = 0;
        Object[] result = a;
        //从头到尾循环链表，并把对应的值赋值给创建的新数组
        for (Node<E> x = first; x != null; x = x.next)
            result[i++] = x.item;
        //如果数组长度大于列表容量,将列表容量大小位置的数组对应的值置为null
        if (a.length > size)
            a[size] = null;

        return a;
    }

    private static final long serialVersionUID = 876323262645176354L;

    /**
     * 序列化默认的方法，保存数组实例的状态到一个流（即序列化）
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out size
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Node<E> x = first; x != null; x = x.next)
            s.writeObject(x.item);
    }

    /**
     * 序列化默认的方法，从流中读取数组实例(反序列化)
     */
    @SuppressWarnings("unchecked")
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i = 0; i < size; i++)
            linkLast((E)s.readObject());
    }

    /**
     * Java8新增，生成Spliterator接口，有点类似nio里的selector
     */
    @Override
    public Spliterator<E> spliterator() {
        return new LLSpliterator<E>(this, -1, 0);
    }

    /** Spliterator的变体 */
    static final class LLSpliterator<E> implements Spliterator<E> {
        static final int BATCH_UNIT = 1 << 10;  // batch array size increment
        static final int MAX_BATCH = 1 << 25;  // max batch array size;
        final LinkedList<E> list; // null OK unless traversed
        Node<E> current;      // current node; null until initialized
        int est;              // size estimate; -1 until first needed
        int expectedModCount; // initialized when est set
        int batch;            // batch size for splits

        LLSpliterator(LinkedList<E> list, int est, int expectedModCount) {
            this.list = list;
            this.est = est;
            this.expectedModCount = expectedModCount;
        }

        final int getEst() {
            int s; // force initialization
            final LinkedList<E> lst;
            if ((s = est) < 0) {
                if ((lst = list) == null)
                    s = est = 0;
                else {
                    expectedModCount = lst.modCount;
                    current = lst.first;
                    s = est = lst.size;
                }
            }
            return s;
        }

        public long estimateSize() { return (long) getEst(); }

        public Spliterator<E> trySplit() {
            Node<E> p;
            int s = getEst();
            if (s > 1 && (p = current) != null) {
                int n = batch + BATCH_UNIT;
                if (n > s)
                    n = s;
                if (n > MAX_BATCH)
                    n = MAX_BATCH;
                Object[] a = new Object[n];
                int j = 0;
                do { a[j++] = p.item; } while ((p = p.next) != null && j < n);
                current = p;
                batch = j;
                est = s - j;
                return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED);
            }
            return null;
        }

        public void forEachRemaining(Consumer<? super E> action) {
            Node<E> p; int n;
            if (action == null) throw new NullPointerException();
            if ((n = getEst()) > 0 && (p = current) != null) {
                current = null;
                est = 0;
                do {
                    E e = p.item;
                    p = p.next;
                    action.accept(e);
                } while (p != null && --n > 0);
            }
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

        public boolean tryAdvance(Consumer<? super E> action) {
            Node<E> p;
            if (action == null) throw new NullPointerException();
            if (getEst() > 0 && (p = current) != null) {
                --est;
                E e = p.item;
                current = p.next;
                action.accept(e);
                if (list.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            }
            return false;
        }

        public int characteristics() {
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        }
    }

}
```


##容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）

##List,Set,Map的区别

##List和Map的实现方式以及存储方式

##HashMap的实现原理

##HashMap数据结构？

##HashMap源码理解

##HashMap如何put数据（从HashMap源码角度讲解）？

##HashMap怎么手写实现？

##ConcurrentHashMap的实现原理

##ArrayMap和HashMap的对比

##HashTable实现原理

##TreeMap具体实现

##HashMap和HashTable的区别

##HashMap与HashSet的区别

##HashSet与HashMap怎么判断集合元素重复？

##集合Set实现Hash怎么防止碰撞

##ArrayList和LinkedList的区别，以及应用场景

##数组和链表的区别

##二叉树的深度优先遍历和广度优先遍历的具体实现

##堆的结构

##堆和树的区别

##堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？

##什么是深拷贝和浅拷贝

##手写链表逆序代码

##讲一下对树，B+树的理解

##讲一下对图的理解

##判断单链表成环与否？

##链表翻转（即：翻转一个单项链表）

##合并多个单有序链表（假设都是递增的）



