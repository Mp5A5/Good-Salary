<center>数据结构</center>
=
##常用数据结构简介
####简介
数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。  

数据结构的基本功能

* 如何插入一条新的数据项
* 如何寻找某一特定的数据项
* 如何删除某一特定的数据项
* 如何迭代的访问各个数据项，以便进行显示或其他操作

####常用的数据结构

![avatar](pic/p79.png)

这几种结构优缺点如下：先有个大概印象，后面会详细讲解！！！

![avatar](pic/p80.png)

####算法
算法简单来说就是解决问题的步骤。  
在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。  

1.算法的5个特征

* 有穷性：对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。
* 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。
* 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。
* 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。
* 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。

2.算法的设计原则

* 正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：
1. 程序语法错误。
2. 程序对于几组输入数据能够得出满足需要的结果。
3. 程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果。
4. 程序对于一切合法的输入数据都能得到满足要求的结果。
5. 通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。
* 可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。
* 健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。
* 高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。  

前面三点 正确性，可读性和健壮性相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。  
相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；
表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；  
复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。

然后我们在说说算法的存储量，包括：

* 程序本身所占空间；
* 输入数据所占空间；
* 辅助变量所占空间；

一个算法的效率越高越好，而存储量是越低越好。

##并发集合了解哪些？

##列举java的集合以及集合之间的继承关系
![avatar](pic/p81.png )
##### Iterable
Iterator是迭代器类，而Iterable是为了只要实现该接口就可以使用foreach，进行迭代.
Iterable中封装了Iterator接口，只要实现了Iterable接口的类，就可以使用Iterator迭代器了。
实现此接口允许对象成为“for-each loop”语句的目标

``` java
public interface Iterable<T> {
    
    //返回类型为T元素的迭代器
    Iterator<T> iterator();

    //对Iterable的每个元素执行给定的操作，直到所有元素都被处理或引发异常。 除非实现类另有规定，否则按照迭代的顺序执行操作（如果指定了迭代顺序）。 动作抛出的异常被抛出给调用者。
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }

	 //在Iterable描述的元素上创建一个Iterable
    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```
##### Iterator
一个集合的迭代器。 Iterator替代Enumeration在Java集合框架。 迭代器有两个方面不用于Enumeration：

* 迭代器允许调用者在具有明确定义的语义的迭代期间从底层集合中删除元素。
* 方法名称已得到改进。

此接口是成员Java Collections Framework 。

``` java
public interface Iterator<E> {

    boolean hasNext();

   
    E next();

    //从底层集合中删除此迭代器返回的最后一个元素（可选操作）。此方法只能调用一次next() 。 如果底层集合在迭代过程中以任何方式进行修改而不是通过调用此方法，则迭代器的行为是未指定的。
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    //对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 如果指定了该顺序，则按迭代的顺序执行操作。 动作抛出的异常被抛出给调用者。
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```
#####Collection
集合体系中的根接口。 集合表示一组称为其元素的对象。 有些集合允许有重复元素而其他则不允许。 有些是有序的，有些是无序的。 JDK不提供此接口的任何直接实现：它提供了更具体的子接口（如Set和List）的实现。 此接口通常用于传递集合并在需要最大通用性的情况下对其进行操作。  
包或多个集合（可能包含重复元素的无序集合）应直接实现此接口。  
所有通用Collection实现类（通常通过其子接口间接实现Collection）应提供两个“标准”构造函数：void（无参数）构造函数，它创建一个空集合，以及一个有参构造函数，其中一个参数类型 Collection，使用与其参数相同的元素创建新集合。 实际上，后一个构造函数允许用户复制任何集合，从而生成所需实现类型的等效集合。 没有办法强制执行此约定（因为接口不能包含构造函数），但Java平台库中的所有通用Collection实现都符合。  
如果此集合不支持该操作，则指定此接口中包含的“破坏性”方法（即修改其操作集合的方法）将抛出UnsupportedOperationException。 如果是这种情况，调用对集合没有影响，则这些方法可能（但不是必须）抛出UnsupportedOperationException。 例如，如果要添加的集合为空，则可以（但不是必须）在不可修改的集合上调用addAll（Collection）方法抛出异常。  
某些集合实现对它们可能包含的元素有限制。 例如，某些实现禁止null元素，并且一些实现对其元素的类型有限制。 尝试添加不合格的元素会引发未经检查的异常，通常是NullPointerException或ClassCastException。 尝试查询不合格元素的可能会引发异常，或者它可能只是返回false; 一些实现将展示前一种行为，一些将展示后者。 更一般地，尝试对不合格的元素进行操作，其完成不会导致将不合格的元素插入到集合中，可以在实现的选择中抛出异常或者它可以成功。 此类异常在此接口的规范中标记为“可选”。  
由每个集合决定自己的同步策略。 在实现没有更强的保证的情况下，未定义的行为可能是由于另一个线程正在调用集合上的任何方法的调用引起的; 这包括直接调用，将集合传递给可能执行调用的方法，以及使用现有迭代器来检查集合。  
Collections框架接口中的许多方法都是根据equals方法定义的。 例如，contains（Object o）方法的规范：“当且仅当此集合包含至少一个元素e时才返回true（o == null？e == null：o.equals（e））“。 不应将此规范解释为使用非null参数o调用Collection.contains将导致对任何元素e调用o.equals（e）。 实现可以自由地优化，从而避免等同调用，例如，首先比较两个元素的哈希码。 （Object.hashCode（）规范保证具有不等哈希码的两个对象不能相等。）一般地，各种集合框架接口的实现可以自由地利用底层Object方法的指定行为，只要实现者认为它是合适的  。  
执行集合的递归遍历的某些集合操作可能会失败，而自引用实例的例外情况是集合直接或间接包含自身。 这包括clone（），equals（），hashCode（）和toString（）方法。 可以可选地处理自引用场景，但是大多数当前实现不这样做。  
此接口是Java集合框架的成员。
#### ArrayList
![avatar](pic/p82.png )
##### AbstractList
此类提供List接口的骨干实现，以最大限度地减少实现由“随机访问”数据存储（例如数组）支持的此接口所需的工作量。对于顺序访问数据（例如链接列表），应优先使用AbstractSequentialList，而不是此类。  
要实现不可修改的列表，程序员只需要扩展此类并提供get（int）和size（）方法的实现。  
要实现可修改的列表，程序员必须另外覆盖set（int，E）方法（否则会抛出UnsupportedOperationException）。如果列表是可变大小的，则程序员必须另外覆盖add（int，E）和remove（int）方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和集合构造函数。  
与其他抽象集合实现不同，程序员不必提供迭代器实现;迭代器和列表迭代器是由这个类在“随机访问”方法之上实现的：get（int），set（int，E），add（int，E）和remove（int）。  
此接口是Java集合框架的成员。 
在这个抽象类中，我们可以发现，很多方法的实现，都是抛出一个UnsupportedOperationException异常，等待具体的实现类来实现．  
未实现的方法：  

* 添加元素 add(E e)、add(int index,  E element)
* 替换指定索引位置的元素 set(int index, Eelement) 
* 删除指定所引处的元素 remove(int index) 
* 凡是涉及到与数据存储结构有关的方法均不能实现

在indexOf方法的实现中，我们可以看到，它是采用的顺序遍历的方式，这是最常见但是同时效率也是最低的遍历方式．

``` java
/**
     * 功能：获取集合第一次出现的指定元素的索引
     * 实现：
     * 1.获取List集合特有迭代器listIterator
     * 2.如果待查找参数为null，遍历集合找到第一个为null的元素并返回，如果没找到返回-1
     * 3.如果待查找参数不为null，遍历集合使用equals方法找到第一个相同元素并返回，没有返回-1
     */
    public int indexOf(Object o) {
        ListIterator<E> it = listIterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return it.previousIndex();
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return it.previousIndex();
        }
        return -1;
```
同时，我们也能看到，AbstractList是允许其中的元素为null的．如果找到元素，则返回其所在的位置，否则返回-1.
在各种查找算法中，性能最好的，似乎就是O(logn)了．但是这些算法都需要数据是有序的．那么存不存在一种算法，即使数据是无序的，其时间复杂度也比O(n)好呢?
确实存在，那就是哈希算法，如果能够确定有效的哈希函数，那么查找性能是O(1)．远比O(n)要好的多．可是，如何设计这么一个高效的哈希函数呢?
但是，使用这种方式，我们能保证，读取的时候，如果按照索引来读取，读取到的元素的顺序，跟元素被插入时的顺序相同．而如果使用哈希函数，则不能保证这一点．
AbstractList中，还为我们提供了一个获取元素的最后出现位置的方法，跟上面那个获取第一次出现位置的方法没什么不同，只不过是从后面开始遍历的．

``` java
/**
     * 功能：获取集合最后一次出现指定元素的索引
     * 实现：
     * 1.同上一个方法类似
     */
    public int lastIndexOf(Object o) {
        ListIterator<E> it = listIterator(size());
        if (o==null) {
            while (it.hasPrevious())
                if (it.previous()==null)
                    return it.nextIndex();
        } else {
            while (it.hasPrevious())
                if (o.equals(it.previous()))
                    return it.nextIndex();
        }
        return -1;
    }
```
除此之外, AbstractList还提供了一个iterator()方法，这个方法相信各位已经很熟悉了，它会获取一个实现了Iterator接口的Itr类用于迭代当前的List.

```java
 //继承自父类的迭代器 iterator()
/**
     * 功能：获取迭代器
     * 实现：
     * 1.通过匿名内部类实现迭代器，创建迭代器Iterator实现类并返回
     */
    public Iterator<E> iterator() {
        return new Itr();
    }
    private class Itr implements Iterator<E> {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        /**
         * 元素索引指针
         */
        int cursor = 0;
 
        /**
         * Index of element returned by most recent call to next or
         * previous.  Reset to -1 if this element is deleted by a call
         * to remove.
         */
        /**
         *最近一次调用返回到下一个或上一个的元素索引。 如果通过删除调用删除此元素，则重置为-1。
         * 通俗点说，他保存cursor操作前的索引
         */
        int lastRet = -1;
 
        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        /**
         * 迭代器认为后备列表应具有的modCount值。 如果违反了此期望，则迭代器已检测到并发修改。
         */
        int expectedModCount = modCount;
 
        /**
         * 功能：检查是否还有下一个元素
         * 实现：
         * 1.迭代器每次迭代出一个元素时元素索引指针cursor都会下移
         * 2.通过检查元素指针cursor是否等于集合长度判断时候还有元素
         */
        public boolean hasNext() {
            return cursor != size();
        }
 
        /**
         * 功能：获取当前元素索引指针(cursor)处的元素
         * 实现：
         * 1.检测是否发生并发修改，并发修改则抛出异常
         * 2.获取当前元素索引指针所指向的元素，保存当前索引到lastRet、cursor++
         * 3.返回回去到的元素
         */
        public E next() {
            checkForComodification();
            try {
                int i = cursor;
                E next = get(i);
                lastRet = i;
                cursor = i + 1;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }
 
        /**
         * 功能：删除lastRet索引处的元素
         * 实现：
         * 1.对lastRet进行和是否并发修改进行检查
         * 2.调用AbstractList超类的remove方法删除lastRet索引处的元素
         * 3.如果元素索引指针cursor大于lastRet，则将cursor迁移一位，lastRet置为-1
         */
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
 
            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }
 
        /**
         * 功能：检查是否发生并发修改
         * 实现：
         * 1.通过modCount和expectedModCount是否相等检查
         */
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

```
但是，它不是线程安全的．也就是说，如果我们已经获取到了Iterator了，而此后这个List被其他的线程修改了，那么会抛出运行时异常．
它还提供了一个listIterator()的方法，它会返回一个实现了ListIterator接口的ListItr类.那么Itr和ListItr有什么区别呢?

```java
/**
     * 功能：List特有迭代器
     * 实现：调用listIterator(final int index)获取迭代器
     * 注：每次调用，迭代器都能从头开始
     */
    public ListIterator<E> listIterator() {
        return listIterator(0);
    }
 
    /**
     * 功能：获取List集合特有迭代器
     * 实现：
     * 1.检查索引范围无误后创建并返回迭代器实现类对象
     */
    public ListIterator<E> listIterator(final int index) {
        rangeCheckForAdd(index);
 
        return new ListItr(index);
    }
 
    private class ListItr extends Itr implements ListIterator<E> {
        /**
         * ListItr类有参构造器，初始化开始元素索引指针位置
         */
        ListItr(int index) {
            cursor = index;
        }
 
        /**
         * 功能：检查cursor指针前面是否还有元素
         * 实现:
         * 1.通过cursor是否等于0判断
         */
        public boolean hasPrevious() {
            return cursor != 0;
        }
 
        /**
         * 功能：获取前一个元素
         * 实现：
         * 1.检查是否发生并发操作，是则抛异常
         * 2.将现在cursor向前移动一位，获取元素并返回
         */
        public E previous() {
            checkForComodification();
            try {
                int i = cursor - 1;
                E previous = get(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }
 
        /**
         * 功能：获取当前指针索引
         */
        public int nextIndex() {
            return cursor;
        }
 
        /**
         * 功能：获取上一个元素指针索引
         */
        public int previousIndex() {
            return cursor-1;
        }
 
        /**
         * 功能：替换元素
         * 实现：
         * 1.检查lastRet是否越界，检查时候并发操作
         * 2.调用AbstractList的set方法进行替换
         */
        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();
 
            try {
                AbstractList.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
 
        /**
         * 功能：添加元素
         * 实现：
         * 1.检查是否并发操作，是则抛异常
         * 2.调用AbstractList的add方法进行添加操作，并将元素指针索引 + 1
         */
        public void add(E e) {
            checkForComodification();
 
            try {
                int i = cursor;
                AbstractList.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
```
我们从名字上应该也能看出来，Itr类是ListItr的父类，它实现了Iterator接口，并实现了了一下几个方法:hasNext, next, remove, checkForComodification.我们可以看到，它只能向后遍历(这里称向索引大的元素遍历称为向后遍历),并且，只能从数据容器的起点开始读，也只能移除某个元素，而无法在迭代的过程中，重新设置此元素的值．
而ListItr呢，继承了Itr的那些特性，同时通过实现ListIterator类，增加了自己的特性．它相对于Itr增加了如下方法:hasPrevious, previous, set, add.从这些函数的名字中，我们就可以知道，它支持向前遍历，在遍历的过程中重新设置元素的值，以及在遍历过程中增加元素．
并且，我们可以看到它的构造函数声明如下:

``` java 
ListItr(int index) {
   cursor = index;
}
```
我们可以看到，我们可以从指定的位置开始进行迭代．
在Itr和ListItr的实现中，我们可以看到，基本上每个方法的实现，都会调用一个叫做checkForComodification()的方法．这个方法是干什么的呢?Itr和ListItr中，都会维护一个变量，叫做expectedModCount，它记录了它认为List被修改的次数，刚开始时，它被初始化为List被修改的次数．checkForComodification()方法，通过将这个变量，和另一个表示List实际被修改的次数的叫做modCount的变量比较，就能得知，在获取到Iterator之后，List是否被修改过，进而抛出ConcurrentModificationException异常．
当然，前面也介绍了,Itr和ListItr实际上也可以在遍历过程中修改List，所以我们在那些修改List的结构的方法中，就需要再同步一下expectedModCount和modCount的值．防止是由于Iterator本身修改了List而导致抛出ConcurrentModificationException.
以Itr的remove为例:

``` java
public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }
```
那modCount这个变量的值都是在什么情况下会被修改呢?
当我们的子类在实现AbstractList时，对于那些修改List结构的方法，比如会造成List的大小发生了变化的函数，那么我们可以在这些方法内部，让modCount+1.来实现让Iterator发现List被修改过并抛出错误的功能．
我们为什么需要让Iterator发现List被修改过并抛出异常呢?这是为了防止在并发的环境下，造成不确定的问题．

AbstractList还给我们提供了一个removeRange方法，通过这个方法，我们可以删除一定范围内的元素，并将此范围右侧的元素左移(但是我并没有发现它实现了将元素左移的功能).此方法接受两个参数，一个是fromIndex,另一个是toIndex，分别代表要删除的元素的范围的起点和终点，不包含终点．如果你指定的fromIndex和toIndex相同，那么并不会删除那一个特定的元素，而是会一点作用没有，相当于并没有调用这个函数．

``` java 
* 功能：删除集合的所有元素
     * 实现：
     * 1.调用removeRange方法删除集合整个范围内的所有元素
     */
    public void clear() {
        removeRange(0, size());
    }
 
    /**
     * 功能：删除指定范围内的所有元素
     * 实现：
     * 1.通过特有迭代器获取fromIndex索引处开始到结尾的所有元素
     * 2.通过for循环，逐个删除元素
     */
    protected void removeRange(int fromIndex, int toIndex) {
        ListIterator<E> it = listIterator(fromIndex);
        for (int i=0, n=toIndex-fromIndex; i<n; i++) {
            it.next();
            it.remove();
        }
    }

```

AbstractList提供了一个addAll(int index, Collection<? extends E> c)方法，

``` java
/**
     * 功能：在指定位置添加一个集合的元素
     * 实现：
     * 1.检查是否并发操作
     * 2.遍历参数集合并调用add(int index, E e)方法进行这个添加，每次添加后索引+1
     */
    public boolean addAll(int index, Collection<? extends E> c) {
        rangeCheckForAdd(index);
        boolean modified = false;
        for (E e : c) {
            add(index++, e);
            modified = true;
        }
        return modified;
    }

```

AbstractList提供了一个subList()方法，它接受两个参数，一个是AbstractList开始切分位置，另一个是AbstractList结束拆分的位置．
这个方法，会返回一个SubList，如果当前AbstractList实现了RandomAccess接口，那么就返回RandomAccessSubList．
那么SubList又是个什么鬼呢?
AbstractList的subList()方法，在形成子列表时，并不会创建一个新的AbstractList,并将父AbstractList中的相应的元素拷贝进去．那它是怎样做的呢?
它是写了一个Wrapper,这个Wrapper就是SubList．既然是一个Wrapper,那么它内部肯定是封装了一个AbstractList实例，并维护了一些其他信息．我们来看一下这个类的属性，以及其构造方法:

```java
class SubList<E> extends AbstractList<E> {
    private final AbstractList<E> l;
    private final int offset;
    private int size;

    SubList(AbstractList<E> list, int fromIndex, int toIndex) {
        if (fromIndex < 0)
            throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
        if (toIndex > list.size())
            throw new IndexOutOfBoundsException("toIndex = " + toIndex);
        if (fromIndex > toIndex)
            throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                               ") > toIndex(" + toIndex + ")");
        l = list;
        offset = fromIndex;
        size = toIndex - fromIndex;
        this.modCount = l.modCount;
    }
```
其中l这个AbstractList，就是要获取子列表的那个AbstractList的实例．offset这个属性，代表的是，从哪里开始是子列表．就是subList()方法的fromIndex参数．size这个属性，代表的是子列表的长度，就是subList的toIndex - fromIndex的值．
从其他的函数中，我们可以发现，实际上，修改这个SubList就是修改的原AbstractList．同时，我们也会发现，如果我们在获取到SubList之后，做了一些会造成AbstractList的modCount属性发生变化的操作，那么就会让SubList失效并抛出ConcurrentModificationException了．
SubList能改变原集合的值，所以我们在使用时要慎重，如果不想改变原集合的值，那么我们就要把这个subList保存到另一个集合中使用它。
##### AbstractCollection
此类提供Collection接口的骨干实现，以最大限度地减少实现此接口所需的工作量。  
要实现不可修改的集合，程序员只需要扩展此类并提供迭代器和大小方法的实现。 （迭代器方法返回的迭代器必须实现hasNext和next。）  
要实现可修改的集合，程序员必须另外覆盖此类的add方法（否则会抛出UnsupportedOperationException），并返回迭代器方法，必须实现其remove方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和Collection构造函数。  
此类中每个非抽象方法的文档详细描述了它的实现。如果正在实施的集合允许更有效的实现，则可以覆盖这些方法中的每一个。  
此接口是Java集合框架的成员。

``` java
public abstract class AbstractCollection<E> implements Collection<E> {
   
    protected AbstractCollection() {
    }

    public abstract Iterator<E> iterator();

    public abstract int size();
	
	//判断集合是否为空
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * 判断是否包含指定的元素
     * （1）如果参数为null，查找值为null的元素，如果存在，返回true，否则返回false。
     * （2）如果参数不为null，则根据equals方法查找与参数相等的元素，如果存在，则返回true，否则返回false。
     * 注意：这里必须对null单独处理，否则null.equals会报空指针异常
     */
    public boolean contains(Object o) {
        Iterator<E> it = iterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return true;
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return true;
        }
        return false;
    }

    
    /**
     * 功能：将集合元素转换为数组
     * 实现：
     * （1）创建一个数组，大小为集合中元素的数量
     * （2）通过迭代器遍历集合，将当前集合中的元素复制到数组中（复制引用）
     * （3）如果集合中元素比预期的少，则调用Arrays.copyOf()方法将数组的元素复制到新数组中，并返回新数组
     * （4）如果集合中元素比预期的多，则调用finishToArray方法生成新数组，并返回新数组，否则返回（1）中创建的数组
     */
    public Object[] toArray() {
        Object[] r = new Object[size()];
        Iterator<E> it = iterator();
        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) // 比预想的元素要少
                return Arrays.copyOf(r, i);
            r[i] = it.next();
        }
        return it.hasNext() ? finishToArray(r, it)/*比预想的元素多*/ : r;
    }
    
	/**
	*如果参数数组的长度小于集合的长度，则用反射创建一个T类型的数组，否则就是用这个数组的引用，
	*还是通过迭代器遍历数组范围的集合元素将其元素 引用复制到数组当中，判断集合的元素是
	*否大于小于等于预期大小（size的大小）分不同的处理情况来处理。
	*/
	//功能：通过泛型约束返回指定类型的数组
   // (1) 如果参数数组长度大于等于集合的长度，则将当前集合的元素复制到参数数组当中
   // (2) 如果参数数组的长度小于集合的长度，则通过数组的反射创建T类型的新数组来容纳集合元素
    public <T> T[] toArray(T[] a) {
        // Estimate size of array; be prepared to see more or fewer elements
        int size = size();
        T[] r = a.length >= size ? a :
                  (T[])java.lang.reflect.Array
                  .newInstance(a.getClass().getComponentType(), size);
        Iterator<E> it = iterator();

        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) { // fewer elements than expected 在数组长度范围内出现没有下一个元素的情况，说明集合大小小于数组的长度
                if (a == r) { //如果a 和 r 所引用的数组相同，则将剩下的数组元素都赋值为null，作为集合元素的结束标志
                    r[i] = null; // null-terminate
                } else if (a.length < i) {//如果参数数组的长度小于集合的长度，也就是r是通过反射新创建的数组，则通过Arrays.copyOf方法截短返回
                    return Arrays.copyOf(r, i);
                } else {//r是通过反射新创建的数组，但是参数数组长度大于集合长度，
                          //即a的长度大于新创建的r数组的长度(这在单线程情况下不可能发生，但是在
                          //并发情况下参数数组的长度可能发生变化)，则将r数组复制到a数组当中，并
                          //将参数数组多的元素设置为null
                    System.arraycopy(r, 0, a, 0, i);//将创建的r数组所有元素复制到a数组当中
                    if (a.length > i) {
                        a[i] = null;
                    }
                }
                return a;
            }
            r[i] = (T)it.next(); //类型转换，可能会抛出ClassCastException异常
        }
        // more elements than expected
        // 如果集合长度大于数组的长度则拓展数组r，否则(集合长度正好等于数组的长度)直接返回数组r
        return it.hasNext() ? finishToArray(r, it) : r;
    }

	/**
	*数组的最大可分配大小为整数的最大值，但是有些虚拟机会保留几个字节大小的空间存储头部，
	*所以为了保险起见最大可分配的数组大小为整数最大值-8，否则会抛出内存溢出错误
	*/
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    
	/**
     *  （1）对数组进行扩容：即创建一个更长的数组，然后将原数组的内容复制到新数组中
     *  （2）扩容大小：cap + cap/2 +1
     *  （3）扩容前需要先判断是否数组长度是否溢出
     */
    private static <T> T[] finishToArray(T[] r, Iterator<?> it) {
        int i = r.length;//记录数组有效长度
        while (it.hasNext()) {
            int cap = r.length;//数组最大可用容量
            if (i == cap) {//当数组有效长度和数组最大可用容量相等时，再次扩容
                int newCap = cap + (cap >> 1) + 1; //扩容为 cap + cap/2 +1
                // overflow-conscious code
                if (newCap - MAX_ARRAY_SIZE > 0)//新扩大的容量发生溢出
                    newCap = hugeCapacity(cap + 1);
                //Arrays.copyOf方法内部创建了一个新的长度为newCap数组，
                //并将元素复制到这个新的数组当中，底层调用的是System.arraycopy native方法
                r = Arrays.copyOf(r, newCap);
            }
            r[i++] = (T)it.next();//数组有效长度自增，并复制引用
        }
        // trim if overallocated 截短数组长度到有效长度
        return (i == r.length) ? r : Arrays.copyOf(r, i);
    }

    /**
     * 判断数组容量是否溢出，最大为整型数据的最大值
     */
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow 超出整型的最大值则数值溢出为负值
            throw new OutOfMemoryError
                ("Required array size too large");
        return (minCapacity > MAX_ARRAY_SIZE) //如果大于最大容量则返回整数的最大值，否则返回集合的最大容量。
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    // Modification Operations
    
	 //未实现的方法
    //子类必须以自己的方式实现这两个方法。除此外，AbstractCollection 中默认不支持添加单个元素，如果直接调用 add(E) 方法，会报错：  因此，如果子类是可添加的数据结构，需要自己实现 add(E) 方法  
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }

    /**
     * 集合允许null元素
     * 功能：移除指定元素
     * （1）如果参数为null，则找到第一个值为null的元素，并将其删除，返回true，如果不存在null的元素，返回false。
     * （2）如果参数不为null，则根据equals方法找到第一个与参数相等的元素，并将其删除，返回true，如果找不到，返回false。
     */
    public boolean remove(Object o) {
        Iterator<E> it = iterator();
        if (o==null) {
            while (it.hasNext()) {
                if (it.next()==null) {
                    it.remove();
                    return true;
                }
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next())) {
                    it.remove();
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * 遍历参数集合，依次判断参数集合中的元素是否在当前集合中，
     * 只要有一个不存在，则返回false
     * 如果参数集合中所有的元素都在当前集合中，则返回true
     */
    public boolean containsAll(Collection<?> c) {
        for (Object e : c)
            if (!contains(e))
                return false;
        return true;
    }

    /**
     * 遍历参数集合，依次将参数集合中的元素添加当前集合中
     */
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }

    /**
     * 功能：移除参数集合的元素
     * （1）获取当前集合的迭代器进行遍历
     * （2）如果当前集合中的元素包含在参数集合中，则删除当前集合中的元素
     *  注：只要参数集合中有任何一个元素在当前元素中，则返回true，表示当前集合有发送变化，否则返回false。
     */
    public boolean removeAll(Collection<?> c) {
        boolean modified = false;
        Iterator<?> it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

    /***
     * 功能：求参数集合与当前集合的交集
     * （1）获取当前集合的迭代器进行遍历
     * （2）如果当前集合中的元素不在参数集合中，则将其移除。
     *  注意：如果当前集合是参数集合中的子集，则返回false，表示当前集合未发送变化，否则返回true。
     */
    public boolean retainAll(Collection<?> c) {
        boolean modified = false;
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            if (!c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }

     //删除所有元素
    public void clear() {
        Iterator<E> it = iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
    }


    public String toString() {
        Iterator<E> it = iterator();
        if (! it.hasNext())
            return "[]";

        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? "(this Collection)" : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

}
```  
#####RandomAccess
> 标记接口，Marker interface，它们是一类没有定义任何接口方法的接口，表现为一个空接口 
没有接口方法意味着实现该接口的类无需实现任何接口方法，仅仅作为一种标记，以供其他方法判断 
作用就是当某个类实现这个接口后即拥有了这个接口的功能，Java 虚拟机在运行时会识别到它 
标记接口是Java的语言特性 。  

> 在计算机科学中，随机访问（RandomAccess）是从大量的可寻址元素的数据中访问任何元素大致和访问其他元素一样简洁有效，不管多少元素在这个集合中。与随机访问相反的是顺序访问（SequenceAccess）

RandomAccess 就是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机和顺序访问的List中性能更加高效（在Collections二分查找时）。 
Collections的binarySearch方法：

``` java
public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {
    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}
```
在进行二分查找时，首先判断list是否实现了RandomAccess，然后选择执行最优算法。 
如果集合类是RandomAccess的实现，则尽量用for(int i = 0; i < size; i++) 即for循环来遍历，而不是用Iterator 
迭代器来进行迭代。
> JDK中说的很清楚，在对List特别是Huge size的List的遍历算法中，要尽量来判断是属于RandomAccess(如：ArrayList)还是SequenceAccess(如：LinkedList)

``` java
/**
 * Marker interface used by <tt>List</tt> implementations to indicate that
 * they support fast (generally constant time) random access.  The primary
 * purpose of this interface is to allow generic algorithms to alter their
 * behavior to provide good performance when applied to either random or
 * sequential access lists.
 * List实现所使用的标记接口，用来表明实现了这些接口的list支持快速（通常是常数时间）随机访问。 
 * 这个接口的主要目的是允许一般的算法更改它们的行为，以便在随机或者顺序存取列表时能提供更好的性能
 * <p>The best algorithms for manipulating random access lists (such as
 * <tt>ArrayList</tt>) can produce quadratic behavior when applied to
 * sequential access lists (such as <tt>LinkedList</tt>).  Generic list
 * algorithms are encouraged to check whether the given list is an
 * <tt>instanceof</tt> this interface before applying an algorithm that would
 * provide poor performance if it were applied to a sequential access list,
 * and to alter their behavior if necessary to guarantee acceptable
 * performance.
 * 操作随机访问列表（如ArrayList）的最佳算法在应用于顺序存取列表时，有可能产生二次项行为。
 * 泛型算法列表鼓励在将某个算法应用于顺序存取列表可能导致差的性能之前，先检查给定的列表是
 * 否是这个接口的一个实例，并在需要时去改变这些算法的行为以保证性能。
 * <p>It is recognized that the distinction between random and sequential
 * access is often fuzzy.  For example, some <tt>List</tt> implementations
 * provide asymptotically linear access times if they get huge, but constant
 * access times in practice.  Such a <tt>List</tt> implementation
 * should generally implement this interface.  As a rule of thumb, a
 * <tt>List</tt> implementation should implement this interface if,
 * for typical instances of the class, this loop:
 * 随机访问和顺序存取之间的界限通常是模糊的。例如，一些List实现在变得很大时会导致渐进的非
 * 线性访问时间，但实际上是常量访问时间。这样的List实现通常都应该实现该接口。一般来说，某
 * 个List实现如果（对某些典型的类的实例来说）满足下面的条件，就应该实现这个接口：循环
 * <pre>
 *     for (int i=0, n=list.size(); i < n; i++)
 *         list.get(i);
 * </pre>
 * runs faster than this loop:
 * 比下面的循环运行速度快。
 * <pre>
 *     for (Iterator i=list.iterator(); i.hasNext(); )
 *         i.next();
 * </pre>
 *
 * @since 1.4
 */
public interface RandomAccess {
}
```
<font color=red size=5>__*总结：*__</font>RandomAccess是一个空接口，而空接口的作用一般是起到一个标识的作用。 
通俗点讲，就是判断一个list是否实现了RandomAcess接口，如果实现了，采用简单的for循环进行访问速度比较快。 
如果未实现RandomAcess接口，则采用iterator循环访问速度比较快。 
判断使用instanceof，即```if (list instanceof RandomAccess) ```
###### Cloneable

1 Cloneable的用途
Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。
2 克隆的分类

* 浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，而不拷贝对象包含的引用指向的对象。
* 深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。
举例：对象X中包含对Y的引用，Y中包含对Z的引用。浅拷贝X得到X1，X1中依然包含对Y的引用，Y中依然包含对Z的引用。深拷贝则是对浅拷贝的递归，深拷贝X得到X1，X1中包含对Y1（Y的copy）的引用，Y1中包含对Z1（Z的copy）的引用。

3 克隆代码举例
要让对象可以被克隆，应具备以下2个条件：

* 让该类实现java.lang.Cloneable接口；
* 重写（Override）Object的clone()方法；

``` java
public class Info implements Cloneable {

  private int id;

  private String text;

  public Info(int id, String text) {

    this.id = id;

    this.text = text;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    Info temp = (Info) obj;
    if (id != temp.id) return false;
    if (text == null) {
      if (temp.text != null) {
        return false;
      }
    } else if (!text.equals(temp.text)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}

public static void main(String[] args) throws CloneNotSupportedException {
    Info clone = new Info(1, "I am Mp5A5");
    Info clone1 = (Info) clone.clone();


    System.out.println(clone.getClass() == clone1.getClass()); // true

    System.out.println(clone == clone1); // false

    System.out.println(clone.equals(clone1)); // true
  }
```
4 浅克隆

``` java
public class MyFile implements Cloneable {

  private String path;

  public Info info;

  public MyFile(String path, Info info) {

    this.path = path;

    this.info = info;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    MyFile temp = (MyFile) obj;
    if (path == null) {
      if (temp.path != null) {
        return false;
      }
    } else if (!path.equals(temp.path)) {
      return false;
    }

    if (info == null) {
      if (temp.info != null) {
        return false;
      }
    } else if (!info.equals(temp.info)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}

public static void main(String[] args) throws CloneNotSupportedException {

    Info info = new Info(2, "Hello world.");

    MyFile file1 = new MyFile("c:", info);

    MyFile file2 = (MyFile) file1.clone();

    System.out.println(file1.getClass() == file2.getClass()); // true

    System.out.println(file1 == file2); // false

    System.out.println(file1.equals(file2)); // true

    System.out.println(file1.info.getClass() == file2.info.getClass()); // true

    System.out.println(file1.info == file2.info); // true

    System.out.println(file1.info.equals(file2.info)); // true
  }

```
5 深克隆
深克隆需要重写（Override）Object类的clone()方法，并且在方法内部调用持有对象的clone方法

``` java
public class MyFile2 implements Cloneable {

  private String path;

  public Info info;

  public MyFile2(String path, Info info) {

    this.path = path;

    this.info = info;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    if (obj.getClass() != getClass()) return false;
    MyFile2 temp = (MyFile2) obj;
    if (path == null) {
      if (temp.path != null) {
        return false;
      }
    } else if (!path.equals(temp.path)) {
      return false;
    }

    if (info == null) {
      if (temp.info != null) {
        return false;
      }
    } else if (!info.equals(temp.info)) {
      return false;
    }

    return true;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {

    MyFile2 file = (MyFile2) super.clone();
    file.info = (Info) file.info.clone();
    return file;
  }
}

    Info info = new Info(2, "Hello world.");

    MyFile2 file1 = new MyFile2("c:", info);

    MyFile2 file2 = (MyFile2) file1.clone();



    System.out.println(file1.getClass() == file2.getClass());//true

    System.out.println(file1 == file2);//false

    System.out.println(file1.equals(file2));//true

    System.out.println(file1.info.getClass() == file2.info.getClass());//true

    System.out.println(file1.info == file2.info);//false

    System.out.println(file1.info.equals(file2.info));//true
```
##### List
List是一个有序集合(也称为序列)，你可以控制每个元素被插入的位置，和根据索引访问列表中元素。List集合元素可以重复，也可以存入 null 元素。  
List集合是可以根据索引来操纵集合，所以List接口在Collection接口基础增加了一些根据索引操纵集合的接口方法。
![avatar](pic/p83.png)
#### Vector
![avatar](pic/p84.png)
#### Stack
![avatar](pic/p85.png)
#### LinkedList
![avatar](pic/p86.png)
##### AbstractSequentialList
此类提供List接口的骨干实现，以最大限度地减少实现由“顺序访问”数据存储（例如链接列表）支持的此接口所需的工作量。对于随机访问数据（例如数组），应优先使用AbstractList而不是此类。
这个类与AbstractList类相反，它实现了“随机访问”方法（get（int index），set（int index，E element），add（int index，E element）和remove（int index） ））在列表的列表迭代器之上，而不是相反。  
要实现列表，程序员只需要扩展此类并提供listIterator和size方法的实现。对于不可修改的列表，程序员只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。  
对于可修改的列表，程序员还应该实现list迭代器的set方法。对于可变大小的列表，程序员还应该实现列表迭代器的remove和add方法。  
程序员通常应该根据Collection接口规范中的建议提供void（无参数）和集合构造函数。  
此类属于Java集合框架

* 非抽象方法：

1.get方法，通过双向迭代器返回集合中元素
``` java
    public E get(int index) {
        try {
            return listIterator(index).next();
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
2.set方法 通过迭代器设置集合中的元素

``` java
    public E set(int index, E element) {
        try {
            ListIterator<E> e = listIterator(index);
            E oldVal = e.next();
            e.set(element);
            return oldVal;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
 3.add方法通过迭代器添加一个元素
 
``` java
    public void add(int index, E element) {
        try {
            listIterator(index).add(element);
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
4.remove方法 通过迭代器将固定位置的元素拿到集合外面

``` java
    public E remove(int index) {
        try {
            ListIterator<E> e = listIterator(index);
            E outCast = e.next();
            e.remove();
            return outCast;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
    
```
5.addAll方法 通过迭代器在固定位置添加一个集合的元素

``` java
    public boolean addAll(int index, Collection<? extends E> c) {
        try {
            boolean modified = false;
            ListIterator<E> e1 = listIterator(index);
            Iterator<? extends E> e2 = c.iterator();
            while (e2.hasNext()) {
                e1.add(e2.next());
                modified = true;
            }
            return modified;
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
 ```
 6.Iterator方法 返回的是一个listIterator对象
 
``` java
    public Iterator<E> iterator() {
        return listIterator();
    }
```    
* AbstractSequentialList总结
AbstractSequentialList超类的对集合的增删改查操作都是基于迭代器完成的(包括get方法)。AbstractSequentialList可以这么讲，他是一个按次序访问的线性表的简化版，它是一个超类，他规定了其子类必须去实现ListIterator这个接口。必须用迭代的方式完成对线性表的各项操作。当我们在使用AbstractSequentialList的子类对象时，遍历操作最好是使用迭代器，因为for循环的get也是使用迭代器所以我们不要多此一举再去增加个for循环调用迭代方法了

##### Queue
![avatar](pic/p95.png)
Queue一种队列结构集合,用来存储将要进行处理的元素.通常以FIFO的方式排序元素,但这并不是必须的.比如优先度队列就是一个例外,它是以元素的值来排序.但无论怎样,每个Queue的实现都必须指定它的排序属性.Queue通常不定义元素的equal和hashCode方法.

``` java
public interface Queue<E> extends Collection<E> {

// 向队列中添加一个元素
// 如果添加成功则返回true
// 如果队列容量已满则抛出异常
boolean add(E e);

// 向队列中添加一个元素
// 如果添加成功则返回true
// 如果添加失败则返回false
boolean offer(E e);


// 移除对头元素
// 返回对头元素，如果没有对头元素则抛出异常
// throws NoSuchElementException
E remove();

// 移除对头元素
// 返回对头元素，如果没有对头元素则返回null
E poll();

// 返回对头元素，不会删除对头元素
// 如果没有对头元素则抛出异常
// throws NoSuchElementException
E element();

// 返回对头元素，不会删除对头元素
// 如果队列为空，则返回null
E peek();
```

##### Deque
Deque接口是Queue接口的子接口，代表一个双端队列。同时Deque不仅可以作为双端队列使用，而且可以被当成栈来使用，所以可以使用出栈，入栈的方法。

* 特性：

插入、删除、获取操作支持两种形式：快速失败和返回null或true/false
既具有FIFO特点又具有LIFO特点，即是队列又是栈
不推荐插入null元素，null作为特定返回值表示队列为空
未定义基于元素相等的equals和hashCode

* 源码

``` java
// 将指定元素添加到对头
// 如果没有足够的空间则抛出异常
// throw IllegalArgumentException
void addFirst(E e);



// 将指定元素添加到对头
// 如果添加成功则返回true，如果没有足够的空间则返回false
// 如果是使用容量有限的队列，推荐使用该方法而不是addFirst
boolean offerFirst(E e);


// 将指定元素添加到队尾
// 如果没有足够的空间则抛出异常
// throw IllegalArgumentException
void addLast(E e);

// 添加指定元素到队尾
// 如果添加成功则返回true，如果没有足够空间则返回false
// 如果是使用容量有限的队列，推荐使用该方法而不是addLast
boolean offerLast(E e);

// 移除并返回对头元素
// 如果队列为空，则抛出异常
E removeFirst();

// 移除并返回队尾元素
// 如果队列为空，则抛出异常
E removeLast();

// 移除并返回对头元素
// 如果队列为空则返回null
E pollFirst();

// 移除并返回队尾元素
// 如果队列为空则返回null
E pollLast();

// 查询对头元素
// 如果队列为空，则抛出异常
E getFirst();


// 查询队尾元素
// 如果队列为空，则抛出异常
E getLast();

// 查询对头元素
// 如果队列为空，则返回null
E peekFirst();

// 查询队尾元素
// 如果队列为空，则返回null
E peekLast();

// 移除队列中出现的第一个元素
// 移除成功则返回true，如果队列不包含该元素则返回false
boolean removeFirstOccurrence(Object e);

boolean removeLastOccurrence(Object e);

// 以下是栈方法

void push(E e);

E pop();


// 返回一个逆序的迭代器，从队尾到对头
Iterator<E> descendingIterator();

```

##### ArrayBlockingQueue

[ArrayBlockingQueue的详细介绍及源码分析](https://blog.csdn.net/qq_22798455/article/details/81636772)

##### ConcurrentLinkedQueue

[ConcurrentLinkedQueue的详细介绍及源码分析](https://blog.csdn.net/qq_22798455/article/details/81637397)

#### CopyOnWriteArrayList

![avatar](pic/p96.png)

##集合类以及集合框架
##容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类）

##List,Set,Map的区别

##List和Map的实现方式以及存储方式

##HashMap的实现原理

##HashMap数据结构？

##HashMap源码理解

##HashMap如何put数据（从HashMap源码角度讲解）？

##HashMap怎么手写实现？

##ConcurrentHashMap的实现原理

##ArrayMap和HashMap的对比

##HashTable实现原理

##TreeMap具体实现

##HashMap和HashTable的区别

##HashMap与HashSet的区别

##HashSet与HashMap怎么判断集合元素重复？

##集合Set实现Hash怎么防止碰撞

##ArrayList和LinkedList的区别，以及应用场景

##数组和链表的区别

##二叉树的深度优先遍历和广度优先遍历的具体实现

##堆的结构

##堆和树的区别

##堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？

##什么是深拷贝和浅拷贝

##手写链表逆序代码

##讲一下对树，B+树的理解

##讲一下对图的理解

##判断单链表成环与否？

##链表翻转（即：翻转一个单项链表）

##合并多个单有序链表（假设都是递增的）



